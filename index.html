<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hitzkopf ğŸ”¥ V5</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            color: #ffffff; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            text-align: center; 
            padding: 15px; 
            padding-bottom: 80px;
            min-height: 100vh;
        }
        h1 { 
            color: #ff4500; 
            margin: 0 0 15px 0; 
            text-shadow: 0 0 15px rgba(255, 69, 0, 0.7); 
            font-size: 2.2rem; 
            font-weight: 900;
        }
        
        .screen { display: none; animation: fadeIn 0.4s ease-out; }
        .screen.active { display: block; }
        
        .card { 
            background: linear-gradient(145deg, #1e1e1e, #252525);
            padding: 25px; 
            border-radius: 20px; 
            max-width: 480px; 
            margin: 0 auto 20px auto; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.8); 
            border: 1px solid #333;
        }
        
        input, select { 
            width: 100%; 
            padding: 15px; 
            margin: 10px 0; 
            border-radius: 10px; 
            border: 2px solid #444; 
            background: #2c2c2c; 
            color: white; 
            font-size: 16px; 
            text-align: center;
            transition: border-color 0.3s, background 0.3s;
        }
        input:focus, select:focus { 
            outline: none; 
            border-color: #ff4500; 
            background: #333;
        }
        
        button { 
            width: 100%; 
            padding: 16px; 
            margin: 10px 0; 
            border: none; 
            border-radius: 12px; 
            font-size: 18px; 
            font-weight: bold; 
            cursor: pointer; 
            transition: transform 0.15s, box-shadow 0.3s, opacity 0.3s;
        }
        button:hover:not(:disabled) { 
            transform: translateY(-2px); 
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }
        button:active:not(:disabled) { transform: scale(0.97); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-primary { 
            background: linear-gradient(135deg, #ff4500, #ff8c00); 
            color: white;
            box-shadow: 0 4px 15px rgba(255, 69, 0, 0.4);
        }
        .btn-secondary { background: linear-gradient(135deg, #333, #444); color: #fff; }
        .btn-danger { 
            background: linear-gradient(135deg, #dc3545, #c82333); 
            color: white; 
            font-size: 0.95rem; 
            padding: 12px;
        }
        .btn-ready { 
            background: linear-gradient(135deg, #28a745, #20c997); 
            color: white; 
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }
        .btn-ready:disabled { 
            background: #1e5e28; 
            opacity: 0.5; 
            cursor: not-allowed;
            box-shadow: none;
        }

        .thermo-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            gap: 12px; 
            margin-bottom: 20px;
        }
        .thermo-item { 
            background: linear-gradient(145deg, #1a1a1a, #252525);
            padding: 12px; 
            border-radius: 12px; 
            text-align: left; 
            border: 1px solid #333;
            transition: transform 0.2s;
        }
        .thermo-item:hover { transform: translateY(-3px); }
        .thermo-item.top-hot { border-color: #ff8c00; box-shadow: 0 0 12px rgba(255,140,0,0.4); }
        .thermo-item.is-hotseat { border-color: #ff4d4d; box-shadow: 0 0 15px rgba(255,77,77,0.6); }
        .thermo-top { 
            display: flex; 
            justify-content: space-between; 
            font-size: 0.9rem; 
            font-weight: bold; 
            margin-bottom: 8px;
            color: #fff;
        }
        .thermo-bar { 
            height: 8px; 
            background: #333; 
            border-radius: 4px; 
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }
        .thermo-fill { 
            height: 100%; 
            width: 0%; 
            transition: width 0.6s ease-out;
            box-shadow: 0 0 10px currentColor;
        }
        
        .option-row { display: flex; gap: 12px; margin-top: 20px; }
        .btn-option { 
            flex: 1; 
            background: linear-gradient(145deg, #2a2a2a, #1f1f1f);
            border: 3px solid #444; 
            padding: 30px 10px; 
            font-size: 1.2rem; 
            color: #eee;
            transition: all 0.3s;
        }
        .btn-option:hover { 
            border-color: #666;
            background: linear-gradient(145deg, #333, #2a2a2a);
        }
        .btn-option.selected { 
            border-color: #ff4500; 
            background: linear-gradient(145deg, #3e2e2e, #2a1a1a);
            color: #ff4500;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.5);
        }
        
        .category-card {
            aspect-ratio: 1;
            background: linear-gradient(145deg, #1a1a1a, #0f0f0f);
            border: 3px solid #333;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            opacity: 0.4;
        }
        .category-card:hover {
            opacity: 0.6;
            transform: translateY(-2px);
        }
        .category-card.selected {
            opacity: 1;
            border-color: #ff4500;
            background: linear-gradient(145deg, #2a2a2a, #1f1f1f);
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.5);
        }
        .category-card.selected:hover {
            opacity: 1;
        }
        .category-card .category-emoji {
            font-size: 2rem;
        }
        .category-card .category-name {
            font-size: 0.85rem;
            font-weight: 600;
            color: #888;
        }
        .category-card.selected .category-name {
            color: #fff;
        }
        
        .game-mode-card {
            aspect-ratio: 1;
            background: linear-gradient(145deg, #2a2a2a, #1f1f1f);
            border: 3px solid #444;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .game-mode-card:hover {
            border-color: #666;
            background: linear-gradient(145deg, #333, #2a2a2a);
            transform: translateY(-2px);
        }
        .game-mode-card.selected {
            border-color: #ff4500;
            background: linear-gradient(145deg, #3e2e2e, #2a1a1a);
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.5);
        }
        .game-mode-card .mode-emoji {
            font-size: 2rem;
        }
        .game-mode-card .mode-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: #fff;
        }
        .game-mode-card.selected .mode-name {
            color: #ff4500;
        }

        .log-box { 
            background: #0a0a0a; 
            border: 1px solid #333; 
            border-radius: 10px; 
            height: 160px; 
            overflow-y: auto; 
            padding: 12px; 
            margin-top: 15px; 
            text-align: left; 
            font-size: 0.85rem; 
            display: flex; 
            flex-direction: column; 
            gap: 8px;
        }
        .log-box::-webkit-scrollbar { width: 6px; }
        .log-box::-webkit-scrollbar-track { background: #1a1a1a; }
        .log-box::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        
        .log-entry { 
            padding: 8px 10px; 
            border-radius: 6px; 
            background: #1f1f1f; 
            border-left: 3px solid #555;
            animation: slideIn 0.3s ease-out;
        }
        .log-entry.attack { border-left-color: #dc3545; }
        
        .menu-btn { 
            position: fixed; 
            top: 15px; 
            right: 15px; 
            width: 50px; 
            height: 50px; 
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border-radius: 50%; 
            border: 2px solid #444; 
            z-index: 3000; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            font-size: 1.4rem;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            pointer-events: auto;
        }
        .menu-btn:hover { transform: rotate(90deg); border-color: #ff4500; }
        
        .admin-drawer { 
            position: fixed; 
            top: 0; 
            right: -280px; 
            width: 280px; 
            height: 100%; 
            background: linear-gradient(180deg, #111, #0a0a0a);
            border-left: 2px solid #ff4500; 
            z-index: 2001; 
            transition: right 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            padding: 25px; 
            text-align: left; 
            box-shadow: -8px 0 32px rgba(0,0,0,0.9);
            overflow-y: auto;
        }
        .admin-drawer.open { right: 0; }
        
        .overlay { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0,0,0,0.85); 
            z-index: 1999; 
            display: none;
            backdrop-filter: blur(4px);
        }
        .overlay.open { display: block; }

        .hidden { display: none !important; }

        .card-select-btn {
            font-size: 1rem;
            padding: 15px;
            background: linear-gradient(145deg, #2a2a2a, #1f1f1f);
            border: 2px solid #444;
            border-radius: 12px;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            gap: 6px;
            color: #fff;
        }
        .card-select-btn strong { font-size: 1.2rem; }
        .card-select-btn span { font-size: 0.85rem; color: #ddd; }
        .card-select-btn:hover { border-color: #ff8c00; transform: translateY(-2px); }

        .start-actions { display:flex; gap:12px; margin-top:15px; }
        .start-actions button { flex:1; }
        .start-panel { margin-top:15px; padding:15px; border:1px solid #2f2f2f; border-radius:12px; background:rgba(0,0,0,0.2); }
        .share-btn { margin-top:15px; background:linear-gradient(135deg,#1f1f1f,#2e2e2e); color:#fff; font-size:0.95rem; }
        .toast { position:fixed; bottom:-80px; left:50%; transform:translateX(-50%); background:#222; padding:12px 20px; border-radius:20px; color:#fff; box-shadow:0 10px 30px rgba(0,0,0,0.5); transition:bottom 0.3s; z-index:3000; }
        .toast.show { bottom:25px; }
        .attack-alert {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-120%);
            background: #ff4500;
            border: 1px solid #ff9a6b;
            color: #fff;
            padding: 12px 24px;
            border-radius: 999px;
            font-size: 0.95rem;
            font-weight: 600;
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
            transition: transform 0.4s ease, opacity 0.4s ease;
            opacity: 0;
            z-index: 2500;
        }
        .attack-alert.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        body.viewport-shake {
            animation: screenShake 0.6s cubic-bezier(.36,.07,.19,.97);
        }
        @keyframes screenShake {
            10%, 90% { transform: translate3d(-4px, 0, 0); }
            20%, 80% { transform: translate3d(5px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-8px, 0, 0); }
            40%, 60% { transform: translate3d(8px, 0, 0); }
            100% { transform: translate3d(0,0,0); }
        }
        .joker-panel {
            margin-top: 20px;
            background: rgba(255,255,255,0.03);
            border: 1px solid #2e2e2e;
            border-radius: 12px;
            padding: 12px;
        }
        .joker-panel h4 {
            margin-bottom: 8px;
            font-size: 0.95rem;
            color: #ffa45c;
        }
        .joker-strip {
            display: flex;
            gap: 8px;
            justify-content: space-between;
        }
        .joker-chip {
            flex: 1;
            border: 1px dashed #555;
            border-radius: 12px;
            padding: 10px;
            font-size: 0.85rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            color: #888;
            opacity: 0.4;
        }
        .joker-chip strong {
            font-size: 1.2rem;
        }
        .joker-chip.has {
            border-style: solid;
            border-color: #ff8c00;
            color: #fff;
            opacity: 1;
            box-shadow: 0 6px 16px rgba(255,140,0,0.25);
        }
        .joker-chip span {
            font-size: 0.75rem;
            text-align: center;
            color: inherit;
        }
        .countdown-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 4000;
        }
        .countdown-overlay.show { display: flex; }
        .countdown-text {
            font-size: 6rem;
            font-weight: 900;
            color: #ff3b00;
            text-shadow: 0 0 30px rgba(255,59,0,0.7);
            animation: pulse 1s infinite;
        }
        .countdown-sub {
            margin-top: 10px;
            font-size: 1.2rem;
            color: #fff;
            letter-spacing: 0.2rem;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        body.final-mode {
            animation: finalPulse 1.2s infinite;
            background: radial-gradient(circle at center, rgba(255,69,0,0.15), #0a0a0a 70%);
        }
        @keyframes finalPulse {
            0%,100% { background-color: #1a0a0a; }
            50% { background-color: #2d0505; }
        }
        .final-card {
            background: radial-gradient(circle at top, rgba(255,69,0,0.2), #120202);
            border: 2px solid #ff3b00;
        }
        .final-hero {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        .final-emoji {
            font-size: 5rem;
            animation: sweatShake 0.9s infinite;
        }
        @keyframes sweatShake {
            0%,100% { transform: translateY(0); }
            25% { transform: translateY(-4px); }
            50% { transform: translateY(3px); }
            75% { transform: translateY(-2px); }
        }
        .final-name {
            font-size: 2rem;
            font-weight: 800;
            color: #ffae00;
            text-shadow: 0 0 18px rgba(255,174,0,0.6);
        }
        .final-caption {
            margin-top: 8px;
            font-size: 1rem;
            color: #ffd6c1;
        }
        .final-thermo {
            margin: 20px auto;
            width: 80%;
        }
        .final-thermo-track {
            height: 20px;
            border-radius: 10px;
            background: #280000;
            overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.7);
        }
        .final-thermo-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ffae00, #ff0000);
            box-shadow: 0 0 20px rgba(255,0,0,0.7);
            transition: width 1.2s ease-out;
        }
        .final-ranking {
            margin-top: 25px;
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .final-rank-item {
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid #2d2d2d;
            display: flex;
            justify-content: space-between;
            background: rgba(0,0,0,0.35);
            font-size: 0.95rem;
        }
        .final-rank-item.coolest {
            border-color: #00d1ff;
            box-shadow: 0 0 15px rgba(0,209,255,0.3);
            color: #c8f4ff;
        }
        .final-rank-item span {
            color: #aaa;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ffd700;
            position: absolute;
            animation: confetti-fall linear forwards;
        }
        @keyframes confetti-fall {
            to {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        .spectator-mode {
            opacity: 0.6;
            pointer-events: none;
        }
        .spectator-mode .menu-btn {
            pointer-events: auto !important;
            opacity: 1 !important;
        }
        
        .emoji-card {
            aspect-ratio: 1;
            min-width: 80px;
            width: 80px;
            background: rgba(255,255,255,0.05);
            border: 3px solid #333;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            cursor: pointer;
            transition: all 0.3s;
            flex-shrink: 0;
        }
        .emoji-card:hover {
            background: rgba(255,255,255,0.1);
            border-color: #666;
            transform: scale(1.05);
        }
        .emoji-card.selected {
            background: rgba(255,69,0,0.2);
            border-color: #ff4500;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.5);
            transform: scale(1.1);
        }
        
        #emojiGallery {
            scrollbar-width: thin;
            scrollbar-color: #444 #1a1a1a;
            position: relative;
        }
        #emojiGallery::after {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 50%;
            background: linear-gradient(to right, transparent, rgba(10,10,10,0.8));
            pointer-events: none;
            z-index: 1;
        }
        #emojiGallery::-webkit-scrollbar {
            height: 6px;
        }
        #emojiGallery::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 3px;
        }
        #emojiGallery::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 3px;
        }
        #emojiGallery::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        .spectator-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: linear-gradient(135deg, #ff4500, #ff8c00);
            color: white;
            padding: 15px;
            text-align: center;
            font-weight: bold;
            z-index: 3000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        @keyframes fadeIn { 
            from { opacity: 0; transform: translateY(20px); } 
            to { opacity: 1; transform: translateY(0); } 
        }
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }
        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 
            10%, 90% { transform: translate3d(-2px, 0, 0); } 
            20%, 80% { transform: translate3d(3px, 0, 0); } 
            30%, 50%, 70% { transform: translate3d(-5px, 0, 0); } 
            40%, 60% { transform: translate3d(5px, 0, 0); } 
        }
    </style>
</head>
<body>
    <div class="menu-btn" onclick="toggleMenu()">âš™ï¸</div>
    <div id="attackAlert" class="attack-alert"></div>
    <div id="countdownOverlay" class="countdown-overlay">
        <div id="countdownText" class="countdown-text" style="font-size:4rem; line-height:1.2;">Hitz<br>kopf</div>
        <div class="countdown-sub">Bereit machen...</div>
    </div>
    <!-- ANLEITUNG OVERLAY -->
    <div id="rulesOverlay" class="countdown-overlay" style="display:none;">
        <div style="background:linear-gradient(145deg, #1e1e1e, #252525); padding:30px; border-radius:20px; max-width:500px; margin:20px; border:2px solid #ff4500; box-shadow:0 8px 32px rgba(0,0,0,0.8);">
            <h2 style="color:#ff4500; margin-bottom:20px; font-size:1.8rem;">ğŸ“– Anleitung</h2>
            <div style="text-align:left; font-size:1rem; line-height:1.6; color:#fff; margin-bottom:25px;">
                <p style="margin-bottom:12px;">ğŸ¯ <strong>Ziel:</strong> Errate die Antworten deiner Freunde und bringe sie zum kochen!</p>
                <p style="margin-bottom:12px;">ğŸ”¥ <strong>Verlierer:</strong> Wer als erstes 100Â° erreicht, fliegt raus.</p>
                <p style="margin-bottom:12px;">ğŸ§Š <strong>Gewinner:</strong> Bewahrst du einen kÃ¼hlen Kopf, entscheidest du das Spiel fÃ¼r dich.</p>
                <p style="margin-bottom:0;">ğŸ’¡ <strong>Tipp:</strong> Bei richtigem Raten kannst du Gegner aufheizen oder Joker ziehen!</p>
            </div>
            <button onclick="closeRulesOverlay()" class="btn-primary" style="width:100%; padding:15px; font-size:1.1rem;">Verstanden âœ“</button>
        </div>
    </div>
    <div class="overlay" id="menuOverlay" onclick="toggleMenu()"></div>
    <div class="admin-drawer" id="adminDrawer">
        <h3 style="color:#ff4500; border-bottom:2px solid #333; padding-bottom:12px; margin-bottom:15px;">âš™ï¸ MenÃ¼</h3>
        
        <div id="hostControls" style="display:none;">
            <p style="font-size:0.75rem; color:#888; margin-bottom:8px; text-transform:uppercase;">Host-Steuerung:</p>
            <button style="padding:12px; font-size:0.85rem; margin:8px 0; background:#333; border-radius:8px;" onclick="forceNextRound()">â© Runde erzwingen</button>
            <button style="padding:12px; font-size:0.85rem; margin:8px 0; background:#550000; border-radius:8px;" onclick="resetGame()">ğŸ”„ Spiel neustarten</button>
            <button style="padding:12px; font-size:0.85rem; margin:8px 0; background:#880000; border-radius:8px;" onclick="killLobby()">ğŸ§¨ Lobby lÃ¶schen</button>
            <hr style="border:none; border-top:1px solid #333; margin:20px 0;">
        </div>

        <button style="padding:12px; font-size:0.85rem; margin:8px 0; background:#444; border-radius:8px;" onclick="leaveLobby()">ğŸ‘‹ Lobby verlassen</button>
    </div>

    <h1>ğŸ”¥ Hitzkopf</h1>

    <!-- START SCREEN -->
    <div id="screen-start" class="screen active card">
        <h3 style="margin-bottom:15px; color:#ff8c00;">Wie heiÃŸt du?</h3>
        <input type="text" id="inpName" placeholder="Dein Name" maxlength="20" autocomplete="off">
        <label style="display:block; font-size:0.85rem; color:#aaa; margin-top:15px; margin-bottom:8px; font-weight:500;">WÃ¤hle deinen Charakter:</label>
        <div style="position:relative; margin-bottom:15px;">
            <div id="emojiGallery" style="display:flex; gap:10px; overflow-x:auto; overflow-y:hidden; padding:10px 0; scroll-behavior:smooth; -webkit-overflow-scrolling:touch; width:100%; max-width:100%;">
                <!-- Wird dynamisch gefÃ¼llt -->
            </div>
            <input type="hidden" id="inpEmoji" value="ğŸ˜Š">
        </div>
        
        <div class="start-actions">
            <button class="btn-primary" onclick="openHostSettings()">ğŸ® Spiel erstellen</button>
            <button class="btn-secondary" onclick="openJoinPanel()">ğŸšª Spiel beitreten</button>
        </div>

        <div id="hostSettings" class="start-panel hidden">
            <p style="font-size:0.85rem; color:#ccc; margin-bottom:8px; font-weight:600;">âš™ï¸ Host-Einstellungen</p>
            <label style="display:block; font-size:0.85rem; color:#aaa; margin-bottom:5px; font-weight:500;">Spielmodus:</label>
            <div id="gameModeSelection" style="display:grid; grid-template-columns:repeat(2, 1fr); gap:10px; margin-top:10px; margin-bottom:15px;">
                <div class="game-mode-card selected" data-mode="party" onclick="toggleGameMode('party')">
                    <div class="mode-emoji">âš¡</div>
                    <div class="mode-name">Party-Modus</div>
                    <div style="font-size:0.7rem; color:#aaa; margin-top:5px;">Schnell & einfach</div>
                </div>
                <div class="game-mode-card" data-mode="strategisch" onclick="toggleGameMode('strategisch')">
                    <div class="mode-emoji">ğŸ•</div>
                    <div class="mode-name">Strategie-Modus</div>
                    <div style="font-size:0.7rem; color:#aaa; margin-top:5px;">Mit Joker & Taktik</div>
                </div>
            </div>
            <label style="display:block; font-size:0.85rem; color:#aaa; margin-top:12px; margin-bottom:5px; font-weight:500;">WÃ¤hle Fragenkategorien:</label>
            <div id="categorySelection" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(140px, 1fr)); gap:10px; margin-top:10px; margin-bottom:15px;">
                <!-- Wird dynamisch gefÃ¼llt -->
            </div>
            <label style="display:block; font-size:0.85rem; color:#aaa; margin-top:15px; margin-bottom:5px; font-weight:500;">ğŸ”’ Raum-Passwort (optional):</label>
            <input type="password" id="inpRoomPassword" placeholder="Leer lassen fÃ¼r Ã¶ffentlichen Raum" style="margin-bottom:5px;" autocomplete="off">
            <p style="font-size:0.7rem; color:#666; margin-top:5px; margin-bottom:15px;">âš ï¸ Mit Passwort kÃ¶nnen nur Spieler mit dem Code + Passwort beitreten</p>
            <button class="btn-primary" onclick="createGame()" style="margin-top:15px;">ğŸ® Spiel erstellen</button>
        </div>

        <div id="joinPanel" class="start-panel hidden">
            <p style="font-size:0.85rem; color:#ccc; margin-bottom:8px; font-weight:600;">ğŸ¤ Spiel beitreten</p>
            <div id="roomList" style="max-height:300px; overflow-y:auto; margin-bottom:15px; display:none;">
                <!-- Wird dynamisch gefÃ¼llt -->
            </div>
            <input type="text" id="inpCode" placeholder="Raum-Code" style="text-transform:uppercase; display:none;" maxlength="6" autocomplete="off" oninput="this.value = this.value.toUpperCase();">
            <input type="password" id="inpPassword" placeholder="Passwort (optional)" style="display:none; margin-top:10px;" autocomplete="off">
            <button class="btn-secondary" onclick="joinGame()" id="btnJoinGame">ğŸšª Beitreten</button>
            <button class="btn-secondary" onclick="loadRoomList()" style="margin-top:10px; font-size:0.9rem; padding:10px;">ğŸ”„ RÃ¤ume aktualisieren</button>
        </div>
    </div>
    
    <!-- ANLEITUNG BUTTON (auÃŸerhalb des Kastens, nur auf Start-Screen) -->
    <div id="anleitungButton" style="max-width:480px; margin:20px auto 0 auto; display:none;">
        <button onclick="openRulesOverlay()" class="btn-secondary" style="width:100%; padding:12px; font-size:0.95rem; margin-top:10px;">ğŸ“– Anleitung</button>
    </div>

    <!-- LOBBY SCREEN -->
    <div id="screen-lobby" class="screen card">
        <div id="lobbyList" style="margin:25px 0; font-weight:bold; font-size:1.15rem; color:#fff;"></div>
        <div id="lobbyReadyList" style="font-size:0.9rem; color:#aaa; margin-bottom:15px;"></div>
        <button id="btnLobbyReady" class="btn-secondary" onclick="toggleLobbyReady()">âœ… Bereit</button>
        <div id="lobbyReadyStatus" style="font-size:0.85rem; color:#777; margin-top:5px;"></div>
        <button id="btnHostStart" class="btn-primary" style="display:none;" onclick="startCountdown()">ğŸ”¥ Spiel starten</button>
        <button id="btnShare" class="share-btn" style="display:none;" onclick="shareLobby()">ğŸ“¤ Link teilen</button>
        <p id="lblWait" style="color:#666; font-size:0.9rem;">â³ Warte auf Host...</p>
    </div>

    <!-- GAME SCREEN -->
    <div id="screen-game" class="screen card">
        <div id="gridGame" class="thermo-grid"></div>
        <hr style="border-color:#333; margin:15px 0;">
        
        <div style="margin-bottom:15px;">
            <span style="font-size:2rem;">ğŸ¥µ</span>
            <div id="lblHotseat" style="font-weight:bold; font-size:1.3rem; color:#ff4500;">...</div>
            <p id="lblHotseatSub" style="font-size:0.85rem; color:#aaa; margin-top:4px;"></p>
        </div>
        
        <h3 id="lblQuestion" style="margin:20px 0; min-height:60px; display:flex; align-items:center; justify-content:center;">Lade Frage...</h3>
        <p id="lblQuestionCategory" style="font-size:0.8rem; color:#888; margin-top:-10px; margin-bottom:10px; font-style:italic;"></p>

        <div class="option-row" id="optionRow" style="margin-top:15px;">
            <button id="btnA" class="btn-option" onclick="vote('A')">A</button>
            <button id="btnB" class="btn-option" onclick="vote('B')">B</button>
        </div>

        <button id="btnLock" class="btn-primary" style="margin-top:20px;" onclick="submitVote()">ğŸ”’ Antwort absenden</button>
        <div id="lblVoteStatus" style="font-size:0.8rem; color:#888; margin-top:10px;"></div>
        <div class="joker-panel" id="jokerPanelGame">
            <h4>Deine Joker</h4>
            <div id="myJokerListGame" class="joker-strip"></div>
        </div>
    </div>

    <!-- RESULT SCREEN -->
    <div id="screen-result" class="screen card">
        <div id="gridResult" class="thermo-grid"></div>
        
        <h3>Die Wahrheit: <span id="lblTruth" style="color:#fff;">?</span></h3>
        <p id="lblResultCategory" style="font-size:0.8rem; color:#888; margin-top:-10px; margin-bottom:10px; font-style:italic;"></p>
        <h2 id="lblResultStatus" style="margin:10px 0;">...</h2>

        <div id="boxReward" style="display:none; background:#2a3a1a; padding:15px; border-radius:10px; margin-bottom:15px; border:2px solid #4a6a2a;">
            <h4 style="margin:0 0 12px 0; color:#8fef8f;">ğŸ Belohnung wÃ¤hlen:</h4>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <button onclick="chooseReward('attack')" style="background:linear-gradient(135deg, #dc3545, #c82333); color:white; padding:20px; border-radius:10px; border:none; font-size:1.1rem; font-weight:bold; cursor:pointer; transition:transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ğŸ”´ Gegner aufheizen
                </button>
                <button onclick="chooseReward('invest')" style="background:linear-gradient(135deg, #1a2a3a, #2a3a4a); color:white; padding:20px; border-radius:10px; border:none; font-size:1.1rem; font-weight:bold; cursor:pointer; transition:transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ğŸƒ Joker ziehen
                </button>
            </div>
        </div>

        <div id="boxAttack" style="display:none; background:#3a1a1a; padding:10px; border-radius:10px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0;" id="attackTitle">ğŸ”¥ Wen aufheizen?</h4>
            <div id="divTargets" style="display:grid; grid-template-columns:1fr 1fr; gap:5px;"></div>
            <div style="display:flex; gap:5px; margin-top:10px;" id="attackControls">
                <button style="flex:1; background:transparent; border:1px solid #666; color:#aaa; font-size:0.85rem; padding:8px; display:none;" onclick="goBackToReward()" id="btnBackFromAttack">â† ZurÃ¼ck</button>
                <button style="flex:1; background:transparent; border:1px solid #666; color:#aaa; font-size:0.85rem; padding:8px; display:none;" onclick="skipAttack()" id="btnSkipAttack">Angriff Ã¼berspringen</button>
            </div>
        </div>

        <div id="boxShop" style="display:none; background:#1a2a3a; padding:10px; border-radius:10px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0;">ğŸƒ Joker-Karte wÃ¤hlen:</h4>
            <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px;">
                <button class="card-select-btn" onclick="takeCard('card_oil')">
                    <strong>ğŸ›¢ï¸ Ã–lfass</strong>
                    <span>Verdoppelt deinen nÃ¤chsten Angriff.</span>
                </button>
                <button class="card-select-btn" onclick="takeCard('card_mirror')">
                    <strong>ğŸª Spiegel</strong>
                    <span>Der nÃ¤chste Angriff prallt zurÃ¼ck.</span>
                </button>
                <button class="card-select-btn" onclick="takeCard('card_ice')">
                    <strong>ğŸ§Š EiswÃ¼rfel</strong>
                    <span>KÃ¼hlt dich in der nÃ¤chsten Runde automatisch ab.</span>
                </button>
            </div>
            <button style="width:100%; background:transparent; border:1px solid #666; color:#aaa; font-size:0.85rem; margin-top:10px; padding:8px;" onclick="goBackToReward()">â† ZurÃ¼ck</button>
        </div>

        <div style="text-align:left; font-size:0.7rem; color:#666; margin-bottom:5px;">ğŸ“‹ Spielverlauf:</div>
        <div id="divLog" class="log-box"></div>

        <button id="btnReady" class="btn-ready" onclick="setReady()">ğŸ‘ Bereit</button>
        <div id="lblReady" style="font-size:0.8rem; color:#666; margin-top:5px;"></div>
        <div class="joker-panel" style="margin-top:20px;">
            <h4>Deine Joker</h4>
            <div id="myJokerListResult" class="joker-strip"></div>
        </div>
    </div>

    <!-- FULLSCREEN ANIMATION OVERLAY -->
    <div id="fullscreenAnimation" class="countdown-overlay" style="display:none;">
        <div style="background:linear-gradient(145deg, #1e1e1e, #252525); padding:40px; border-radius:20px; max-width:600px; margin:20px; border:2px solid #ff4500; box-shadow:0 8px 32px rgba(0,0,0,0.8); text-align:center;">
            <div id="animEmoji" style="font-size:5rem; margin-bottom:20px; animation:sweatShake 0.9s infinite;">ğŸ¥µ</div>
            <div id="animName" style="font-size:2.5rem; font-weight:800; color:#ff4500; margin-bottom:15px; text-shadow:0 0 18px rgba(255,69,0,0.6);">...</div>
            <div id="animText" style="font-size:1.2rem; color:#fff; margin-bottom:25px;">...</div>
            <div style="width:80%; margin:0 auto 20px auto;">
                <div style="height:25px; border-radius:12px; background:#280000; overflow:hidden; box-shadow:inset 0 0 10px rgba(0,0,0,0.7);">
                    <div id="animThermoFill" style="height:100%; width:0%; background:linear-gradient(90deg, #ffae00, #ff0000); box-shadow:0 0 20px rgba(255,0,0,0.7); transition:width 1.2s ease-out;"></div>
                </div>
                <div id="animTemp" style="font-size:1.5rem; font-weight:bold; color:#ff4500; margin-top:10px;">0Â°C</div>
            </div>
            <div id="animCounter" style="font-size:0.9rem; color:#888; margin-top:15px; display:none;">Angriff 1 von 3</div>
        </div>
    </div>

    <!-- ROUND RECAP OVERLAY -->
    <div id="roundRecapOverlay" class="countdown-overlay" style="display:none;">
        <div style="background:linear-gradient(145deg, #1e1e1e, #252525); padding:40px; border-radius:20px; max-width:700px; margin:20px; border:2px solid #ff4500; box-shadow:0 8px 32px rgba(0,0,0,0.8); text-align:center;">
            <h2 style="color:#ff4500; margin-bottom:30px; font-size:2rem;">ğŸ“Š Runden-Rekapitulation</h2>
            <div id="recapContent" style="min-height:400px;">
                <!-- Wird dynamisch gefÃ¼llt -->
            </div>
            <button onclick="closeRoundRecap()" class="btn-primary" style="margin-top:20px; padding:15px 30px; font-size:1.1rem;">Weiter â­ï¸</button>
        </div>
    </div>

    <!-- WINNER SCREEN -->
    <div id="screen-winner" class="screen card" style="background:radial-gradient(circle at center, rgba(0,209,255,0.15), #0a0a0a 70%); border:2px solid #00d1ff;">
        <div id="confetti-container" style="position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:5000;"></div>
        <div style="text-align:center; position:relative; z-index:1;">
            <div id="winnerEmoji" style="font-size:6rem; margin-bottom:20px; animation:sweatShake 0.9s infinite;">ğŸ˜</div>
            <div id="winnerName" style="font-size:3rem; font-weight:900; color:#00d1ff; margin-bottom:15px; text-shadow:0 0 30px rgba(0,209,255,0.7);">...</div>
            <div style="font-size:1.3rem; color:#c8f4ff; margin-bottom:30px;">ist cool geblieben und gewinnt diese Runde Hitzkopf! ğŸ§Š</div>
            <div style="width:80%; margin:0 auto 30px auto;">
                <div style="height:30px; border-radius:15px; background:#001a28; overflow:hidden; box-shadow:inset 0 0 15px rgba(0,0,0,0.7);">
                    <div id="winnerThermoFill" style="height:100%; width:0%; background:linear-gradient(90deg, #00d1ff, #0080ff); box-shadow:0 0 25px rgba(0,209,255,0.7); transition:width 1.5s ease-out;"></div>
                </div>
                <div id="winnerTemp" style="font-size:2rem; font-weight:bold; color:#00d1ff; margin-top:15px;">0Â°C</div>
            </div>
            <hr style="border-color:#003d5c; margin:30px 0;">
            <div id="rankingList" style="text-align:left; margin-top:20px;">
                <!-- Wird dynamisch gefÃ¼llt -->
            </div>
        </div>
    </div>

    <!-- VOTING SCREEN -->
    <div id="screen-voting" class="screen card">
        <h2 style="color:#ff8c00; margin-bottom:20px;">ğŸ® Spiel beendet!</h2>
        <p style="color:#aaa; margin-bottom:30px;">MÃ¶chtest du noch eine Runde spielen?</p>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:20px;">
            <button id="btnVoteRematch" class="btn-primary" onclick="voteRematch(true)" style="padding:20px; font-size:1.2rem;">âœ… Nochmal spielen</button>
            <button id="btnVoteLeave" class="btn-secondary" onclick="voteRematch(false)" style="padding:20px; font-size:1.2rem;">ğŸšª Verlassen</button>
        </div>
        <div id="votingStatus" style="font-size:0.9rem; color:#888; margin-top:15px;">Warte auf andere Spieler...</div>
        <div id="votingResults" style="margin-top:20px; font-size:0.85rem; color:#aaa;"></div>
    </div>

    <!-- GAMEOVER SCREEN (fÃ¼r rausgeflogene Spieler) -->
    <div id="screen-gameover" class="screen card final-card">
        <div class="final-hero">
            <div id="finalEmoji" class="final-emoji">ğŸ¥µ</div>
            <div>
                <div id="lblLoser" class="final-name">...</div>
                <div id="lblFinalText" class="final-caption">...</div>
            </div>
        </div>
        <div class="final-thermo">
            <div class="final-thermo-track">
                <div id="finalThermoFill" class="final-thermo-fill"></div>
            </div>
        </div>
        <div id="finalRanking" class="final-ranking"></div>
        <button id="btnRematch" style="background:#ff4500; margin-top:25px;" onclick="rematchGame()">â™»ï¸ Revanche starten</button>
        <button style="background:#444; margin-top:10px;" onclick="leaveLobby()">ğŸšª Lobby verlassen</button>
    </div>
    <div id="toast" class="toast"></div>
    <script type="module">
        // --- FIREBASE SETUP ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, arrayUnion, arrayRemove, onSnapshot, increment, deleteDoc, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBQ7c9JkZ3zWlyIjZLl1O1sJJOrKfYJbmA",
            authDomain: "hitzkopf-f0ea6.firebaseapp.com",
            projectId: "hitzkopf-f0ea6",
            storageBucket: "hitzkopf-f0ea6.firebasestorage.app",
            messagingSenderId: "828164655874",
            appId: "1:828164655874:web:1cab759bdb03bfb736101b"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- STATE ---
        let myName = sessionStorage.getItem("hk_name") || "";
        let myEmoji = sessionStorage.getItem("hk_emoji") || "ğŸ˜Š";
        let myGender = sessionStorage.getItem("hk_gender") || "divers"; // Deaktiviert, aber behalten
        let roomId = sessionStorage.getItem("hk_room") || "";
        let isHost = false;
        let localActionDone = false;
        let mySelection = null;
        let myStrategy = null;
        let globalData = null;
        let lastRoundId = null;
        let loggedRoundResult = null;
        let lobbyClosedHandled = false;
        let lastTemps = {};
        let lastMyTemp = null;
        let attackAlertTimer = null;
        let countdownInterval = null;
        let countdownTarget = null;
        let rulesShown = false;
        
        // --- EMOJI SELECTION ---
        const baseEmojis = ['ğŸ˜Š', 'ğŸ˜', 'ğŸ¤ ', 'ğŸ¥³', 'ğŸ˜„', 'ğŸ¤©', 'ğŸ˜‡', 'ğŸ§', 'ğŸ¤“', 'ğŸ˜‹', 'ğŸ·', 'ğŸ‘»', 'ğŸ„', 'ğŸ¶', 'ğŸ±', 'ğŸ¼', 'ğŸ¦', 'ğŸ¸', 'ğŸ¦Š', 'ğŸ¨'];
        // ZufÃ¤llige Reihenfolge der Emojis
        const availableEmojis = [...baseEmojis].sort(() => Math.random() - 0.5);
        let currentEmojiIndex = 0;
        
        window.selectEmoji = (emoji) => {
            const inpEmoji = document.getElementById('inpEmoji');
            if(inpEmoji) inpEmoji.value = emoji;
            myEmoji = emoji;
            currentEmojiIndex = availableEmojis.indexOf(emoji);
            
            // Aktualisiere visuelle Auswahl
            const gallery = document.getElementById('emojiGallery');
            if(gallery) {
                gallery.querySelectorAll('.emoji-card').forEach((card) => {
                    const cardEmoji = card.getAttribute('data-emoji');
                    if(cardEmoji === emoji) {
                        card.classList.add('selected');
                        // Scroll zu ausgewÃ¤hltem Emoji
                        card.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                    } else {
                        card.classList.remove('selected');
                    }
                });
            }
        };
        
        // Initialisiere Emoji-Galerie
        if(document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initEmojiGallery);
        } else {
            initEmojiGallery();
        }
        
        function initEmojiGallery() {
            const gallery = document.getElementById('emojiGallery');
            const inpEmoji = document.getElementById('inpEmoji');
            if(!gallery || !inpEmoji) return;
            
            // Finde aktuelles Emoji
            let currentEmoji = myEmoji || 'ğŸ˜Š';
            if(!availableEmojis.includes(currentEmoji)) {
                currentEmoji = availableEmojis[0];
            }
            currentEmojiIndex = availableEmojis.indexOf(currentEmoji);
            
            // Erstelle Galerie
            gallery.innerHTML = availableEmojis.map((emoji, idx) => {
                const isSelected = emoji === currentEmoji;
                return `
                    <div class="emoji-card ${isSelected ? 'selected' : ''}" onclick="selectEmoji('${emoji}')" data-emoji="${emoji}">
                        ${emoji}
                    </div>
                `;
            }).join('');
            
            inpEmoji.value = currentEmoji;
            myEmoji = currentEmoji;
            
            // Positioniere so dass nur 1.5 Emojis sichtbar sind (scroll auf Position 0)
            setTimeout(() => {
                gallery.scrollLeft = 0;
            }, 100);
            
            // Initialisiere Anleitung-Button Sichtbarkeit
            const anleitungBtn = document.getElementById('anleitungButton');
            const startScreen = document.getElementById('screen-start');
            if(anleitungBtn && startScreen) {
                anleitungBtn.style.display = startScreen.classList.contains('active') ? 'block' : 'none';
            }
        }
        
        // --- GENDERING FUNCTION ---
        function genderText(text, gender = myGender) {
            if(!text || typeof text !== 'string') return text;
            const patterns = {
                mÃ¤nnlich: { 'er/ihn': 'er', 'ihn': 'ihn', 'sein': 'sein', 'seine': 'seine', 'seinen': 'seinen', 'seiner': 'seiner' },
                weiblich: { 'er/ihn': 'sie', 'ihn': 'sie', 'sein': 'ihr', 'seine': 'ihre', 'seinen': 'ihren', 'seiner': 'ihrer' },
                divers: { 'er/ihn': 'sie', 'ihn': 'sie', 'sein': 'ihr', 'seine': 'ihre', 'seinen': 'ihren', 'seiner': 'ihrer' }
            };
            const replacements = patterns[gender] || patterns.divers;
            let result = text;
            Object.keys(replacements).forEach(key => {
                const regex = new RegExp(`\\b${key}\\b`, 'gi');
                result = result.replace(regex, replacements[key]);
            });
            return result;
        }
        
        function getGenderPronoun(gender = myGender) {
            const pronouns = {
                mÃ¤nnlich: { subject: 'er', object: 'ihn', possessive: 'sein', possessiveAdj: 'seine' },
                weiblich: { subject: 'sie', object: 'sie', possessive: 'ihr', possessiveAdj: 'ihre' },
                divers: { subject: 'sie', object: 'sie', possessive: 'ihr', possessiveAdj: 'ihre' }
            };
            return pronouns[gender] || pronouns.divers;
        }

        const sleep = (ms = 0) => new Promise(res => setTimeout(res, ms));

        // Fragenstruktur in Kategorien organisiert
        const questionCategories = {
            "astronomie_geographie": {
                name: "Astronomie & Geographie",
                emoji: "ğŸŒ",
                questions: [
                    { q: "Lieber Tag oder Nacht?", a: "Tag â˜€ï¸", b: "Nacht ğŸŒ™" },
                    { q: "Lieber Regenwald oder WÃ¼ste?", a: "Regenwald ğŸŒ³ğŸ’§", b: "WÃ¼ste ğŸœï¸â˜€ï¸" },
                    { q: "Lieber Ozean oder Gebirge?", a: "Ozean ğŸŒŠ", b: "Gebirge â›°ï¸" },
                    { q: "Lieber Nordpol oder SÃ¼dpol?", a: "Nordpol ğŸ»â€â„ï¸", b: "SÃ¼dpol ğŸ§" },
                    { q: "Lieber StÃ¤dtereise oder Naturreise?", a: "Stadt ğŸ™ï¸", b: "Natur ğŸï¸" },
                    { q: "Lieber Kontinental oder Insel?", a: "Kontinental ğŸ—ºï¸", b: "Insel ğŸï¸" },
                    { q: "Lieber heiÃŸe oder kalte Klimazone?", a: "HeiÃŸ ğŸŒ", b: "Kalt â„ï¸" },
                    { q: "Lieber Regen oder Schnee?", a: "Regen ğŸŒ§ï¸", b: "Schnee â„ï¸" },
                    { q: "Lieber Sonne oder Mond beobachten?", a: "Sonne â˜€ï¸", b: "Mond ğŸŒ™" },
                    { q: "Lieber Flachland oder Hochland?", a: "Flachland ğŸŒ¾", b: "Hochland ğŸ”ï¸" },
                    { q: "Lieber Fluss oder See?", a: "Fluss ğŸŒŠ", b: "See ğŸï¸" },
                    { q: "Lieber tropisch oder gemÃ¤ÃŸigt?", a: "Tropisch ğŸŒ´", b: "GemÃ¤ÃŸigt ğŸƒ" },
                    { q: "Lieber MeereskÃ¼ste oder Seenlandschaft?", a: "MeereskÃ¼ste ğŸŒŠ", b: "Seenlandschaft ğŸï¸" },
                    { q: "Lieber Vulkan oder Geysir?", a: "Vulkan ğŸŒ‹", b: "Geysir ğŸ’¨" },
                    { q: "Lieber Regenzeit oder Trockenzeit?", a: "Regenzeit ğŸŒ§ï¸", b: "Trockenzeit â˜€ï¸" },
                    { q: "Lieber Polarlicht oder Sonnenuntergang?", a: "Polarlicht ğŸŒŒ", b: "Sonnenuntergang ğŸŒ…" },
                    { q: "Lieber Kontinent oder Ozean?", a: "Kontinent ğŸ—ºï¸", b: "Ozean ğŸŒŠ" },
                    { q: "Lieber Wettervorhersage oder Ã¼berrascht werden?", a: "Vorhersage ğŸ“¡", b: "Ãœberraschung ğŸ²" },
                    { q: "Lieber HÃ¶henluft oder MeereshÃ¶he?", a: "HÃ¶henluft â›°ï¸", b: "MeereshÃ¶he ğŸ–ï¸" },
                    { q: "Lieber Erdmagnetfeld oder Schwerkraft?", a: "Magnetfeld ğŸ§²", b: "Schwerkraft â¬‡ï¸" }
                ]
            },
            "essen_trinken": {
                name: "Essen & Trinken",
                emoji: "ğŸ½ï¸",
                questions: [
                    { q: "Lieber Butter oder Margarine?", a: "Butter ğŸ§ˆ", b: "Margarine ğŸ¥„" },
                    { q: "Lieber Kaffee oder Tee?", a: "Kaffee â˜•", b: "Tee ğŸµ" },
                    { q: "Lieber Pizza oder Pasta?", a: "Pizza ğŸ•", b: "Pasta ğŸ" },
                    { q: "Lieber Schokolade oder GummibÃ¤rchen?", a: "Schokolade ğŸ«", b: "GummibÃ¤rchen ğŸ»" },
                    { q: "Lieber Burger oder DÃ¶ner?", a: "Burger ğŸ”", b: "DÃ¶ner ğŸ¥™" },
                    { q: "Lieber kochen oder bestellen?", a: "Kochen ğŸ§‘â€ğŸ³", b: "Bestellen ğŸ›µ" },
                    { q: "Lieber Vanille oder Schokoeis?", a: "Vanille ğŸ¤ğŸ¦", b: "Schoko ğŸ¤ğŸ¦" },
                    { q: "Lieber Popcorn sÃ¼ÃŸ oder salzig?", a: "SÃ¼ÃŸ ğŸ¬ğŸ¿", b: "Salzig ğŸ§‚ğŸ¿" },
                    { q: "Lieber Wein oder Bier?", a: "Wein ğŸ·", b: "Bier ğŸº" },
                    { q: "Lieber KÃ¤se oder Wurst?", a: "KÃ¤se ğŸ§€", b: "Wurst ğŸ¥“" },
                    { q: "Lieber Spiegelei oder RÃ¼hrei?", a: "Spiegelei ğŸ³ğŸ‘ï¸", b: "RÃ¼hrei ğŸ¥šğŸ¥£" },
                    { q: "Lieber Limo oder Saft?", a: "Limo ğŸ¥¤", b: "Saft ğŸ§ƒ" },
                    { q: "Lieber Torte oder Kuchen?", a: "Torte ğŸ‚", b: "Kuchen ğŸ°" },
                    { q: "Lieber Ketchup oder Mayo?", a: "Ketchup ğŸ…", b: "Mayo ğŸ¥š" },
                    { q: "Lieber Salat oder Suppe?", a: "Salat ğŸ¥—", b: "Suppe ğŸ¥£" },
                    { q: "Lieber Marmelade oder Honig?", a: "Marmelade ğŸ“", b: "Honig ğŸ¯" },
                    { q: "Lieber Kartoffeln oder Reis?", a: "Kartoffeln ğŸ¥”", b: "Reis ğŸš" },
                    { q: "Lieber sÃ¼ÃŸ oder herzhaft frÃ¼hstÃ¼cken?", a: "SÃ¼ÃŸ ğŸ¥ğŸ¬", b: "Herzhaft ğŸ¥“ğŸ³" },
                    { q: "Lieber KÃ¤seplatte oder Obstteller?", a: "KÃ¤se ğŸ§€ğŸ‡", b: "Obst ğŸ¥ğŸ" },
                    { q: "Lieber Apfelkuchen oder KÃ¤sekuchen?", a: "Apfelkuchen ğŸğŸ°", b: "KÃ¤sekuchen ğŸ§€ğŸ°" }
                ]
            },
            "flora_fauna": {
                name: "Flora & Fauna",
                emoji: "ğŸŒ¿",
                questions: [
                    { q: "Lieber Hund oder Katze?", a: "Hund ğŸ•", b: "Katze ğŸˆ" },
                    { q: "Lieber Blumen oder BÃ¤ume?", a: "Blumen ğŸŒ¸", b: "BÃ¤ume ğŸŒ³" },
                    { q: "Lieber VÃ¶gel oder Fische beobachten?", a: "VÃ¶gel ğŸ¦", b: "Fische ğŸ " },
                    { q: "Lieber Rosen oder Sonnenblumen?", a: "Rosen ğŸŒ¹", b: "Sonnenblumen ğŸŒ»" },
                    { q: "Lieber Haus- oder Wildtier?", a: "Haustier ğŸ•", b: "Wildtier ğŸ¦" },
                    { q: "Lieber Garten oder Wald?", a: "Garten ğŸŒ³", b: "Wald ğŸŒ²" },
                    { q: "Lieber Kraut oder BlÃ¼te?", a: "Kraut ğŸŒ¿", b: "BlÃ¼te ğŸŒº" },
                    { q: "Lieber Tagfalter oder Nachtfalter?", a: "Tagfalter ğŸ¦‹", b: "Nachtfalter ğŸ¦‹ğŸŒ™" },
                    { q: "Lieber Nadel- oder Laubbaum?", a: "Nadelbaum ğŸŒ²", b: "Laubbaum ğŸƒ" },
                    { q: "Lieber SÃ¤ugetier oder Reptil?", a: "SÃ¤ugetier ğŸ¾", b: "Reptil ğŸ¦" },
                    { q: "Lieber Obst- oder GemÃ¼segarten?", a: "Obstgarten ğŸ", b: "GemÃ¼segarten ğŸ¥•" },
                    { q: "Lieber Land- oder Wassertier?", a: "Landtier ğŸ¦Œ", b: "Wassertier ğŸ™" },
                    { q: "Lieber Kaktus oder Palme?", a: "Kaktus ğŸŒµ", b: "Palme ğŸŒ´" },
                    { q: "Lieber kleine oder groÃŸe Tiere?", a: "Klein ğŸ­", b: "GroÃŸ ğŸ˜" },
                    { q: "Lieber duftende oder bunte Blumen?", a: "Duftend ğŸŒ¸", b: "Bunt ğŸŒº" },
                    { q: "Lieber Raub- oder Beutetier?", a: "Raubtier ğŸ¦", b: "Beutetier ğŸ°" },
                    { q: "Lieber heimische oder exotische Pflanzen?", a: "Heimisch ğŸŒ¾", b: "Exotisch ğŸŒ´" },
                    { q: "Lieber Insekten oder Spinnen?", a: "Insekten ğŸ¦—", b: "Spinnen ğŸ•·ï¸" },
                    { q: "Lieber einjÃ¤hrige oder mehrjÃ¤hrige Pflanzen?", a: "EinjÃ¤hrig ğŸŒ±", b: "MehrjÃ¤hrig ğŸŒ³" },
                    { q: "Lieber Pflanzen pflegen oder Tiere versorgen?", a: "Pflanzen ğŸŒ¿", b: "Tiere ğŸ•" }
                ]
            },
            "forschung_wissenschaft": {
                name: "Forschung & Wissenschaft",
                emoji: "ğŸ”¬",
                questions: [
                    { q: "Lieber Biologie oder Physik?", a: "Biologie ğŸ§¬", b: "Physik âš›ï¸" },
                    { q: "Lieber Labor oder Feldversuch?", a: "Labor ğŸ§ª", b: "Feldversuch ğŸŒ" },
                    { q: "Lieber Theorie oder Praxis?", a: "Theorie ğŸ“š", b: "Praxis ğŸ”¬" },
                    { q: "Lieber Mikroskop oder Teleskop?", a: "Mikroskop ğŸ”¬", b: "Teleskop ğŸ”­" },
                    { q: "Lieber Chemie oder Mathematik?", a: "Chemie âš—ï¸", b: "Mathematik ğŸ“" },
                    { q: "Lieber beobachten oder experimentieren?", a: "Beobachten ğŸ‘ï¸", b: "Experimentieren âš—ï¸" },
                    { q: "Lieber Naturwissenschaft oder Geisteswissenschaft?", a: "Naturwissenschaft ğŸ”¬", b: "Geisteswissenschaft ğŸ“–" },
                    { q: "Lieber Einzelergebnis oder Durchbruch?", a: "Einzelergebnis ğŸ“Š", b: "Durchbruch ğŸ’¡" },
                    { q: "Lieber quantitative oder qualitative Forschung?", a: "Quantitativ ğŸ“ˆ", b: "Qualitativ ğŸ“" },
                    { q: "Lieber Astronomie oder Geologie?", a: "Astronomie ğŸª", b: "Geologie ğŸ—¿" },
                    { q: "Lieber Genom oder Umwelt?", a: "Genom ğŸ§¬", b: "Umwelt ğŸŒ" },
                    { q: "Lieber Hypothese oder Theorie?", a: "Hypothese ğŸ’­", b: "Theorie ğŸ“š" },
                    { q: "Lieber klinische oder Grundlagenforschung?", a: "Klinisch ğŸ¥", b: "Grundlagen ğŸ§ª" },
                    { q: "Lieber Robotik oder KI?", a: "Robotik ğŸ¤–", b: "KI ğŸ§ " },
                    { q: "Lieber Entdeckung oder Erfindung?", a: "Entdeckung ğŸ”", b: "Erfindung ğŸ’¡" },
                    { q: "Lieber Mikro- oder Makroskala?", a: "Mikro ğŸ”¬", b: "Makro ğŸŒŒ" },
                    { q: "Lieber Langzeitstudie oder Schnelltest?", a: "Langzeit ğŸ“…", b: "Schnelltest âš¡" },
                    { q: "Lieber Teamforschung oder Einzelforschung?", a: "Team ğŸ‘¥", b: "Einzel ğŸ§‘â€ğŸ”¬" },
                    { q: "Lieber Datenanalyse oder Datensammlung?", a: "Analyse ğŸ“Š", b: "Sammlung ğŸ“¦" },
                    { q: "Lieber publizieren oder forschen?", a: "Publizieren ğŸ“„", b: "Forschen ğŸ”¬" }
                ]
            },
            "geschichte_politik": {
                name: "Geschichte & Politik",
                emoji: "ğŸ›ï¸",
                questions: [
                    { q: "Lieber Antike oder Moderne?", a: "Antike ğŸ›ï¸", b: "Moderne ğŸ™ï¸" },
                    { q: "Lieber Monarchie oder Republik?", a: "Monarchie ğŸ‘‘", b: "Republik ğŸ—³ï¸" },
                    { q: "Lieber lokale oder Weltgeschichte?", a: "Lokal ğŸ˜ï¸", b: "Welt ğŸŒ" },
                    { q: "Lieber Krieg oder Frieden?", a: "Krieg âš”ï¸", b: "Frieden ğŸ•Šï¸" },
                    { q: "Lieber Revolution oder Evolution?", a: "Revolution ğŸ”¥", b: "Evolution ğŸ“ˆ" },
                    { q: "Lieber Demokratie oder Diktatur?", a: "Demokratie ğŸ—³ï¸", b: "Diktatur ğŸš«" },
                    { q: "Lieber geschichtliche Dokumente oder mÃ¼ndliche Ãœberlieferung?", a: "Dokumente ğŸ“œ", b: "MÃ¼ndlich ğŸ—£ï¸" },
                    { q: "Lieber Imperium oder Stadtstaat?", a: "Imperium ğŸŒ", b: "Stadtstaat ğŸ›ï¸" },
                    { q: "Lieber Vergangenheit oder Zukunft?", a: "Vergangenheit â®ï¸", b: "Zukunft â­ï¸" },
                    { q: "Lieber Wirtschafts- oder Kulturpolitik?", a: "Wirtschaft ğŸ’¼", b: "Kultur ğŸ­" },
                    { q: "Lieber Nationalismus oder Globalismus?", a: "Nationalismus ğŸ‡©ğŸ‡ª", b: "Globalismus ğŸŒ" },
                    { q: "Lieber Konservativ oder Progressiv?", a: "Konservativ ğŸ“œ", b: "Progressiv ğŸš€" },
                    { q: "Lieber historische PersÃ¶nlichkeit oder Ereignis?", a: "PersÃ¶nlichkeit ğŸ‘¤", b: "Ereignis ğŸ“…" },
                    { q: "Lieber Innen- oder AuÃŸenpolitik?", a: "Innenpolitik ğŸ ", b: "AuÃŸenpolitik ğŸŒ" },
                    { q: "Lieber Wahl oder Revolution?", a: "Wahl ğŸ—³ï¸", b: "Revolution ğŸ”¥" },
                    { q: "Lieber Tradition oder Innovation?", a: "Tradition ğŸ“œ", b: "Innovation ğŸ’¡" },
                    { q: "Lieber Friedensvertrag oder Handelsabkommen?", a: "Friedensvertrag âœï¸", b: "Handelsabkommen ğŸ¤" },
                    { q: "Lieber historischer Roman oder Dokumentation?", a: "Roman ğŸ“š", b: "Dokumentation ğŸ¥" },
                    { q: "Lieber Regierung oder Opposition?", a: "Regierung ğŸ›ï¸", b: "Opposition ğŸ¤" },
                    { q: "Lieber Geschichtsbuch oder Museum?", a: "Buch ğŸ“–", b: "Museum ğŸ›ï¸" }
                ]
            },
            "glaube_religion": {
                name: "Glaube & Religion",
                emoji: "ğŸ™",
                questions: [
                    { q: "Lieber Glaube oder Wissen?", a: "Glaube ğŸ™", b: "Wissen ğŸ“š" },
                    { q: "Lieber Gebet oder Meditation?", a: "Gebet ğŸ™", b: "Meditation ğŸ§˜" },
                    { q: "Lieber Kirche oder Natur?", a: "Kirche â›ª", b: "Natur ğŸŒ³" },
                    { q: "Lieber religiÃ¶ser Text oder spirituelle Erfahrung?", a: "Text ğŸ“–", b: "Erfahrung âœ¨" },
                    { q: "Lieber Gemeinschaft oder EinzelgÃ¤nger?", a: "Gemeinschaft ğŸ‘¥", b: "Einzel ğŸ™" },
                    { q: "Lieber Ritual oder spontan?", a: "Ritual ğŸ””", b: "Spontan ğŸ’«" },
                    { q: "Lieber Tradition oder ModernitÃ¤t?", a: "Tradition ğŸ“œ", b: "ModernitÃ¤t ğŸŒŸ" },
                    { q: "Lieber Philosophie oder Theologie?", a: "Philosophie ğŸ’­", b: "Theologie ğŸ“–" },
                    { q: "Lieber feste Ãœberzeugung oder offene Fragen?", a: "Ãœberzeugung ğŸ’ª", b: "Offen ğŸ¤”" },
                    { q: "Lieber Gott oder Universum?", a: "Gott ğŸ‘¼", b: "Universum ğŸŒŒ" },
                    { q: "Lieber Predigt oder Stille?", a: "Predigt ğŸ—£ï¸", b: "Stille ğŸ¤«" },
                    { q: "Lieber heiliger Ort oder Ã¼berall?", a: "Heiliger Ort â›ª", b: "Ãœberall ğŸŒ" },
                    { q: "Lieber Dogma oder Toleranz?", a: "Dogma ğŸ“œ", b: "Toleranz ğŸ¤" },
                    { q: "Lieber Religion oder SpiritualitÃ¤t?", a: "Religion â›ª", b: "SpiritualitÃ¤t âœ¨" },
                    { q: "Lieber Gemeindeleben oder Privatheit?", a: "Gemeinde ğŸ‘¥", b: "Privat ğŸ™" },
                    { q: "Lieber geschriebenes Gesetz oder Gewissen?", a: "Gesetz ğŸ“œ", b: "Gewissen â¤ï¸" },
                    { q: "Lieber Priester oder Laie?", a: "Priester ğŸ‘¨â€ğŸ’¼", b: "Laie ğŸ‘¤" },
                    { q: "Lieber heilige Schrift oder persÃ¶nliche Offenbarung?", a: "Schrift ğŸ“–", b: "Offenbarung ğŸ’¡" },
                    { q: "Lieber Festtag oder Alltag?", a: "Festtag ğŸ‰", b: "Alltag ğŸ“…" },
                    { q: "Lieber Transzendenz oder Immanenz?", a: "Transzendenz ğŸŒŒ", b: "Immanenz ğŸŒ" }
                ]
            },
            "kunst_kultur": {
                name: "Kunst & Kultur",
                emoji: "ğŸ¨",
                questions: [
                    { q: "Lieber Malerei oder Skulptur?", a: "Malerei ğŸ–¼ï¸", b: "Skulptur ğŸ—¿" },
                    { q: "Lieber abstrakt oder figurativ?", a: "Abstrakt ğŸ¨", b: "Figurativ ğŸ‘¤" },
                    { q: "Lieber Museum oder Galerie?", a: "Museum ğŸ›ï¸", b: "Galerie ğŸ–¼ï¸" },
                    { q: "Lieber klassisch oder modern?", a: "Klassisch ğŸ­", b: "Modern ğŸ¨" },
                    { q: "Lieber Farbe oder Form?", a: "Farbe ğŸŒˆ", b: "Form â¬œ" },
                    { q: "Lieber Original oder Reproduktion?", a: "Original âœ¨", b: "Reproduktion ğŸ“‹" },
                    { q: "Lieber KÃ¼nstler oder Betrachter?", a: "KÃ¼nstler ğŸ¨", b: "Betrachter ğŸ‘ï¸" },
                    { q: "Lieber Ã–l- oder Aquarellmalerei?", a: "Ã–l ğŸ–Œï¸", b: "Aquarell ğŸ’§" },
                    { q: "Lieber Renaissance oder Barock?", a: "Renaissance ğŸ­", b: "Barock ğŸ›ï¸" },
                    { q: "Lieber Street Art oder Museumskunst?", a: "Street Art ğŸ¨", b: "Museumskunst ğŸ–¼ï¸" },
                    { q: "Lieber PortrÃ¤t oder Landschaft?", a: "PortrÃ¤t ğŸ‘¤", b: "Landschaft ğŸŒ„" },
                    { q: "Lieber Fotografie oder GemÃ¤lde?", a: "Fotografie ğŸ“¸", b: "GemÃ¤lde ğŸ–¼ï¸" },
                    { q: "Lieber Installation oder Performance?", a: "Installation ğŸ­", b: "Performance ğŸª" },
                    { q: "Lieber Realismus oder Surrealismus?", a: "Realismus ğŸ‘ï¸", b: "Surrealismus ğŸŒˆ" },
                    { q: "Lieber minimal oder opulent?", a: "Minimal â¬œ", b: "Opulent âœ¨" },
                    { q: "Lieber analog oder digital?", a: "Analog ğŸ–Œï¸", b: "Digital ğŸ’»" },
                    { q: "Lieber Tradition oder Avantgarde?", a: "Tradition ğŸ“œ", b: "Avantgarde ğŸš€" },
                    { q: "Lieber Einzelwerk oder Serie?", a: "Einzelwerk ğŸ–¼ï¸", b: "Serie ğŸ“š" },
                    { q: "Lieber GemÃ¤lde oder Zeichnung?", a: "GemÃ¤lde ğŸ¨", b: "Zeichnung âœï¸" },
                    { q: "Lieber KÃ¼nstlerkollektiv oder EinzelkÃ¼nstler?", a: "Kollektiv ğŸ‘¥", b: "EinzelkÃ¼nstler ğŸ¨" }
                ]
            },
            "literatur_sprache": {
                name: "Literatur & Sprache",
                emoji: "ğŸ“š",
                questions: [
                    { q: "Lieber Buch oder HÃ¶rbuch?", a: "Buch ğŸ“š", b: "HÃ¶rbuch ğŸ§" },
                    { q: "Lieber Roman oder Gedicht?", a: "Roman ğŸ“–", b: "Gedicht âœï¸" },
                    { q: "Lieber Fiktion oder Non-Fiktion?", a: "Fiktion ğŸ­", b: "Non-Fiktion ğŸ“Š" },
                    { q: "Lieber Schreiber oder Leser?", a: "Schreiber âœï¸", b: "Leser ğŸ‘ï¸" },
                    { q: "Lieber gedruckt oder digital?", a: "Gedruckt ğŸ“–", b: "Digital ğŸ“±" },
                    { q: "Lieber Fantasy oder Realismus?", a: "Fantasy ğŸ‰", b: "Realismus ğŸ‘ï¸" },
                    { q: "Lieber Kurzgeschichte oder Roman?", a: "Kurzgeschichte ğŸ“", b: "Roman ğŸ“–" },
                    { q: "Lieber Ãœbersetzen oder Original?", a: "Ãœbersetzen ğŸŒ", b: "Original ğŸ“š" },
                    { q: "Lieber Gedicht schreiben oder lesen?", a: "Schreiben âœï¸", b: "Lesen ğŸ‘ï¸" },
                    { q: "Lieber Drama oder KomÃ¶die?", a: "Drama ğŸ­", b: "KomÃ¶die ğŸ˜‚" },
                    { q: "Lieber Autor oder Kritiker?", a: "Autor âœï¸", b: "Kritiker ğŸ“" },
                    { q: "Lieber Bibliothek oder Buchhandlung?", a: "Bibliothek ğŸ“š", b: "Buchhandlung ğŸª" },
                    { q: "Lieber Klassiker oder Bestseller?", a: "Klassiker ğŸ“œ", b: "Bestseller ğŸ”¥" },
                    { q: "Lieber Poesie oder Prosa?", a: "Poesie âœï¸", b: "Prosa ğŸ“–" },
                    { q: "Lieber Muttersprache oder Fremdsprache?", a: "Muttersprache ğŸ‡©ğŸ‡ª", b: "Fremdsprache ğŸŒ" },
                    { q: "Lieber ErzÃ¤hler oder ZuhÃ¶rer?", a: "ErzÃ¤hler ğŸ—£ï¸", b: "ZuhÃ¶rer ğŸ‘‚" },
                    { q: "Lieber Brief oder E-Mail?", a: "Brief âœ‰ï¸", b: "E-Mail ğŸ“§" },
                    { q: "Lieber Tagebuch oder Blog?", a: "Tagebuch ğŸ“”", b: "Blog ğŸ’»" },
                    { q: "Lieber Lyrik oder Epik?", a: "Lyrik âœï¸", b: "Epik ğŸ“–" },
                    { q: "Lieber Wort oder Bild?", a: "Wort ğŸ“", b: "Bild ğŸ–¼ï¸" }
                ]
            },
            "medien_unterhaltung": {
                name: "Medien & Unterhaltung",
                emoji: "ğŸ“º",
                questions: [
                    { q: "Lieber Film oder Serie?", a: "Film ğŸ¬", b: "Serie ğŸ“º" },
                    { q: "Lieber Netflix oder YouTube?", a: "Netflix ğŸŸ¥", b: "YouTube â–¶ï¸" },
                    { q: "Lieber Kino oder zu Hause?", a: "Kino ğŸ¬", b: "Zuhause ğŸ“º" },
                    { q: "Lieber Action oder Drama?", a: "Action ğŸ’¥", b: "Drama ğŸ­" },
                    { q: "Lieber Comedy oder Thriller?", a: "Comedy ğŸ˜‚", b: "Thriller ğŸ•µï¸" },
                    { q: "Lieber Live-TV oder Streaming?", a: "Live-TV ğŸ“¡", b: "Streaming ğŸ“±" },
                    { q: "Lieber Dokumentation oder Spielfilm?", a: "Dokumentation ğŸ“¹", b: "Spielfilm ğŸ¬" },
                    { q: "Lieber Originalsprache oder Synchronisation?", a: "Original ğŸ—£ï¸", b: "Synchronisation ğŸ¤" },
                    { q: "Lieber Kurzfilm oder Langfilm?", a: "Kurzfilm â±ï¸", b: "Langfilm â°" },
                    { q: "Lieber Schwarz-WeiÃŸ oder Farbe?", a: "Schwarz-WeiÃŸ âš«âšª", b: "Farbe ğŸŒˆ" },
                    { q: "Lieber RealitÃ¤t oder Fiktion?", a: "RealitÃ¤t ğŸ‘ï¸", b: "Fiktion ğŸ­" },
                    { q: "Lieber Single-Player oder Multiplayer?", a: "Single ğŸ®", b: "Multiplayer ğŸ‘¥" },
                    { q: "Lieber Actionspiel oder Strategiespiel?", a: "Action ğŸ’¥", b: "Strategie ğŸ§ " },
                    { q: "Lieber Konsole oder PC?", a: "Konsole ğŸ®", b: "PC ğŸ’»" },
                    { q: "Lieber Videospiele spielen oder Brettspiele?", a: "Video ğŸ®", b: "Brett ğŸ²" },
                    { q: "Lieber Kabel oder Streaming?", a: "Kabel ğŸ“º", b: "Streaming ğŸ“±" },
                    { q: "Lieber Neuerscheinung oder Klassiker?", a: "Neu ğŸ†•", b: "Klassiker â­" },
                    { q: "Lieber Fernseher oder Projektor?", a: "Fernseher ğŸ“º", b: "Projektor ğŸ¬" },
                    { q: "Lieber Reality-TV oder Scripted?", a: "Reality ğŸ“º", b: "Scripted ğŸ“" },
                    { q: "Lieber Binge-Watching oder wÃ¶chentlich?", a: "Binge ğŸ¿", b: "WÃ¶chentlich ğŸ“…" }
                ]
            },
            "musik": {
                name: "Musik",
                emoji: "ğŸµ",
                questions: [
                    { q: "Lieber Rock oder Pop?", a: "Rock ğŸ¸", b: "Pop ğŸ¤" },
                    { q: "Lieber laut oder leise Musik hÃ¶ren?", a: "Laut ğŸ”ŠğŸ¶", b: "Leise ğŸ¤«ğŸ§" },
                    { q: "Lieber Musik mit oder ohne Text?", a: "Mit Text ğŸ—£ï¸ğŸµ", b: "Instrumental ğŸ¼ğŸ§" },
                    { q: "Lieber Live-Konzert oder Studioaufnahme?", a: "Live ğŸ¤", b: "Studio ğŸ§" },
                    { q: "Lieber SÃ¤nger oder Instrumentalist?", a: "SÃ¤nger ğŸ¤", b: "Instrumentalist ğŸ¸" },
                    { q: "Lieber Klassik oder Moderne?", a: "Klassik ğŸ»", b: "Moderne ğŸ¸" },
                    { q: "Lieber Gitarre oder Klavier?", a: "Gitarre ğŸ¸", b: "Klavier ğŸ¹" },
                    { q: "Lieber allein oder in der Band?", a: "Allein ğŸ¤", b: "Band ğŸ‘¥" },
                    { q: "Lieber KopfhÃ¶rer oder Lautsprecher?", a: "KopfhÃ¶rer ğŸ§", b: "Lautsprecher ğŸ”Š" },
                    { q: "Lieber Vinyl oder Digital?", a: "Vinyl ğŸ’¿", b: "Digital ğŸ“±" },
                    { q: "Lieber Songwriter oder Interprete?", a: "Songwriter âœï¸", b: "Interprete ğŸ¤" },
                    { q: "Lieber Jazz oder Electronic?", a: "Jazz ğŸ·", b: "Electronic ğŸ¹" },
                    { q: "Lieber Festival oder Intimkonzert?", a: "Festival ğŸª", b: "Intim ğŸµ" },
                    { q: "Lieber Refrain oder Bridge?", a: "Refrain ğŸµ", b: "Bridge ğŸŒ‰" },
                    { q: "Lieber Musik machen oder hÃ¶ren?", a: "Machen ğŸ¸", b: "HÃ¶ren ğŸ§" },
                    { q: "Lieber Akustik oder Elektrik?", a: "Akustik ğŸ¸", b: "Elektrik âš¡" },
                    { q: "Lieber Cover oder Original?", a: "Cover ğŸµ", b: "Original âœ¨" },
                    { q: "Lieber Album oder Single?", a: "Album ğŸ’¿", b: "Single ğŸµ" },
                    { q: "Lieber Rhythmus oder Melodie?", a: "Rhythmus ğŸ¥", b: "Melodie ğŸµ" },
                    { q: "Lieber Bar oder Club?", a: "Bar ğŸ¸", b: "Club ğŸ¶" }
                ]
            },
            "sport": {
                name: "Sport",
                emoji: "âš½",
                questions: [
                    { q: "Lieber Sport im Team oder allein?", a: "Team âš½", b: "Allein ğŸƒâ€â™€ï¸" },
                    { q: "Lieber Sport gucken oder selber machen?", a: "Gucken ğŸŸï¸ğŸ‘€", b: "Machen ğŸ¤¸â€â™‚ï¸ğŸ’ª" },
                    { q: "Lieber morgens oder abends trainieren?", a: "Morgens ğŸŒ…ğŸƒ", b: "Abends ğŸŒ™ğŸ’ª" },
                    { q: "Lieber Laufen oder Schwimmen?", a: "Laufen ğŸƒ", b: "Schwimmen ğŸŠ" },
                    { q: "Lieber FuÃŸball oder Basketball?", a: "FuÃŸball âš½", b: "Basketball ğŸ€" },
                    { q: "Lieber Indoor oder Outdoor?", a: "Indoor ğŸ ", b: "Outdoor ğŸŒ³" },
                    { q: "Lieber Ausdauer oder Kraft?", a: "Ausdauer ğŸƒ", b: "Kraft ğŸ’ª" },
                    { q: "Lieber Wettkampf oder Training?", a: "Wettkampf ğŸ†", b: "Training ğŸ’ª" },
                    { q: "Lieber Mannschaft oder Einzelsport?", a: "Mannschaft ğŸ‘¥", b: "Einzel ğŸƒ" },
                    { q: "Lieber Tennis oder Badminton?", a: "Tennis ğŸ¾", b: "Badminton ğŸ¸" },
                    { q: "Lieber Radfahren oder Wandern?", a: "Radfahren ğŸš²ğŸŒ³", b: "Wandern ğŸš¶â€â™€ï¸ğŸ”ï¸" },
                    { q: "Lieber Gym oder Natur?", a: "Gym ğŸ‹ï¸", b: "Natur ğŸŒ²" },
                    { q: "Lieber Profi oder Amateur?", a: "Profi ğŸ†", b: "Amateur ğŸ¯" },
                    { q: "Lieber Sieg oder SpaÃŸ?", a: "Sieg ğŸ†", b: "SpaÃŸ ğŸ˜Š" },
                    { q: "Lieber Sommer- oder Wintersport?", a: "Sommer â˜€ï¸", b: "Winter â„ï¸" },
                    { q: "Lieber Kontaktsport oder Nicht-Kontakt?", a: "Kontakt ğŸ¤¼", b: "Nicht-Kontakt ğŸƒ" },
                    { q: "Lieber Sprint oder Marathon?", a: "Sprint âš¡", b: "Marathon ğŸƒ" },
                    { q: "Lieber Ball- oder RÃ¼ckschlagsport?", a: "Ball âš½", b: "RÃ¼ckschlag ğŸ¾" },
                    { q: "Lieber Sportartikel oder natÃ¼rliche Bewegung?", a: "Artikel ğŸ¾", b: "NatÃ¼rlich ğŸƒ" },
                    { q: "Lieber Tageszeitung oder Sport-App?", a: "Zeitung ğŸ“°", b: "App ğŸ“±" }
                ]
            },
            "technik_wirtschaft": {
                name: "Technik & Wirtschaft",
                emoji: "ğŸ’»",
                questions: [
                    { q: "Lieber Apple oder Android?", a: "Apple ğŸ", b: "Android ğŸ¤–" },
                    { q: "Lieber Smartphone oder Laptop?", a: "Smartphone ğŸ“±", b: "Laptop ğŸ’»" },
                    { q: "Lieber Bargeld oder Karte?", a: "Bargeld ğŸ’µ", b: "Karte ğŸ’³" },
                    { q: "Lieber Auto oder Bahn?", a: "Auto ğŸš—", b: "Bahn ğŸš‚" },
                    { q: "Lieber Schreibtisch oder Homeoffice?", a: "BÃ¼ro ğŸ¢", b: "Homeoffice ğŸ¡" },
                    { q: "Lieber WhatsApp oder Anruf?", a: "WhatsApp ğŸ’¬", b: "Anruf ğŸ“" },
                    { q: "Lieber online shoppen oder im Laden?", a: "Online ğŸ›’ğŸ’»", b: "Im Laden ğŸ›ï¸ğŸš¶" },
                    { q: "Lieber Aktien oder Immobilien?", a: "Aktien ğŸ“ˆ", b: "Immobilien ğŸ " },
                    { q: "Lieber Start-up oder Konzern?", a: "Start-up ğŸš€", b: "Konzern ğŸ¢" },
                    { q: "Lieber Innovation oder StabilitÃ¤t?", a: "Innovation ğŸ’¡", b: "StabilitÃ¤t ğŸ“Š" },
                    { q: "Lieber Cloud oder lokal?", a: "Cloud â˜ï¸", b: "Lokal ğŸ’¾" },
                    { q: "Lieber KryptowÃ¤hrung oder Fiat?", a: "Krypto â‚¿", b: "Fiat ğŸ’µ" },
                    { q: "Lieber Automatisierung oder Handarbeit?", a: "Automatisierung ğŸ¤–", b: "Handarbeit âœ‹" },
                    { q: "Lieber Ã–konomie oder Ã–kologie?", a: "Ã–konomie ğŸ’¼", b: "Ã–kologie ğŸŒ¿" },
                    { q: "Lieber B2B oder B2C?", a: "B2B ğŸ’¼", b: "B2C ğŸ›’" },
                    { q: "Lieber Offline oder Online?", a: "Offline ğŸ“´", b: "Online ğŸŒ" },
                    { q: "Lieber Freelancer oder Angestellter?", a: "Freelancer ğŸ†“", b: "Angestellter ğŸ’¼" },
                    { q: "Lieber Kredit oder Sparen?", a: "Kredit ğŸ’³", b: "Sparen ğŸ’°" },
                    { q: "Lieber Risiko oder Sicherheit?", a: "Risiko ğŸ²", b: "Sicherheit ğŸ”’" },
                    { q: "Lieber einmal viel Geld oder jeden Tag ein bisschen?", a: "Einmal viel ğŸ’°ğŸ’¥", b: "Jeden Tag etwas ğŸ’¸ğŸ—“ï¸" }
                ]
            },
            "diverses": {
                name: "Diverses",
                emoji: "ğŸ²",
                questions: [
                    { q: "Lieber Sommer oder Winter?", a: "Sommer â˜€ï¸", b: "Winter â„ï¸" },
                    { q: "Lieber Urlaub am Strand oder in den Bergen?", a: "Strand ğŸ–ï¸", b: "Berge â›°ï¸" },
                    { q: "Lieber FrÃ¼haufsteher oder LangschlÃ¤fer?", a: "FrÃ¼h â°â˜€ï¸", b: "SpÃ¤t ğŸŒ™ğŸ’¤" },
                    { q: "Lieber Sneaker oder Stiefel?", a: "Sneaker ğŸ‘Ÿ", b: "Stiefel ğŸ‘¢" },
                    { q: "Lieber Holz- oder MetallmÃ¶bel?", a: "Holz ğŸªµ", b: "Metall ğŸ”©" },
                    { q: "Lieber Jeans oder Stoffhose?", a: "Jeans ğŸ‘–", b: "Stoffhose ğŸ©³" },
                    { q: "Lieber drinnen oder drauÃŸen feiern?", a: "Drinnen ğŸ ğŸ‰", b: "DrauÃŸen ğŸŒ³ğŸ¥³" },
                    { q: "Lieber Socken an oder barfuÃŸ?", a: "Socken an ğŸ§¦", b: "BarfuÃŸ ğŸ¦¶" },
                    { q: "Lieber Couch oder Sessel?", a: "Couch ğŸ›‹ï¸", b: "Sessel ğŸª‘" },
                    { q: "Lieber Stadt oder Land?", a: "Stadt ğŸ™ï¸", b: "Land ğŸï¸" },
                    { q: "Lieber Meer oder See?", a: "Meer ğŸŒŠ", b: "See ğŸï¸ğŸ’§" },
                    { q: "Lieber FrÃ¼hling oder Herbst?", a: "FrÃ¼hling ğŸŒ·", b: "Herbst ğŸ‚" },
                    { q: "Lieber aufstehen oder liegen bleiben?", a: "Aufstehen ğŸš¶â€â™€ï¸", b: "Liegen ğŸ›Œ" },
                    { q: "Lieber Bleistift oder Kugelschreiber?", a: "Bleistift âœï¸", b: "Kugelschreiber ğŸ–Šï¸" },
                    { q: "Lieber Feste planen oder spontan sein?", a: "Planen ğŸ—“ï¸", b: "Spontan ğŸ‰" },
                    { q: "Lieber Duschgel oder Seife?", a: "Duschgel ğŸ§´", b: "Seife ğŸ§¼" },
                    { q: "Lieber drinnen lesen oder drauÃŸen spazieren?", a: "Drinnen lesen ğŸ“–ğŸ ", b: "DrauÃŸen spazieren ğŸš¶â€â™‚ï¸ğŸŒ²" },
                    { q: "Lieber Zelt oder Hotel?", a: "Zelt â›º", b: "Hotel ğŸ¨" },
                    { q: "Lieber Nachrichten lesen oder hÃ¶ren?", a: "Lesen ğŸ“°ğŸ‘€", b: "HÃ¶ren ğŸ“»ğŸ‘‚" },
                    { q: "Lieber Kerzenlicht oder helles Licht?", a: "Kerzenlicht ğŸ”¥ğŸ•¯ï¸", b: "Helles Licht ğŸ’¡âœ¨" },
                    { q: "Lieber kurze oder lange Haare?", a: "Kurz ğŸ’‡â€â™€ï¸âœ‚ï¸", b: "Lang ğŸ‘±â€â™€ï¸ğŸ¦’" },
                    { q: "Lieber Ananas auf Pizza: Ja oder Nein?", a: "Ananas: Ja ğŸğŸ•ğŸ‘", b: "Ananas: Nein ğŸğŸ•ğŸ‘" },
                    { q: "Lieber Stille oder HintergrundgerÃ¤usche beim Arbeiten?", a: "Stille ğŸ¤«ğŸ”‡", b: "Hintergrund ğŸ§ğŸµ" },
                    { q: "Lieber Bleistift oder Marker?", a: "Bleistift âœï¸", b: "Marker ğŸ–ï¸" },
                    { q: "Lieber Eis im Becher oder in der Waffel?", a: "Becher ğŸ¨", b: "Waffel ğŸ¦" },
                    { q: "Lieber am Fenster sitzen oder am Gang (Flugzeug/Bahn)?", a: "Fenster ğŸ–¼ï¸", b: "Gang ğŸšª" },
                    { q: "Lieber eine saubere, leere Wohnung oder eine unordentliche, gemÃ¼tliche?", a: "Sauber & Leer âœ¨ğŸ“¦", b: "Unordentlich & GemÃ¼tlich ğŸ›‹ï¸ğŸ˜Œ" },
                    { q: "Lieber Kissen weich oder hart?", a: "Weich â˜ï¸", b: "Hart ğŸ§±" },
                    { q: "Lieber ein Leben lang nur noch Toast oder nur noch BrÃ¶tchen essen?", a: "Toast ğŸ", b: "BrÃ¶tchen ğŸ¥" },
                    { q: "Lieber in der ersten oder letzten Reihe sitzen (Kino/Theater)?", a: "Erste Reihe ğŸ¥‡", b: "Letzte Reihe ğŸ”š" },
                    { q: "Lieber Marmelade oder Nutella?", a: "Marmelade ğŸ“", b: "Nutella ğŸ«" },
                    { q: "Lieber warm oder kalt trinken?", a: "Warm â™¨ï¸â˜•", b: "Kalt ğŸ§ŠğŸ¥¤" },
                    { q: "Lieber Fleisch oder Fisch?", a: "Fleisch ğŸ¥©", b: "Fisch ğŸŸ" },
                    { q: "Lieber SÃ¼ÃŸkartoffel oder normale Kartoffel?", a: "SÃ¼ÃŸ ğŸ ", b: "Normal ğŸ¥”" },
                    { q: "Lieber Hemd oder T-Shirt?", a: "Hemd ğŸ‘”", b: "T-Shirt ğŸ‘•" },
                    { q: "Lieber im Hotel frÃ¼hstÃ¼cken oder im CafÃ©?", a: "Hotel ğŸ¨ğŸ³", b: "CafÃ© â˜•ğŸ¥" },
                    { q: "Lieber Scharf oder Mild essen?", a: "Scharf ğŸŒ¶ï¸ğŸ”¥", b: "Mild ğŸ¥›ğŸ˜Œ" },
                    { q: "Lieber E-Book oder gedrucktes Buch?", a: "E-Book ğŸ“±ğŸ“š", b: "Gedruckt ğŸ“–ğŸŒ³" },
                    { q: "Lieber mit Ã¶ffentlichen Verkehrsmitteln oder mit dem Rad zur Arbeit?", a: "Ã–ffentlich ğŸšŒğŸš†", b: "Fahrrad ğŸš²" },
                    { q: "Lieber Rotwein oder WeiÃŸwein?", a: "Rotwein ğŸ·ğŸ”´", b: "WeiÃŸwein ğŸ¥‚âšª" },
                    { q: "Lieber in der KÃ¼che oder im Wohnzimmer essen?", a: "KÃ¼che ğŸ§‘â€ğŸ³ğŸ½ï¸", b: "Wohnzimmer ğŸ›‹ï¸ğŸ“º" },
                    { q: "Lieber SalzgebÃ¤ck oder Chips?", a: "SalzgebÃ¤ck ğŸ¥¨", b: "Chips ğŸ¥”ğŸ’¸" },
                    { q: "Lieber schreiben oder lesen?", a: "Schreiben âœï¸", b: "Lesen ğŸ“–" },
                    { q: "Lieber Krawatte oder Fliege?", a: "Krawatte ğŸ‘”", b: "Fliege ğŸ€" },
                    { q: "Lieber glatt oder lockig?", a: "Glatt ğŸ’‡â€â™€ï¸ğŸ“", b: "Lockig ğŸ’†â€â™€ï¸ğŸŒ€" },
                    { q: "Lieber Taschenlampe oder Kerze?", a: "Taschenlampe ğŸ”¦", b: "Kerze ğŸ•¯ï¸" },
                    { q: "Lieber nur noch GemÃ¼se oder nur noch Obst essen?", a: "GemÃ¼se ğŸ¥¦ğŸ¥¬", b: "Obst ğŸğŸŠ" },
                    { q: "Lieber nur noch MÃ¼tzen oder nur noch Schals tragen?", a: "MÃ¼tzen ğŸ§¢ğŸ‘’", b: "Schals ğŸ§£ğŸ§£" },
                    { q: "Lieber immer pÃ¼nktlich oder immer gute Laune?", a: "PÃ¼nktlich â°âœ…", b: "Gute Laune ğŸ˜„ğŸ¥³" },
                    { q: "Lieber Suppe mit Einlage oder pur?", a: "Mit Einlage ğŸœğŸ²", b: "Pur ğŸ¥£ğŸ’§" },
                    { q: "Lieber SÃ¼ÃŸigkeiten im KÃ¼hlschrank oder ungekÃ¼hlt?", a: "Kalt ğŸ§ŠğŸ¬", b: "Zimmerwarm ğŸŒ¡ï¸ğŸ­" },
                    { q: "Lieber auf dem Bauch oder auf der Seite schlafen?", a: "Bauch â¬‡ï¸ğŸ›Œ", b: "Seite â†ªï¸ğŸ˜´" },
                    { q: "Lieber Jeans mit LÃ¶chern oder ohne?", a: "Mit LÃ¶chern ğŸ‘–ğŸ•³ï¸", b: "Ohne LÃ¶cher ğŸ‘–âœ¨" },
                    { q: "Lieber weiÃŸe oder bunte WÃ¤sche?", a: "WeiÃŸe âšªğŸ§º", b: "Bunte ğŸŒˆğŸ‘•" },
                    { q: "Lieber Nudeln al dente oder weich?", a: "Al Dente ğŸ‘ŒğŸ", b: "Weich ğŸ˜´ğŸœ" },
                    { q: "Lieber FÃ¼ller oder Kugelschreiber?", a: "FÃ¼ller ğŸ–‹ï¸âœ¨", b: "Kugelschreiber ğŸ–Šï¸ğŸ’ª" },
                    { q: "Lieber StÃ¤dtetrip oder Wellness?", a: "StÃ¤dtetrip ğŸ™ï¸", b: "Wellness ğŸ§˜â€â™€ï¸" },
                    { q: "Lieber duschen oder baden?", a: "Duschen ğŸš¿", b: "Baden ğŸ›" }
                ]
            }
        };
        
        // Flache Liste aller Fragen mit Kategorie-Information
        function getAllQuestions(activeCategories = []) {
            let allQuestions = [];
            if(activeCategories.length === 0) {
                // Falls keine Kategorien aktiv sind, verwende alle
                activeCategories = Object.keys(questionCategories);
            }
            
            activeCategories.forEach(catKey => {
                if(questionCategories[catKey] && questionCategories[catKey].questions) {
                    questionCategories[catKey].questions.forEach(q => {
                        allQuestions.push({ ...q, category: catKey });
                    });
                }
            });
            return allQuestions;
        }

        function getRandomUnusedQuestion(usedQuestions = [], activeCategories = [], lastCategory = null) {
            const questions = getAllQuestions(activeCategories);
            if(questions.length === 0) {
                console.error('Keine Fragen verfÃ¼gbar!');
                return { question: { q: "Keine Frage verfÃ¼gbar", a: "A", b: "B" }, index: -1, category: null };
            }
            const available = questions.filter((q, idx) => !usedQuestions.includes(idx));
            if(available.length === 0) {
                const randomIdx = Math.floor(Math.random() * questions.length);
                const q = questions[randomIdx];
                if(!q || !q.q) {
                    console.error('UngÃ¼ltige Frage gefunden:', q);
                    return { question: questions[0] || { q: "Fehler", a: "A", b: "B" }, index: 0, category: null };
                }
                return { question: q, index: randomIdx, category: q.category };
            }
            
            // Wenn mehrere Kategorien aktiv sind und eine letzte Kategorie bekannt ist,
            // vermeide Fragen aus derselben Kategorie
            let filteredAvailable = available;
            if(activeCategories.length > 1 && lastCategory) {
                const fromOtherCategories = available.filter(q => q.category !== lastCategory);
                if(fromOtherCategories.length > 0) {
                    filteredAvailable = fromOtherCategories;
                }
            }
            
            const randomQ = filteredAvailable[Math.floor(Math.random() * filteredAvailable.length)];
            if(!randomQ || !randomQ.q) {
                console.error('UngÃ¼ltige Frage gefunden:', randomQ);
                return { question: questions[0] || { q: "Fehler", a: "A", b: "B" }, index: 0, category: null };
            }
            return { question: randomQ, index: questions.indexOf(randomQ), category: randomQ.category };
        }
        const cardInfo = {
            card_oil: { label: "ğŸ›¢ï¸ Ã–lfass", desc: "Verdoppelt deinen nÃ¤chsten Angriff." },
            card_mirror: { label: "ğŸª Spiegel", desc: "Der nÃ¤chste Angriff prallt zurÃ¼ck." },
            card_ice: { label: "ğŸ§Š EiswÃ¼rfel", desc: "KÃ¼hlt dich in der nÃ¤chsten Runde automatisch ab." }
        };

        // --- AUTO LOGIN ---
        if(myName && roomId) {
            document.getElementById('inpName').value = myName;
            if(document.getElementById('inpEmoji')) {
                document.getElementById('inpEmoji').value = myEmoji;
                // Aktualisiere Emoji-Galerie wenn vorhanden
                const gallery = document.getElementById('emojiGallery');
                if(gallery) {
                    gallery.querySelectorAll('.emoji-card').forEach((card) => {
                        const cardEmoji = card.getAttribute('data-emoji');
                        if(cardEmoji === myEmoji) {
                            card.classList.add('selected');
                        } else {
                            card.classList.remove('selected');
                        }
                    });
                }
                currentEmojiIndex = availableEmojis.indexOf(myEmoji);
                if(currentEmojiIndex === -1) currentEmojiIndex = 0;
            }
            document.getElementById('inpCode').value = roomId;
            setTimeout(() => joinGame(), 500);
        }

        // --- MENU / START CONTROLS ---
        window.toggleMenu = () => {
            document.getElementById('adminDrawer').classList.toggle('open');
            document.getElementById('menuOverlay').classList.toggle('open');
        };
        function ensureName() {
            const name = document.getElementById('inpName').value.trim();
            if(!name) {
                showToast("Bitte gib zuerst deinen Namen ein.");
                document.getElementById('inpName').focus();
                return false;
            }
            return true;
        }

        window.openHostSettings = () => {
            if(!ensureName()) return;
            const panel = document.getElementById('hostSettings');
            const join = document.getElementById('joinPanel');
            join.classList.add('hidden');
            panel.classList.toggle('hidden');
            if(!panel.classList.contains('hidden')) {
                renderCategorySelection();
            }
        };
        
        function renderCategorySelection() {
            const container = document.getElementById('categorySelection');
            if(!container) return;
            
            container.innerHTML = Object.keys(questionCategories).map(catKey => {
                const cat = questionCategories[catKey];
                return `
                    <div class="category-card" data-category="${catKey}" onclick="toggleCategory('${catKey}')">
                        <div class="category-emoji">${cat.emoji}</div>
                        <div class="category-name">${cat.name}</div>
                    </div>
                `;
            }).join('');
            
            // Keine Kategorien standardmÃ¤ÃŸig aktiviert
        }
        
        window.toggleCategory = (catKey) => {
            const card = document.querySelector(`[data-category="${catKey}"]`);
            if(card) {
                card.classList.toggle('selected');
            }
        };
        
        window.toggleGameMode = (mode) => {
            document.querySelectorAll('.game-mode-card').forEach(card => {
                card.classList.remove('selected');
            });
            const card = document.querySelector(`[data-mode="${mode}"]`);
            if(card) {
                card.classList.add('selected');
            }
        };
        
        function getSelectedGameMode() {
            const selectedCard = document.querySelector('.game-mode-card.selected');
            return selectedCard ? selectedCard.getAttribute('data-mode') : 'party';
        }
        
        function getSelectedCategories() {
            const selected = [];
            document.querySelectorAll('.category-card.selected').forEach(card => {
                selected.push(card.getAttribute('data-category'));
            });
            return selected;
        }
        window.openJoinPanel = () => {
            if(!ensureName()) return;
            const panel = document.getElementById('joinPanel');
            const host = document.getElementById('hostSettings');
            host.classList.add('hidden');
            panel.classList.toggle('hidden');
            if(!panel.classList.contains('hidden')) {
                loadRoomList();
            }
        };
        
        window.loadRoomList = async () => {
            try {
                const roomsRef = collection(db, "lobbies");
                const q = query(roomsRef, where("status", "==", "lobby"));
                const querySnapshot = await getDocs(q);
                
                const rooms = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    if(data.hostName) {
                    rooms.push({
                        id: doc.id,
                        hostName: data.hostName,
                        playerCount: Object.keys(data.players || {}).length,
                        password: data.password || "",
                        hasPassword: !!(data.password && data.password.trim().length > 0)
                    });
                    }
                });
                
                const roomListEl = document.getElementById('roomList');
                const inpCodeEl = document.getElementById('inpCode');
                const inpPasswordEl = document.getElementById('inpPassword');
                
                if(rooms.length === 0) {
                    roomListEl.style.display = 'none';
                    inpCodeEl.style.display = 'block';
                    inpCodeEl.placeholder = 'Raum-Code';
                    inpPasswordEl.style.display = 'none';
                    inpCodeEl.focus();
                } else {
                    roomListEl.style.display = 'block';
                    inpCodeEl.style.display = 'none';
                    inpPasswordEl.style.display = 'none';
                    roomListEl.innerHTML = rooms.map(room => `
                        <div class="card" style="padding:15px; margin-bottom:10px; cursor:pointer; background:linear-gradient(145deg, #1e1e1e, #252525);" onclick="selectRoom('${room.id}', ${room.hasPassword ? 'true' : 'false'})">
                            <div style="font-weight:bold; font-size:1.1rem; color:#ff8c00;">
                                ${room.hasPassword ? 'ğŸ”’ ' : ''}Raum von ${room.hostName}
                            </div>
                            <div style="font-size:0.85rem; color:#aaa; margin-top:5px;">ğŸ‘¥ ${room.playerCount} Spieler</div>
                        </div>
                    `).join('');
                }
            } catch(error) {
                console.error('Fehler beim Laden der RÃ¤ume:', error);
                showToast("Fehler beim Laden der RÃ¤ume");
            }
        };
        
        window.selectRoom = (roomId, hasPassword) => {
            // Zeige Code-Eingabefeld und Passwort-Feld
            document.getElementById('inpCode').style.display = 'block';
            document.getElementById('inpCode').placeholder = 'Raum-Code';
            document.getElementById('inpCode').value = '';
            document.getElementById('inpCode').focus();
            if(hasPassword) {
                document.getElementById('inpPassword').style.display = 'block';
                document.getElementById('inpPassword').placeholder = 'Passwort erforderlich';
                document.getElementById('inpPassword').value = '';
            } else {
                document.getElementById('inpPassword').style.display = 'none';
                document.getElementById('inpPassword').value = '';
            }
            // Verstecke Raumliste
            document.getElementById('roomList').style.display = 'none';
        };
        window.toggleLobbyReady = async () => {
            if(!roomId) return;
            const current = !!(globalData?.lobbyReady?.[myName]);
            await updateDoc(doc(db, "lobbies", roomId), {
                [`lobbyReady.${myName}`]: !current
            });
        };

        // --- CREATE GAME ---
        window.createGame = async () => {
            const name = document.getElementById('inpName').value.trim();
            const emoji = document.getElementById('inpEmoji').value || 'ğŸ˜Š';
            const gender = "divers"; // Deaktiviert, aber behalten
            const gameMode = getSelectedGameMode();
            const selectedCategories = getSelectedCategories();
            const roomPassword = document.getElementById('inpRoomPassword').value.trim();
            
            if(!name) {
                showToast("Bitte gib einen Namen ein!");
                return;
            }
            
            if(selectedCategories.length === 0) {
                showToast("Bitte wÃ¤hle mindestens eine Kategorie aus!");
                return;
            }
            
            // Konfiguration basierend auf Spielmodus
            let dmg, speed, startTemp, maxTemp;
            if(gameMode === 'strategisch') {
                dmg = 10;
                speed = 1.0;
                startTemp = 0;
                maxTemp = 120;
            } else { // party
                dmg = 20; // Schaden fÃ¼r Angriff
                speed = 1.5;
                startTemp = 0;
                maxTemp = 100;
            }
            
            const code = Math.random().toString(36).substring(2,6).toUpperCase();
            myName = name;
            myEmoji = emoji;
            myGender = gender;
            roomId = code;
            sessionStorage.setItem("hk_name", name);
            sessionStorage.setItem("hk_emoji", emoji);
            sessionStorage.setItem("hk_gender", gender);
            sessionStorage.setItem("hk_room", code);
            
            // Erste Frage aus aktiven Kategorien
            const firstQuestion = getAllQuestions(selectedCategories)[0] || { q: "Willkommen zu Hitzkopf!", a: "A", b: "B" };
            const firstCategory = firstQuestion.category || null;

            await setDoc(doc(db, "lobbies", code), {
                host: name,
                hostName: name, // FÃ¼r Raumliste
                status: "lobby",
                players: { [name]: { temp: startTemp, inventory: [], gender: gender, emoji: emoji } },
                config: { dmg: dmg, speed: speed, startTemp: startTemp, maxTemp: maxTemp, gameMode: gameMode, categories: selectedCategories },
                votes: {},
                ready: [],
                log: [],
                hotseat: "",
                currentQ: firstQuestion,
                roundId: 0,
                lobbyReady: {},
                countdownEnds: null,
                usedQuestions: [],
                eliminatedShown: [],
                rematchVotes: {},
                winner: null,
                password: roomPassword || "", // Leer = Ã¶ffentlich
                lastQuestionCategory: firstCategory,
                pendingAttacks: {} // Sammelt Angriffe: { targetName: [{ attacker, dmg, hasOil }] }
            });
            
            showToast(`Raum erstellt! Code: ${code}`);
            
            connectToLobby();
        };

        // --- JOIN GAME ---
        window.joinGame = async () => {
            const name = document.getElementById('inpName').value.trim();
            const emoji = document.getElementById('inpEmoji').value || 'ğŸ˜Š';
            const gender = "divers"; // Deaktiviert, aber behalten
            const code = document.getElementById('inpCode').value.trim().toUpperCase();
            const password = document.getElementById('inpPassword').value.trim();
            
            if(!name || !code) {
                showToast("Bitte gib Name und Code ein!");
                return;
            }
            
            // PasswortprÃ¼fung
            const ref = doc(db, "lobbies", code);
            const snap = await getDoc(ref);
            if(!snap.exists()) {
                showToast("Lobby nicht gefunden! PrÃ¼fe den Code.");
                return;
            }
            
            const roomData = snap.data();
            const roomPassword = roomData.password || "";
            
            // Wenn Raum ein Passwort hat, muss es Ã¼bereinstimmen
            if(roomPassword && roomPassword.trim().length > 0) {
                if(!password || password !== roomPassword) {
                    showToast("Falsches Passwort! Bitte versuche es erneut.");
                    return;
                }
            }
            
            myName = name;
            myEmoji = emoji;
            myGender = gender;
            roomId = code;
            sessionStorage.setItem("hk_name", name);
            sessionStorage.setItem("hk_emoji", emoji);
            sessionStorage.setItem("hk_gender", gender);
            sessionStorage.setItem("hk_room", code);

            // data wird bereits oben geladen (siehe PasswortprÃ¼fung)
            const data = snap.data();
            const startTemp = data.config?.startTemp || 0;
            if(!data.players[name]) {
                await updateDoc(ref, { [`players.${name}`]: { temp: startTemp, inventory: [], gender: gender, emoji: emoji } });
            } else {
                // Emoji und Geschlecht aktualisieren falls bereits vorhanden
                await updateDoc(ref, { 
                    [`players.${name}.gender`]: gender,
                    [`players.${name}.emoji`]: emoji
                });
            }
            connectToLobby();
        };

        // --- CONNECT TO LOBBY ---
        function connectToLobby() {
            onSnapshot(doc(db, "lobbies", roomId), (snap) => {
                if(!snap.exists()) { 
                    sessionStorage.clear(); 
                    location.reload(); 
                    return; 
                }
                const data = snap.data();
                globalData = data;

                // PrÃ¼fe ob Angriffe ausgefÃ¼hrt wurden und zeige beim Angegriffenen
                const meState = data.players?.[myName];
                if(meState) {
                    // PrÃ¼fe ob Angriffe ausgefÃ¼hrt wurden (durch executePendingAttacks)
                    if(data.attackResults && data.attackResults[myName]) {
                        const result = data.attackResults[myName];
                        triggerAttackFeedback(result.attackers, result.totalDmg);
                        // Entferne nach Anzeige (mit kurzer VerzÃ¶gerung damit alle sehen kÃ¶nnen)
                        setTimeout(() => {
                            if(isHost) {
                                const newResults = { ...(data.attackResults || {}) };
                                delete newResults[myName];
                                updateDoc(doc(db, "lobbies", roomId), { attackResults: newResults }).catch(console.error);
                            }
                        }, 3500);
                    }
                    lastMyTemp = meState.temp;
                } else {
                    lastMyTemp = null;
                }

                if(data.status === 'closed') {
                    if(!lobbyClosedHandled) {
                        lobbyClosedHandled = true;
                        showToast("ğŸ›‘ Host hat die Lobby beendet.");
                    }
                    sessionStorage.clear();
                    setTimeout(() => location.reload(), 200);
                    return;
                }
                
                isHost = (data.host === myName);
                if(isHost) {
                    document.getElementById('hostControls').style.display = 'block';
                    document.getElementById('btnHostStart').style.display = 'block';
                    document.getElementById('lblWait').style.display = 'none';
                }

                // RENDER
                renderThermos(data.players, 'gridGame');
                renderThermos(data.players, 'gridResult');
                renderLog(data.log);

                // DEATH CHECK - Spieler mit 100Â° fliegen raus, kÃ¶nnen aber zuschauen
                const maxTemp = data.config?.maxTemp || 100;
                const activePlayers = Object.keys(data.players).filter(p => data.players[p].temp < maxTemp);
                const eliminatedPlayers = Object.keys(data.players).filter(p => data.players[p].temp >= maxTemp);
                
                // PrÃ¼fe ob Spieler gerade rausgeflogen ist (fÃ¼r Animation)
                if(eliminatedPlayers.length > 0 && isHost) {
                    eliminatedPlayers.forEach(eliminated => {
                        const eliminatedShown = data.eliminatedShown || [];
                        if(!eliminatedShown.includes(eliminated)) {
                            // Markiere als gezeigt
                            updateDoc(doc(db, "lobbies", roomId), {
                                eliminatedShown: arrayUnion(eliminated)
                            }).catch(console.error);
                        }
                    });
                }
                
                // Zeige Animation fÃ¼r alle (auch wenn nicht Host)
                eliminatedPlayers.forEach(eliminated => {
                    const eliminatedShown = data.eliminatedShown || [];
                    if(eliminatedShown.includes(eliminated)) {
                        // Nur einmal zeigen
                        return;
                    }
                    // Zeige Animation fÃ¼r rausgeflogenen Spieler
                    showEliminationAnimation(eliminated, data.players[eliminated].temp);
                });

                // PrÃ¼fe ob nur noch ein Spieler Ã¼brig ist (Gewinner) - NUR wÃ¤hrend des Spiels
                if((data.status === 'game' || data.status === 'result') && activePlayers.length === 1 && data.status !== 'winner' && data.status !== 'voting') {
                    const winner = activePlayers[0];
                    if(isHost) {
                        updateDoc(doc(db, "lobbies", roomId), {
                            status: 'winner',
                            winner: winner
                        }).catch(console.error);
                    }
                } else if((data.status === 'game' || data.status === 'result') && activePlayers.length === 0 && data.status !== 'voting') {
                    // Fallback: Wenn alle raus sind, gewinnt der mit niedrigster Temperatur
                    let minTemp = 999;
                    let winner = null;
                    Object.keys(data.players).forEach(p => {
                        if(data.players[p].temp < minTemp) {
                            minTemp = data.players[p].temp;
                            winner = p;
                        }
                    });
                    if(winner && isHost) {
                        updateDoc(doc(db, "lobbies", roomId), {
                            status: 'winner',
                            winner: winner
                        }).catch(console.error);
                    }
                }

                // PrÃ¼fe ob Spieler rausgeflogen ist (fÃ¼r Spectator-Mode)
                if(eliminatedPlayers.includes(myName)) {
                    showSpectatorMode();
                } else {
                    hideSpectatorMode();
                }

                // ROUTER
                const shareBtn = document.getElementById('btnShare');
                const readyBtn = document.getElementById('btnLobbyReady');
                const readyStatus = document.getElementById('lobbyReadyStatus');
                const readyList = document.getElementById('lobbyReadyList');
                const hostStartBtn = document.getElementById('btnHostStart');
                if(data.status === 'lobby') {
                    showScreen('screen-lobby');
                    const players = Object.keys(data.players);
                    document.getElementById('lobbyList').innerHTML = players.map(p => 
                        `<div>${p}${p === data.host ? ' ğŸ‘‘' : ''}</div>`
                    ).join('');
                    const readyObj = data.lobbyReady || {};
                    if(readyList) {
                        readyList.innerHTML = players.map(p => {
                            const ready = readyObj[p];
                            const icon = ready ? 'âœ…' : 'â³';
                            const playerData = data.players[p];
                            const playerEmoji = playerData?.emoji || 'ğŸ˜Š';
                            return `<div>${icon} ${playerEmoji} ${p}</div>`;
                        }).join('');
                    }
                    const readyCount = players.filter(p => readyObj[p]).length;
                    if(readyStatus) readyStatus.innerText = `Bereit: ${readyCount}/${players.length}`;
                    if(readyBtn) {
                        readyBtn.style.display = 'block';
                        readyBtn.innerText = readyObj[myName] ? "âŒ Nicht bereit" : "âœ… Bereit";
                        readyBtn.classList.toggle('btn-primary', !readyObj[myName]);
                        readyBtn.classList.toggle('btn-secondary', !!readyObj[myName]);
                    }
                    if(hostStartBtn) {
                        hostStartBtn.style.display = isHost ? 'block' : 'none';
                        hostStartBtn.disabled = !(isHost && readyCount === players.length && players.length >= 2);
                    }
                    lastTemps = {};
                    if(shareBtn) shareBtn.style.display = 'block';
                }
                else if(data.status === 'countdown') {
                    showScreen('screen-lobby');
                    if(readyBtn) readyBtn.style.display = 'none';
                    if(readyStatus) readyStatus.innerText = "";
                    if(readyList) readyList.innerHTML = "";
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) {
                        hostStartBtn.disabled = true;
                        hostStartBtn.style.display = 'none';
                    }
                }
                else if(data.status === 'game') {
                    // Sicherstellen, dass currentQ gesetzt ist und korrekt formatiert
                    let currentQ = data.currentQ;
                    if(currentQ && typeof currentQ === 'object') {
                        // PrÃ¼fe ob es ein Firebase Timestamp oder Map ist
                        if(currentQ.toDate || currentQ.toMillis) currentQ = null;
                    }
                    if(!currentQ || typeof currentQ.q !== 'string' || !currentQ.q) {
                        if(isHost) {
                            const usedQuestions = data.usedQuestions || [];
                            const activeCategories = data.config?.categories || Object.keys(questionCategories);
                            const lastCategory = data.lastQuestionCategory || null;
                            const { question: q, category: qCategory } = getRandomUnusedQuestion(usedQuestions, activeCategories, lastCategory);
                            updateDoc(doc(db, "lobbies", roomId), { currentQ: q, lastQuestionCategory: qCategory }).catch(console.error);
                            data.currentQ = q;
                        } else {
                            // Fallback fÃ¼r Nicht-Hosts
                            const activeCategories = data.config?.categories || Object.keys(questionCategories);
                            const allQuestions = getAllQuestions(activeCategories);
                            data.currentQ = allQuestions[0] || { q: "Lade Frage...", a: "A", b: "B" };
                        }
                    } else {
                        data.currentQ = currentQ; // Verwende das bereinigte currentQ
                    }
                    if(readyBtn) readyBtn.style.display = 'none';
                    if(readyStatus) readyStatus.innerText = "";
                    if(readyList) readyList.innerHTML = "";
                    showScreen('screen-game');
                    renderGame(data);
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) hostStartBtn.style.display = 'none';
                    // Host Auto-Advance
                    if(isHost && Object.keys(data.votes).length >= Object.keys(data.players).length) {
                        setTimeout(() => {
                            updateDoc(doc(db, "lobbies", roomId), { status: 'result' });
                        }, 500);
                    }
                }
                else if(data.status === 'result') {
                    // Sicherstellen, dass currentQ gesetzt ist und korrekt formatiert
                    let currentQ = data.currentQ;
                    if(currentQ && typeof currentQ === 'object') {
                        // PrÃ¼fe ob es ein Firebase Timestamp oder Map ist
                        if(currentQ.toDate || currentQ.toMillis) currentQ = null;
                    }
                    if(!currentQ || typeof currentQ.q !== 'string' || !currentQ.q) {
                        if(isHost) {
                            const usedQuestions = data.usedQuestions || [];
                            const activeCategories = data.config?.categories || Object.keys(questionCategories);
                            const lastCategory = data.lastQuestionCategory || null;
                            const { question: q, category: qCategory } = getRandomUnusedQuestion(usedQuestions, activeCategories, lastCategory);
                            updateDoc(doc(db, "lobbies", roomId), { currentQ: q, lastQuestionCategory: qCategory }).catch(console.error);
                            data.currentQ = q;
                        } else {
                            // Fallback fÃ¼r Nicht-Hosts
                            const activeCategories = data.config?.categories || Object.keys(questionCategories);
                            const allQuestions = getAllQuestions(activeCategories);
                            data.currentQ = allQuestions[0] || { q: "Lade Frage...", a: "A", b: "B" };
                        }
                    } else {
                        data.currentQ = currentQ; // Verwende das bereinigte currentQ
                    }
                    if(readyBtn) readyBtn.style.display = 'none';
                    if(readyStatus) readyStatus.innerText = "";
                    if(readyList) readyList.innerHTML = "";
                    showScreen('screen-result');
                    renderResult(data);
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) hostStartBtn.style.display = 'none';
                    // Host Auto-Next
                    if(isHost && data.ready.length >= Object.keys(data.players).length) {
                        setTimeout(() => nextRound(), 1000);
                    }
                }
                else if(data.status === 'winner') {
                    showScreen('screen-winner');
                    renderWinner(data.winner, data.players);
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) hostStartBtn.style.display = 'none';
                    // Nach 5 Sekunden zum Voting-Screen
                    if(isHost) {
                        setTimeout(() => {
                            updateDoc(doc(db, "lobbies", roomId), { status: 'voting' }).catch(console.error);
                        }, 5000);
                    }
                }
                else if(data.status === 'voting') {
                    showScreen('screen-voting');
                    renderVoting(data);
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) hostStartBtn.style.display = 'none';
                }
                handleCountdownOverlay(data);
            });
        }
        // --- RENDER GAME ---
        function renderGame(data) {
            const roundId = data.roundId ?? 0;
            const btnLock = document.getElementById('btnLock');
            const btnA = document.getElementById('btnA');
            const btnB = document.getElementById('btnB');
            const lblHotseat = document.getElementById('lblHotseat');
            const lblHotseatSub = document.getElementById('lblHotseatSub');

            if(lastRoundId !== roundId) {
                lastRoundId = roundId;
                localActionDone = false;
                mySelection = null;
                btnA.classList.remove('selected');
                btnB.classList.remove('selected');
                btnLock.disabled = true;
                // A/B Buttons werden spÃ¤ter aktiviert, wenn hotseat gesetzt ist
            }

            if(data.votes[myName]) {
                btnLock.classList.add('hidden');
                // Wenn bereits abgestimmt, A/B Buttons deaktivieren
                const optionRow = document.getElementById('optionRow');
                if(optionRow) {
                    optionRow.style.opacity = '0.5';
                    optionRow.style.pointerEvents = 'none';
                }
            } else {
                btnLock.classList.remove('hidden');
                // Strategie ist nur eine Vorauswahl, nicht mehr zwingend
                btnLock.disabled = !mySelection;
            }

            // Robustere Behandlung von currentQ (Firebase kann Objekte anders serialisieren)
            let currentQ = data.currentQ;
            if(currentQ && typeof currentQ === 'object') {
                // PrÃ¼fe ob es ein Firebase Timestamp oder Map ist
                if(currentQ.toDate) currentQ = null; // Timestamp, ignorieren
                if(currentQ.toMillis) currentQ = null; // Timestamp, ignorieren
            }
            
            if(currentQ && currentQ.q && typeof currentQ.q === 'string') {
                document.getElementById('lblQuestion').innerText = currentQ.q;
                btnA.innerText = currentQ.a || 'A';
                btnB.innerText = currentQ.b || 'B';
                
                // Kategorie anzeigen
                const categoryLabel = document.getElementById('lblQuestionCategory');
                if(categoryLabel && currentQ.category) {
                    const cat = questionCategories[currentQ.category];
                    if(cat) {
                        categoryLabel.innerText = `${cat.emoji} ${cat.name}`;
                        categoryLabel.style.display = 'block';
                    } else {
                        categoryLabel.style.display = 'none';
                    }
                } else if(categoryLabel) {
                    categoryLabel.style.display = 'none';
                }
            } else {
                // Fallback falls currentQ fehlt oder falsch formatiert
                console.warn('currentQ fehlt oder ist falsch formatiert:', currentQ);
                const activeCategories = globalData?.config?.categories || Object.keys(questionCategories);
                const allQuestions = getAllQuestions(activeCategories);
                const fallbackQ = allQuestions[0] || { q: "Lade Frage...", a: "A", b: "B" };
                document.getElementById('lblQuestion').innerText = fallbackQ.q;
                btnA.innerText = fallbackQ.a;
                btnB.innerText = fallbackQ.b;
                
                // Versuche currentQ zu reparieren (nur als Host)
                if(isHost && globalData) {
                    const usedQuestions = globalData.usedQuestions || [];
                    const activeCategories = globalData.config?.categories || Object.keys(questionCategories);
                    const lastCategory = globalData.lastQuestionCategory || null;
                    const { question: q, category: qCategory } = getRandomUnusedQuestion(usedQuestions, activeCategories, lastCategory);
                    updateDoc(doc(db, "lobbies", roomId), { currentQ: q, lastQuestionCategory: qCategory }).catch(console.error);
                }
            }
            
            if(!data.hotseat) {
                lblHotseat.innerText = "Runde wird vorbereitet...";
                lblHotseatSub.innerText = "Bitte kurz warten.";
                // A/B Buttons aktivieren
                const optionRow = document.getElementById('optionRow');
                if(optionRow) {
                    optionRow.style.opacity = '1';
                    optionRow.style.pointerEvents = 'auto';
                }
            } else if(myName === data.hotseat) {
                lblHotseat.innerText = "Du beantwortest die Frage!";
                lblHotseatSub.innerText = "Antworte ehrlich â€“ die anderen versuchen deine Wahl zu erraten.";
                // Hotseat kann direkt A/B wÃ¤hlen
                const optionRow = document.getElementById('optionRow');
                if(optionRow) {
                    optionRow.style.opacity = '1';
                    optionRow.style.pointerEvents = 'auto';
                }
            } else {
                lblHotseat.innerText = `${data.hotseat} beantwortet die Frage!`;
                const gameMode = data.config?.gameMode || 'party';
                const isPartyMode = gameMode === 'party';
                if(isPartyMode) {
                    lblHotseatSub.innerText = "Errate die Wahl, um einen Spieler aufzuheizen!";
                } else {
                    lblHotseatSub.innerText = "Errate die Wahl, um anzugreifen oder Joker zu ziehen.";
                }
                // A/B Buttons aktivieren
                const optionRow = document.getElementById('optionRow');
                if(optionRow) {
                    optionRow.style.opacity = '1';
                    optionRow.style.pointerEvents = 'auto';
                }
            }
            
            const players = Object.keys(data.players);
            const voted = players.filter(p => data.votes[p]);
            const pending = players.filter(p => !data.votes[p]);
            const voteStatusEl = document.getElementById('lblVoteStatus');
            const voteText = voted.length ? voted.join(', ') : 'Niemand';
            const pendingText = pending.length ? pending.join(', ') : 'Niemand';
            voteStatusEl.innerHTML = `âœ… Abgegeben: ${voteText}<br>ğŸ¤” Ãœberlegen: ${pendingText}`;
            // Joker nur im Strategiemodus anzeigen
            const gameMode = data.config?.gameMode || 'party';
            const isPartyMode = gameMode === 'party';
            const jokerPanelGame = document.getElementById('jokerPanelGame');
            if(jokerPanelGame) {
                jokerPanelGame.style.display = isPartyMode ? 'none' : 'block';
            }
            
            if(data.players[myName] && !isPartyMode) {
                renderMyJokers('myJokerListGame', data.players[myName]);
            }
        }

        // --- RENDER RESULT ---
        function renderResult(data) {
            const truth = data.votes[data.hotseat]?.choice;
            let truthText = '?';
            
            // Robustere Behandlung von currentQ (Firebase kann Objekte anders serialisieren)
            let currentQ = data.currentQ;
            if(currentQ && typeof currentQ === 'object') {
                // PrÃ¼fe ob es ein Firebase Timestamp oder Map ist
                if(currentQ.toDate) currentQ = null; // Timestamp, ignorieren
                if(currentQ.toMillis) currentQ = null; // Timestamp, ignorieren
            }
            
            if(truth && currentQ && typeof currentQ.a === 'string' && typeof currentQ.b === 'string') {
                truthText = truth === 'A' ? currentQ.a : currentQ.b;
            } else if(truth) {
                // Fallback falls currentQ fehlt
                console.warn('currentQ fehlt in renderResult:', currentQ);
                truthText = truth === 'A' ? 'A' : 'B';
            }
            document.getElementById('lblTruth').innerText = truthText;
            
            // Kategorie anzeigen
            const categoryLabel = document.getElementById('lblResultCategory');
            if(categoryLabel && currentQ && currentQ.category) {
                const cat = questionCategories[currentQ.category];
                if(cat) {
                    categoryLabel.innerText = `${cat.emoji} ${cat.name}`;
                    categoryLabel.style.display = 'block';
                } else {
                    categoryLabel.style.display = 'none';
                }
            } else if(categoryLabel) {
                categoryLabel.style.display = 'none';
            }

            const myVote = data.votes[myName];
            const statusEl = document.getElementById('lblResultStatus');
            const boxAttack = document.getElementById('boxAttack');
            const boxShop = document.getElementById('boxShop');
            const btnReady = document.getElementById('btnReady');

            // Reset Boxes
            boxAttack.style.display = 'none';
            boxShop.style.display = 'none';
            
            // Ready Status mit Namen
            const players = Object.keys(data.players);
            const readyPlayers = data.ready || [];
            const notReadyPlayers = players.filter(p => !readyPlayers.includes(p));
            
            let readyText = `âœ… Bereit (${readyPlayers.length}/${players.length}): `;
            if(readyPlayers.length > 0) {
                readyText += readyPlayers.map(p => {
                    const playerData = data.players[p];
                    const playerEmoji = playerData?.emoji || 'ğŸ˜Š';
                    return `${playerEmoji} ${p}`;
                }).join(', ');
            } else {
                readyText += "Niemand";
            }
            
            if(notReadyPlayers.length > 0) {
                readyText += `<br>â³ Noch nicht bereit: `;
                readyText += notReadyPlayers.map(p => {
                    const playerData = data.players[p];
                    const playerEmoji = playerData?.emoji || 'ğŸ˜Š';
                    return `${playerEmoji} ${p}`;
                }).join(', ');
            }
            
            document.getElementById('lblReady').innerHTML = readyText;
            
            if(data.ready.includes(myName)) {
                btnReady.disabled = true;
                btnReady.innerText = "â³ Warte...";
                return;
            } else {
                btnReady.disabled = false;
                btnReady.innerText = "ğŸ‘ Bereit";
            }

            if(isHost) {
                maybeLogRoundSummary(data, truthText, truth);
            }

            // Zeige Rekapitulation wenn alle bereit sind (nur einmal pro Runde)
            if(data.ready.length >= Object.keys(data.players).length && !data.roundRecapShown) {
                if(isHost) {
                    // FÃ¼hre gesammelte Angriffe aus bevor Rekapitulation gezeigt wird
                    executePendingAttacks(data).then(() => {
                        updateDoc(doc(db, "lobbies", roomId), { roundRecapShown: true }).catch(console.error);
                    });
                }
                // Zeige Rekapitulation nach kurzer VerzÃ¶gerung
                setTimeout(() => {
                    showRoundRecap(data);
                }, 1500);
            }

            const gameMode = data.config?.gameMode || 'party';
            const isPartyMode = gameMode === 'party';
            
            // Joker-Panel nur im Strategiemodus anzeigen
            const jokerPanel = document.querySelector('.joker-panel');
            if(jokerPanel) {
                jokerPanel.style.display = isPartyMode ? 'none' : 'block';
            }
            
            if(myName === data.hotseat) {
                statusEl.innerText = "Du hast die Frage beantwortet.";
                statusEl.style.color = "#aaa";
            } else {
                if(myVote && myVote.choice === truth) {
                    if(isPartyMode) {
                        // Partymodus: Direkt Angriff-Auswahl
                        statusEl.innerHTML = "âœ… <strong>RICHTIG GERATEN!</strong><br><span style='font-size:0.9rem; font-weight:normal;'>WÃ¤hle einen Spieler zum Aufheizen!</span>";
                        statusEl.style.color = "#0f0";
                        
                        if(!localActionDone) {
                            btnReady.disabled = true;
                            btnReady.innerText = "âš¡ WÃ¤hle einen Spieler!";
                            
                            const boxAttackEl = document.getElementById('boxAttack');
                            if(boxAttackEl) {
                                boxAttackEl.style.display = 'block';
                                renderTargets(data.players);
                            }
                        }
                    } else {
                        // Strategiemodus: Belohnungsauswahl
                        statusEl.innerHTML = "âœ… <strong>RICHTIG GERATEN!</strong><br><span style='font-size:0.9rem; font-weight:normal;'>Hier ist deine Belohnung, wie mÃ¶chtest du vorgehen?</span>";
                        statusEl.style.color = "#0f0";

                        if(!localActionDone) {
                            btnReady.disabled = true;
                            btnReady.innerText = "âš¡ WÃ¤hle deine Belohnung!";
                            
                            const rewardBoxEl = document.getElementById('boxReward');
                            if(rewardBoxEl) {
                                rewardBoxEl.style.display = 'block';
                            }
                        }
                    }
                } else {
                    if(!myVote) {
                        statusEl.innerText = "âŒ› Keine Antwort abgegeben.";
                        statusEl.style.color = "#ccc";
                    } else {
                        statusEl.innerText = "âŒ FALSCH";
                        statusEl.style.color = "#f00";
                        
                        // Partymodus: Bei falscher Antwort automatisch 10Â° selbst bekommen
                        if(isPartyMode && !localActionDone) {
                            localActionDone = true;
                            handlePartyModeWrongAnswer();
                        }
                    }
                    if(!isPartyMode || (isPartyMode && !myVote)) {
                        localActionDone = true;
                    }
                }
            }
            if(data.players[myName] && !isPartyMode) {
                renderMyJokers('myJokerListResult', data.players[myName]);
            }
        }

        // --- RENDER TARGETS ---
        window.renderTargets = (players) => {
            const div = document.getElementById('divTargets');
            const attackTitle = document.getElementById('attackTitle');
            const btnBack = document.getElementById('btnBackFromAttack');
            const btnSkip = document.getElementById('btnSkipAttack');
            div.innerHTML = "";
            const gameMode = globalData?.config?.gameMode || 'party';
            const isPartyMode = gameMode === 'party';
            const dmg = isPartyMode ? 20 : (globalData?.config?.dmg || 10);
            
            // Anpassen fÃ¼r Partymodus
            if(isPartyMode) {
                if(attackTitle) attackTitle.innerText = "ğŸ”¥ Wen aufheizen?";
                if(btnBack) btnBack.style.display = 'none';
                if(btnSkip) btnSkip.style.display = 'none';
            } else {
                if(attackTitle) attackTitle.innerText = "ğŸ”¥ Wen angreifen?";
                if(btnBack) btnBack.style.display = 'block';
                if(btnSkip) btnSkip.style.display = 'block';
            }
            
            Object.keys(players).forEach(p => {
                if(p !== myName) {
                    const b = document.createElement('button');
                    b.className = 'btn-danger';
                    b.innerText = `${p} (+${dmg}Â°C)`;
                    b.onclick = () => doAttack(p);
                    div.appendChild(b);
                }
            });
        };

        // --- SELECT STRATEGY ---
        window.selectStrategy = (strat) => {
            myStrategy = strat;
            const btnAttack = document.getElementById('btnStratAttack');
            const btnInvest = document.getElementById('btnStratInvest');
            const lockBtn = document.getElementById('btnLock');
            
            // Buttons markieren (nur visuelle Vorauswahl)
            if(btnAttack) {
                btnAttack.classList.toggle('selected', strat === 'attack');
            }
            if(btnInvest) {
                btnInvest.classList.toggle('selected', strat === 'invest');
            }
            
            // Lock-Button aktivieren, wenn bereits A/B gewÃ¤hlt wurde
            if(lockBtn && mySelection) {
                lockBtn.disabled = false;
            }
        };

        // --- VOTE ---
        window.vote = (opt) => {
            // Strategie ist nur eine Vorauswahl, nicht mehr zwingend erforderlich
            mySelection = opt;
            document.getElementById('btnA').classList.toggle('selected', opt === 'A');
            document.getElementById('btnB').classList.toggle('selected', opt === 'B');
            const lockBtn = document.getElementById('btnLock');
            lockBtn.disabled = false;
        };

        // --- SUBMIT VOTE ---
        window.submitVote = async () => {
            // PrÃ¼fe ob Hotseat (dann keine Strategie nÃ¶tig)
            const stratSection = document.getElementById('stratSection');
            const isHotseat = stratSection && stratSection.classList.contains('hidden');
            
            if(!mySelection) {
                showToast("Bitte wÃ¤hle zuerst eine Antwort (A oder B)!");
                return;
            }
            
            // Strategie ist nur eine Vorauswahl, wird nicht mehr bindend gespeichert
            // Die finale Entscheidung wird im Result-Screen getroffen
            let strat = myStrategy || 'none'; // Vorauswahl oder 'none' als Fallback
            
            // Hotseat braucht keine Strategie (wird ignoriert)
            if(isHotseat) {
                strat = 'none'; // Placeholder fÃ¼r Hotseat
            }
            
            document.getElementById('btnLock').classList.add('hidden');
            
            await updateDoc(doc(db, "lobbies", roomId), {
                [`votes.${myName}`]: { choice: mySelection, strategy: strat }
            });
        };

        // --- CHOOSE REWARD ---
        window.chooseReward = (rewardType) => {
            const rewardBox = document.getElementById('boxReward');
            if(rewardBox) rewardBox.style.display = 'none';
            
            const boxAttack = document.getElementById('boxAttack');
            const boxShop = document.getElementById('boxShop');
            
            if(rewardType === 'attack') {
                boxAttack.style.display = 'block';
                renderTargets(globalData.players);
            } else if(rewardType === 'invest') {
                boxShop.style.display = 'block';
            }
        };

        // --- GO BACK TO REWARD ---
        window.goBackToReward = () => {
            const rewardBox = document.getElementById('boxReward');
            const boxAttack = document.getElementById('boxAttack');
            const boxShop = document.getElementById('boxShop');
            
            if(rewardBox) rewardBox.style.display = 'block';
            if(boxAttack) boxAttack.style.display = 'none';
            if(boxShop) boxShop.style.display = 'none';
        };

        // --- ATTACK ---
        window.doAttack = async (target) => {
            localActionDone = true;
            const rewardBox = document.getElementById('boxReward');
            if(rewardBox) rewardBox.style.display = 'none';
            document.getElementById('boxAttack').style.display = 'none';
            document.getElementById('btnReady').disabled = false;
            
            const gameMode = globalData?.config?.gameMode || 'party';
            const isPartyMode = gameMode === 'party';
            const baseDmg = isPartyMode ? 20 : (globalData?.config?.dmg || 10); // Partymodus: 20Â°
            const attackerState = globalData?.players?.[myName] || {};
            const hasOil = attackerState.inventory?.includes('card_oil');
            const dmg = baseDmg * (hasOil ? 2 : 1);
            
            // Angriff sammeln statt sofort ausfÃ¼hren
            const ref = doc(db, "lobbies", roomId);
            const pendingAttacks = globalData.pendingAttacks || {};
            if(!pendingAttacks[target]) {
                pendingAttacks[target] = [];
            }
            pendingAttacks[target].push({
                attacker: myName,
                dmg: dmg,
                hasOil: hasOil
            });
            
            // Ã–lfass entfernen wenn verwendet
            if(hasOil) {
                await updateDoc(ref, { 
                    [`players.${myName}.inventory`]: arrayRemove('card_oil'),
                    pendingAttacks: pendingAttacks
                });
            } else {
                await updateDoc(ref, { 
                    pendingAttacks: pendingAttacks
                });
            }
        };

        // --- TAKE CARD ---
        window.takeCard = async (card) => {
            localActionDone = true;
            const rewardBox = document.getElementById('boxReward');
            if(rewardBox) rewardBox.style.display = 'none';
            document.getElementById('boxShop').style.display = 'none';
            document.getElementById('btnReady').disabled = false;

            const inventory = globalData?.players?.[myName]?.inventory || [];
            if(inventory.includes(card)) {
                showToast("Du besitzt diesen Joker bereits! Du kannst jeden Joker nur einmal haben.");
                return;
            }

            await updateDoc(doc(db, "lobbies", roomId), {
                [`players.${myName}.inventory`]: arrayUnion(card),
                log: arrayUnion(`ğŸƒ ${myName} zieht eine geheime Karte.`)
            });
            
            // Zeige Animation
            await showJokerAnimation(myName, card);
            
            showToast(`${cardInfo[card].label} erhalten! ${cardInfo[card].desc}`);
        };

        // --- SKIP ATTACK ---
        window.skipAttack = async () => {
            localActionDone = true;
            const rewardBox = document.getElementById('boxReward');
            if(rewardBox) rewardBox.style.display = 'none';
            document.getElementById('boxAttack').style.display = 'none';
            document.getElementById('btnReady').disabled = false;
            document.getElementById('btnReady').innerText = "ğŸ‘ Bereit";
            await updateDoc(doc(db, "lobbies", roomId), {
                log: arrayUnion(`ğŸ•Šï¸ ${myName} verzichtet auf einen Angriff.`)
            });
        };

        // --- SET READY ---
        window.setReady = async () => {
            await updateDoc(doc(db, "lobbies", roomId), { 
                ready: arrayUnion(myName) 
            });
        };
        
        // --- PARTY MODE WRONG ANSWER ---
        async function handlePartyModeWrongAnswer() {
            const dmg = 10; // 10Â° selbst bekommen bei falscher Antwort
            await updateDoc(doc(db, "lobbies", roomId), {
                [`players.${myName}.temp`]: increment(dmg),
                log: arrayUnion(`âŒ ${myName} hat falsch geraten und sich selbst aufgeheizt (+${dmg}Â°C)`)
            });
            showToast(`Du hast falsch geraten! +${dmg}Â°C fÃ¼r dich.`);
        }
        // --- START GAME (COUNTDOWN) ---
        window.startCountdown = async () => {
            if(!isHost || !globalData) return;
            const players = Object.keys(globalData.players);
            if(players.length < 2) {
                showToast("Mindestens 2 Spieler benÃ¶tigt!");
                return;
            }
            const readyObj = globalData.lobbyReady || {};
            const unready = players.filter(p => !readyObj[p]);
                if(unready.length) {
                showToast(`Noch nicht alle bereit: ${unready.join(', ')}`);
                return;
            }
            
            await applyIceCooling(globalData.players);
            const usedQuestions = globalData.usedQuestions || [];
            const activeCategories = globalData.config?.categories || Object.keys(questionCategories);
            const lastCategory = globalData.lastQuestionCategory || null;
            const { question: q, index: qIdx, category: qCategory } = getRandomUnusedQuestion(usedQuestions, activeCategories, lastCategory);
            const nextRoundId = (globalData?.roundId ?? 0) + 1;
            const countdownEnds = Date.now() + 3000;
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'countdown',
                hotseat: players[0],
                currentQ: q,
                votes: {},
                ready: [],
                roundId: nextRoundId,
                countdownEnds,
                lobbyReady: {},
                usedQuestions: [...usedQuestions, qIdx],
                lastQuestionCategory: qCategory,
                pendingAttacks: {} // ZurÃ¼cksetzen fÃ¼r neue Runde
            });
            setTimeout(() => {
                updateDoc(doc(db, "lobbies", roomId), { status: 'game', countdownEnds: null });
            }, 3300);
        };
        
        // Starte Spiel nach SchlieÃŸen der Regeln
        // --- OPEN RULES OVERLAY ---
        window.openRulesOverlay = () => {
            const overlay = document.getElementById('rulesOverlay');
            if(overlay) {
                overlay.style.display = 'flex';
            }
        };

        // --- CLOSE RULES OVERLAY ---
        window.closeRulesOverlay = () => {
            const overlay = document.getElementById('rulesOverlay');
            if(overlay) {
                overlay.style.display = 'none';
            }
        };
        
        // --- SHOW ROUND RECAP ---
        function showRoundRecap(data) {
            const overlay = document.getElementById('roundRecapOverlay');
            const content = document.getElementById('recapContent');
            if(!overlay || !content) return;
            
            const players = Object.keys(data.players || {});
            const readyPlayers = data.ready || [];
            const notReadyPlayers = players.filter(p => !readyPlayers.includes(p));
            
            let html = `<div style="text-align:left; margin-bottom:20px;">`;
            html += `<h3 style="color:#ff4500; margin-bottom:15px;">Bereitschaftsstatus:</h3>`;
            
            if(readyPlayers.length > 0) {
                html += `<div style="margin-bottom:15px;"><strong style="color:#4CAF50;">âœ… Bereit (${readyPlayers.length}):</strong><br>`;
                html += readyPlayers.map(p => {
                    const playerData = data.players[p];
                    const playerEmoji = playerData?.emoji || 'ğŸ˜Š';
                    return `  ${playerEmoji} ${p}`;
                }).join('<br>');
                html += `</div>`;
            }
            
            if(notReadyPlayers.length > 0) {
                html += `<div><strong style="color:#ff9800;">â³ Noch nicht bereit (${notReadyPlayers.length}):</strong><br>`;
                html += notReadyPlayers.map(p => {
                    const playerData = data.players[p];
                    const playerEmoji = playerData?.emoji || 'ğŸ˜Š';
                    return `  ${playerEmoji} ${p}`;
                }).join('<br>');
                html += `</div>`;
            }
            
            html += `</div>`;
            content.innerHTML = html;
            overlay.style.display = 'flex';
        }
        
        // --- CLOSE ROUND RECAP ---
        window.closeRoundRecap = () => {
            const overlay = document.getElementById('roundRecapOverlay');
            if(overlay) {
                overlay.style.display = 'none';
            }
        };

        // --- NEXT ROUND ---
        window.nextRound = async () => {
            const maxTemp = globalData?.config?.maxTemp || 100;
            const activePlayers = Object.keys(globalData.players).filter(p => 
                (globalData.players[p].temp || 0) < maxTemp
            );
            
            if(activePlayers.length === 0) {
                // Fallback: Alle sind raus, nimm alle Spieler
                activePlayers.push(...Object.keys(globalData.players));
            }
            
            // PrÃ¼fe nur wÃ¤hrend des Spiels, nicht in der Lobby
            if(globalData?.status === 'game' || globalData?.status === 'result') {
                if(activePlayers.length === 1) {
                    // Nur noch ein Spieler Ã¼brig - Gewinner!
                    if(isHost) {
                        await updateDoc(doc(db, "lobbies", roomId), {
                            status: 'winner',
                            winner: activePlayers[0]
                        });
                    }
                    return;
                }
            }
            
            const curr = globalData.hotseat;
            let nextIdx = activePlayers.indexOf(curr);
            if(nextIdx === -1) nextIdx = 0;
            nextIdx = (nextIdx + 1) % activePlayers.length;
            
            const usedQuestions = globalData.usedQuestions || [];
            const activeCategories = globalData.config?.categories || Object.keys(questionCategories);
            const lastCategory = globalData.lastQuestionCategory || null;
            const { question: q, index: qIdx, category: qCategory } = getRandomUnusedQuestion(usedQuestions, activeCategories, lastCategory);
            const nextRoundId = (globalData?.roundId ?? 0) + 1;
            await applyIceCooling(globalData.players);
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'game',
                hotseat: activePlayers[nextIdx],
                currentQ: q,
                votes: {},
                ready: [],
                roundId: nextRoundId,
                usedQuestions: [...usedQuestions, qIdx],
                roundRecapShown: false,
                lastQuestionCategory: qCategory,
                pendingAttacks: {}, // ZurÃ¼cksetzen fÃ¼r neue Runde
                attackResults: {} // ZurÃ¼cksetzen fÃ¼r neue Runde
            });
        };

        // --- FORCE NEXT ROUND ---
        window.forceNextRound = async () => {
            if(!isHost) return;
            if(!confirm("MÃ¶chtest du wirklich zur nÃ¤chsten Runde springen?")) return;
            await nextRound();
            toggleMenu();
        };

        // --- RESET GAME ---
        window.resetGame = async () => {
            if(!isHost) return;
            if(!confirm("MÃ¶chtest du das Spiel wirklich neustarten? Alle Temperaturen werden zurÃ¼ckgesetzt.")) return;
            
            const pClean = {};
            Object.keys(globalData.players).forEach(p => {
                pClean[p] = {temp: 0, inventory: []};
            });
            
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'lobby', 
                players: pClean, 
                votes: {}, 
                ready: [], 
                log: [],
                hotseat: "",
                roundId: 0,
                lobbyReady: {},
                countdownEnds: null,
                usedQuestions: [],
                pendingAttacks: {},
                attackResults: {}
            });
            toggleMenu();
            document.body.classList.remove('final-mode');
        };

        // --- KILL LOBBY ---
        window.killLobby = async () => {
            if(!isHost) return;
            if(!confirm("Lobby wirklich lÃ¶schen? Alle Spieler werden ausgeworfen und die Lobby ist danach nicht mehr verfÃ¼gbar!")) return;
            const ref = doc(db, "lobbies", roomId);
            await updateDoc(ref, {
                status: 'closed',
                log: arrayUnion(`ğŸ›‘ ${myName} hat die Lobby beendet.`)
            });
            setTimeout(() => deleteDoc(ref), 1200);
        };

        // --- LEAVE LOBBY ---
        window.leaveLobby = () => {
            if(confirm("Lobby wirklich verlassen?")) {
                document.body.classList.remove('final-mode');
                sessionStorage.clear();
                location.reload();
            }
        };
        
        window.shareLobby = async () => {
            if(!roomId || !globalData) {
                showToast("Kein aktiver Raum zum Teilen verfÃ¼gbar.");
                return;
            }
            let text = `ğŸ”¥ Hitzkopf-Code: ${roomId}`;
            text += " â€“ komm in meine Lobby!";
            try {
                if(navigator.share) {
                    await navigator.share({ title: "Hitzkopf Lobby", text, url: location.href });
                    showToast("Link erfolgreich geteilt!");
                } else if(navigator.clipboard) {
                    await navigator.clipboard.writeText(text);
                    showToast("Link kopiert! Teile ihn mit deinen Freunden.");
                } else {
                    prompt("Code kopieren:", text);
                }
            } catch (err) {
                console.warn(err);
                showToast("Teilen wurde abgebrochen.");
            }
        };

        window.rematchGame = async () => {
            if(!globalData) return;
            if(globalData.host !== myName) {
                showToast("Nur der Host kann eine Revanche starten.");
                return;
            }
            if(!confirm("MÃ¶chtest du eine Revanche starten? Alle Temperaturen werden zurÃ¼ckgesetzt.")) return;
            const pClean = {};
            Object.keys(globalData.players).forEach(p => {
                pClean[p] = { temp: 0, inventory: [] };
            });
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'lobby',
                players: pClean,
                votes: {},
                ready: [],
                log: arrayUnion("â™»ï¸ Revanche gestartet! Alle Temperaturen wurden zurÃ¼ckgesetzt."),
                hotseat: "",
                roundId: (globalData.roundId ?? 0) + 1,
                lobbyReady: {},
                countdownEnds: null,
                usedQuestions: [],
                pendingAttacks: {},
                attackResults: {}
            });
            document.body.classList.remove('final-mode');
            showToast("Revanche gestartet! Alle zurÃ¼ck in die Lobby.");
        };

        // --- RENDER HELPERS ---
        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            
            // Anleitung-Button nur auf Start-Screen anzeigen
            const anleitungBtn = document.getElementById('anleitungButton');
            if(anleitungBtn) {
                anleitungBtn.style.display = (id === 'screen-start') ? 'block' : 'none';
            }
            
            // Host-Einstellungen und Join-Panel zurÃ¼cksetzen wenn nicht auf Start-Screen
            if(id !== 'screen-start') {
                const hostSettings = document.getElementById('hostSettings');
                const joinPanel = document.getElementById('joinPanel');
                if(hostSettings) hostSettings.classList.add('hidden');
                if(joinPanel) joinPanel.classList.add('hidden');
            }
        }

        function renderGameOver(loser, players) {
            showScreen('screen-gameover');
            document.body.classList.add('final-mode');
            const nameEl = document.getElementById('lblLoser');
            const captionEl = document.getElementById('lblFinalText');
            const fillEl = document.getElementById('finalThermoFill');
            const emojiEl = document.getElementById('finalEmoji');
            const btnRematch = document.getElementById('btnRematch');
            nameEl.innerText = loser;
            captionEl.innerText = `${loser} hat 100Â°C erreicht â€“ ein echter Hitzkopf! ğŸ”¥`;
            if(emojiEl) emojiEl.innerText = 'ğŸ¥µ';
            if(fillEl) {
                fillEl.style.width = '0%';
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        const temp = Math.min(players[loser]?.temp ?? 120, 120);
                        fillEl.style.width = `${Math.min(temp, 120)}%`;
                    });
                });
            }
            const rankingEl = document.getElementById('finalRanking');
            if(rankingEl) {
                const survivors = Object.keys(players).filter(p => p !== loser)
                    .sort((a,b) => players[a].temp - players[b].temp);
                if(!survivors.length) {
                    rankingEl.innerHTML = `<div class="final-rank-item">Keine weiteren Spieler.</div>`;
                } else {
                    const coolest = survivors[0];
                    rankingEl.innerHTML = survivors.map((p, idx) => `
                        <div class="final-rank-item ${p === coolest ? 'coolest' : ''}">
                            <span>${idx + 1}. ${p}</span>
                            <span>${players[p].temp}Â°C ${p === coolest ? 'ğŸ§Š' : ''}</span>
                        </div>
                    `).join('');
                }
            if(btnRematch) {
                if(isHost) {
                    btnRematch.disabled = false;
                    btnRematch.innerText = "â™»ï¸ Revanche starten";
                } else {
                    btnRematch.disabled = true;
                    btnRematch.innerText = "â³ Host entscheidet...";
                }
            }
            }
        }

        function renderThermos(players, targetId) {
            const div = document.getElementById(targetId);
            if(!div) return;
            
            const order = Object.keys(players).sort((a,b) => players[b].temp - players[a].temp);
            let html = "";
            const newTemps = {};
            order.forEach((p, idx) => {
                const d = players[p];
                const percent = Math.min(d.temp, 100);
                let color = '#0f0';
                if(d.temp >= 80) color = '#ff4500';
                else if(d.temp >= 50) color = '#ff8c00';
                else if(d.temp >= 30) color = '#ffa500';
                
                const inventory = d.inventory?.length > 0 ? 
                    ` <span style="font-size:0.7rem;">ğŸ´${d.inventory.length}</span>` : '';
                const classes = ['thermo-item'];
                const isHotseat = globalData?.hotseat === p;
                if(idx === 0) classes.push('top-hot');
                if(isHotseat) classes.push('is-hotseat');
                if(targetId === 'gridGame' && lastTemps[p] != null && d.temp > lastTemps[p]) {
                    classes.push('shake');
                }
                const playerEmoji = d.emoji || 'ğŸ˜Š';
                const prefix = isHotseat ? 'ğŸ¥µ ' : (idx === 0 ? 'ğŸ”¥ ' : '');
                const nameLabel = `${prefix}${playerEmoji} ${p}${inventory}`;
                
                html += `
                    <div class="${classes.join(' ')}">
                        <div class="thermo-top">
                            <span>${nameLabel}</span>
                            <span>${d.temp}Â°C</span>
                        </div>
                        <div class="thermo-bar">
                            <div class="thermo-fill" style="width:${percent}%; background:${color}"></div>
                        </div>
                    </div>
                `;
                newTemps[p] = d.temp;
            });
            div.innerHTML = html;
            if(targetId === 'gridGame') {
                lastTemps = newTemps;
            }
        }

        function renderLog(log) {
            const el = document.getElementById('divLog');
            if(!el || !log) return;
            
            el.innerHTML = log.slice(-10).reverse().map(l => {
                let className = 'log-entry';
                if(l.includes('ğŸ”¥')) className += ' attack';
                return `<div class="${className}">${l}</div>`;
            }).join('');
            
            // Auto-scroll to top (newest)
            el.scrollTop = 0;
        }

        async function maybeLogRoundSummary(data, truthText, truthKey) {
            if(!isHost) return;
            if(data.roundId == null) return;
            if(loggedRoundResult === data.roundId) return;
            if(!truthKey) return;

            loggedRoundResult = data.roundId;
            const players = Object.keys(data.players).filter(p => p !== data.hotseat);
            const correct = players.filter(p => data.votes[p]?.choice === truthKey);
            const wrong = players.filter(p => !correct.includes(p));
            const entries = [
                `ğŸ§  Wahrheit (${data.hotseat}): ${truthText}`
            ];

            if(correct.length) {
                entries.push(`âœ… Richtige Spieler: ${correct.join(', ')}`);
                if(wrong.length) entries.push(`âŒ Daneben: ${wrong.join(', ')}`);
            } else {
                entries.push('âšª Niemand lag richtig â€“ keine Aktionen in dieser Runde.');
            }

            await updateDoc(doc(db, "lobbies", roomId), {
                log: arrayUnion(...entries)
            });
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            if(!toast) return;
            toast.innerText = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2500);
        }

        function renderMyJokers(targetId, playerData) {
            const container = document.getElementById(targetId);
            if(!container) return;
            const inventory = playerData?.inventory || [];
            const cards = Object.keys(cardInfo);
            container.innerHTML = cards.map(key => {
                const info = cardInfo[key];
                const has = inventory.includes(key);
                return `
                    <div class="joker-chip ${has ? 'has' : ''}">
                        <strong>${info.label}</strong>
                        <span>${info.desc}</span>
                    </div>
                `;
            }).join('');
        }

        async function applyIceCooling(players) {
            if(!players) return;
            const ref = doc(db, "lobbies", roomId);
            const coolValue = globalData?.config?.dmg || 10;
            for(const name of Object.keys(players)) {
                if(players[name].inventory?.includes('card_ice')) {
                    const reduction = Math.min(coolValue, players[name].temp);
                    await updateDoc(ref, {
                        [`players.${name}.temp`]: increment(-reduction),
                        [`players.${name}.inventory`]: arrayRemove('card_ice'),
                        log: arrayUnion(`ğŸ§Š ${name} kÃ¼hlt sich ab (-${reduction}Â°C)`)
                    });
                }
            }
        }

        function findLatestAttackOnMe(log = []) {
            if(!log || !Array.isArray(log)) return null;
            for(let i = log.length - 1; i >= 0; i--) {
                const entry = log[i];
                const match = entry?.match(/ğŸ”¥\s(.+?)\s+greift\s+(.+?)\san\s\(\+(\d+)Â°C\)/);
                if(match && match[2] === myName) {
                    return { attacker: match[1], dmg: parseInt(match[3], 10) || null };
                }
            }
            return null;
        }

        function triggerAttackFeedback(attackers, totalDmg) {
            const body = document.body;
            body.classList.add('viewport-shake');
            setTimeout(() => body.classList.remove('viewport-shake'), 600);

            const alert = document.getElementById('attackAlert');
            if(!alert) return;
            
            // Formatiere Meldung je nach Anzahl der Angreifer
            let message;
            if(Array.isArray(attackers) && attackers.length > 1) {
                const attackerList = attackers.join(' und ');
                message = `ğŸ”¥ ${attackerList} haben dich gemeinsam angegriffen (+${totalDmg}Â°C)`;
            } else {
                const attacker = Array.isArray(attackers) ? attackers[0] : attackers;
                message = `ğŸ”¥ ${attacker} hat dich aufgeheizt (+${totalDmg}Â°C)`;
            }
            
            alert.innerText = message;
            alert.classList.add('show');
            if(attackAlertTimer) clearTimeout(attackAlertTimer);
            attackAlertTimer = setTimeout(() => alert.classList.remove('show'), 3000);
        }
        
        // --- EXECUTE PENDING ATTACKS ---
        async function executePendingAttacks(data) {
            if(!isHost) return;
            const pendingAttacks = data.pendingAttacks || {};
            if(Object.keys(pendingAttacks).length === 0) return;
            
            const ref = doc(db, "lobbies", roomId);
            const players = data.players || {};
            const logEntries = [];
            const tempUpdates = {};
            const attackResults = {}; // FÃ¼r Anzeige bei betroffenen Spielern: { target: { attackers: [], totalDmg: 0 } }
            
            // Verarbeite alle Angriffe
            for(const [target, attacks] of Object.entries(pendingAttacks)) {
                if(!players[target] || attacks.length === 0) continue;
                
                const targetState = players[target];
                const targetHasMirror = targetState.inventory?.includes('card_mirror');
                let totalDmg = 0;
                const attackerNames = [];
                
                // Summiere Schaden und sammle Angreifer
                attacks.forEach(attack => {
                    totalDmg += attack.dmg;
                    attackerNames.push(attack.attacker);
                    
                    // Log-Eintrag fÃ¼r einzelnen Angriff
                    if(attack.hasOil) {
                        logEntries.push(`ğŸ”¥ ${attack.attacker} greift ${target} mit dem Ã–lfass an (+${attack.dmg}Â°C)`);
                    } else {
                        logEntries.push(`ğŸ”¥ ${attack.attacker} greift ${target} an (+${attack.dmg}Â°C)`);
                    }
                });
                
                // Spiegele Angriffe zurÃ¼ck wenn Spiegel vorhanden
                if(targetHasMirror) {
                    await updateDoc(ref, {
                        [`players.${target}.inventory`]: arrayRemove('card_mirror')
                    });
                    
                    // Spiegle an jeden Angreifer zurÃ¼ck
                    attacks.forEach(attack => {
                        if(!tempUpdates[`players.${attack.attacker}.temp`]) {
                            tempUpdates[`players.${attack.attacker}.temp`] = 0;
                        }
                        tempUpdates[`players.${attack.attacker}.temp`] += attack.dmg;
                    });
                    
                    // Sammle alle Angreifer fÃ¼r Log
                    const attackerList = attackerNames.join(' und ');
                    logEntries.push(`ğŸª ${target} spiegelt die Angriffe von ${attackerList} zurÃ¼ck! (+${totalDmg}Â°C)`);
                } else {
                    // Normaler Angriff
                    if(!tempUpdates[`players.${target}.temp`]) {
                        tempUpdates[`players.${target}.temp`] = 0;
                    }
                    tempUpdates[`players.${target}.temp`] += totalDmg;
                    
                    // FÃ¼r Anzeige beim Angegriffenen
                    attackResults[target] = {
                        attackers: attackerNames,
                        totalDmg: totalDmg
                    };
                }
            }
            
            // FÃ¼hre alle Temperatur-Updates aus
            const updateData = { pendingAttacks: {}, log: arrayUnion(...logEntries) };
            for(const [path, dmg] of Object.entries(tempUpdates)) {
                updateData[path] = increment(dmg);
            }
            
            // Speichere Angriffsergebnisse fÃ¼r Anzeige bei betroffenen Spielern
            if(Object.keys(attackResults).length > 0) {
                updateData.attackResults = attackResults;
            }
            
            await updateDoc(ref, updateData);
        }

        function handleCountdownOverlay(data) {
            const overlay = document.getElementById('countdownOverlay');
            if(!overlay) return;
            if(data.status === 'countdown' && data.countdownEnds) {
                countdownTarget = data.countdownEnds;
                overlay.classList.add('show');
                startCountdownTicker();
            } else {
                overlay.classList.remove('show');
                stopCountdownTicker();
            }
        }

        function startCountdownTicker() {
            updateCountdownText();
            if(countdownInterval) clearInterval(countdownInterval);
            countdownInterval = setInterval(updateCountdownText, 250);
        }

        function stopCountdownTicker() {
            if(countdownInterval) clearInterval(countdownInterval);
            countdownInterval = null;
            countdownTarget = null;
        }

        function updateCountdownText() {
            if(!countdownTarget) return;
            const textEl = document.getElementById('countdownText');
            if(!textEl) return;
            const remainingMs = countdownTarget - Date.now();
            const seconds = Math.max(0, Math.ceil(remainingMs / 1000));
            if(seconds > 0) {
                textEl.innerHTML = seconds.toString();
            } else {
                textEl.innerHTML = "Hitz<br>kopf";
            }
        }

        // --- SPECTATOR MODE ---
        function showSpectatorMode() {
            const banner = document.getElementById('spectatorBanner');
            if(!banner) {
                const newBanner = document.createElement('div');
                newBanner.id = 'spectatorBanner';
                newBanner.className = 'spectator-banner';
                newBanner.innerText = 'ğŸ”¥ Du bist ein Hitzkopf! Bis zur nÃ¤chsten Runde bist du leider raus. Zeit abzukÃ¼hlen.';
                document.body.appendChild(newBanner);
            }
            document.body.classList.add('spectator-mode');
        }

        function hideSpectatorMode() {
            const banner = document.getElementById('spectatorBanner');
            if(banner) banner.remove();
            document.body.classList.remove('spectator-mode');
        }

        // --- ELIMINATION ANIMATION ---
        function showEliminationAnimation(playerName, temp) {
            const overlay = document.getElementById('fullscreenAnimation');
            if(!overlay) return;
            
            const emojiEl = document.getElementById('animEmoji');
            const nameEl = document.getElementById('animName');
            const textEl = document.getElementById('animText');
            const thermoEl = document.getElementById('animThermoFill');
            const tempEl = document.getElementById('animTemp');
            
            if(emojiEl) emojiEl.innerText = 'ğŸ¥µ';
            if(nameEl) nameEl.innerText = playerName;
            if(textEl) textEl.innerText = 'ist ein Hitzkopf und fliegt raus! ğŸ”¥';
            if(tempEl) tempEl.innerText = `${temp}Â°C`;
            
            overlay.style.display = 'flex';
            
            // Thermometer animieren
            if(thermoEl) {
                thermoEl.style.width = '0%';
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        thermoEl.style.width = `${Math.min(temp, 120)}%`;
                    });
                });
            }
            
            // Nach 3 Sekunden ausblenden
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 3000);
        }

        // --- RENDER WINNER ---
        function renderWinner(winnerName, players) {
            const nameEl = document.getElementById('winnerName');
            const emojiEl = document.getElementById('winnerEmoji');
            const tempEl = document.getElementById('winnerTemp');
            const thermoEl = document.getElementById('winnerThermoFill');
            const rankingEl = document.getElementById('rankingList');
            
            const winnerData = players[winnerName];
            const winnerEmoji = winnerData?.emoji || 'ğŸ˜';
            
            if(nameEl) nameEl.innerText = winnerName;
            if(emojiEl) emojiEl.innerText = winnerEmoji;
            const temp = winnerData?.temp || 0;
            if(tempEl) tempEl.innerText = `${temp}Â°C`;
            
            // Thermometer animieren
            if(thermoEl) {
                thermoEl.style.width = '0%';
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        thermoEl.style.width = `${Math.min((temp / 100) * 100, 100)}%`;
                    });
                });
            }
            
            // Ranking: Andere Spieler nach Reihenfolge des Rausfliegens
            const maxTemp = globalData?.config?.maxTemp || 100;
            const eliminated = Object.keys(players)
                .filter(p => p !== winnerName && (players[p].temp || 0) >= maxTemp)
                .sort((a, b) => (players[b].temp || 0) - (players[a].temp || 0)); // HÃ¶chste zuerst (zuletzt rausgeflogen)
            
            if(rankingEl && eliminated.length > 0) {
                rankingEl.innerHTML = eliminated.map((p, idx) => {
                    const playerData = players[p];
                    const playerEmoji = playerData?.emoji || 'ğŸ¥µ';
                    const playerTemp = playerData?.temp || 0;
                    return `
                        <div style="padding:12px; margin-bottom:8px; background:rgba(255,69,0,0.1); border:1px solid rgba(255,69,0,0.3); border-radius:10px; display:flex; justify-content:space-between; align-items:center;">
                            <div>
                                <span style="font-size:1.5rem; margin-right:10px;">${playerEmoji}</span>
                                <span style="font-size:1.1rem; font-weight:bold; color:#ff8c00;">${p}</span>
                            </div>
                            <div style="font-size:1rem; color:#ff4500; font-weight:bold;">${playerTemp}Â°C</div>
                        </div>
                    `;
                }).join('');
            } else if(rankingEl) {
                rankingEl.innerHTML = '<div style="text-align:center; color:#888; padding:20px;">Keine weiteren Spieler</div>';
            }
            
            // Konfetti starten
            startConfetti();
        }

        // --- CONFETTI ---
        function startConfetti() {
            const container = document.getElementById('confetti-container');
            if(!container) return;
            
            const colors = ['#ffd700', '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7'];
            
            for(let i = 0; i < 100; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
                    confetti.style.animationDelay = Math.random() * 0.5 + 's';
                    container.appendChild(confetti);
                    
                    setTimeout(() => confetti.remove(), 5000);
                }, i * 20);
            }
        }

        // --- RENDER VOTING ---
        function renderVoting(data) {
            const votingStatus = document.getElementById('votingStatus');
            const votingResults = document.getElementById('votingResults');
            const btnRematch = document.getElementById('btnVoteRematch');
            const btnLeave = document.getElementById('btnVoteLeave');
            
            const votes = data.rematchVotes || {};
            const players = Object.keys(data.players);
            const activePlayers = players.filter(p => (data.players[p].temp || 0) < (data.config?.maxTemp || 100));
            
            const rematchCount = activePlayers.filter(p => votes[p] === true).length;
            const leaveCount = activePlayers.filter(p => votes[p] === false).length;
            const totalVotes = rematchCount + leaveCount;
            
            if(votingStatus) {
                votingStatus.innerText = `Abgestimmt: ${totalVotes}/${activePlayers.length}`;
            }
            
            if(votingResults) {
                votingResults.innerHTML = `
                    <div style="margin-bottom:10px;">âœ… Nochmal spielen: ${rematchCount}</div>
                    <div>ğŸšª Verlassen: ${leaveCount}</div>
                `;
            }
            
            // Buttons deaktivieren wenn bereits abgestimmt
            if(votes[myName] !== undefined) {
                if(btnRematch) btnRematch.disabled = true;
                if(btnLeave) btnLeave.disabled = true;
                if(votes[myName]) {
                    if(btnRematch) btnRematch.innerText = 'âœ… GewÃ¤hlt';
                    if(btnLeave) btnLeave.innerText = 'ğŸšª Verlassen';
                } else {
                    if(btnRematch) btnRematch.innerText = 'âœ… Nochmal spielen';
                    if(btnLeave) btnLeave.innerText = 'ğŸšª GewÃ¤hlt';
                }
            } else {
                if(btnRematch) btnRematch.disabled = false;
                if(btnLeave) btnLeave.disabled = false;
            }
            
            // Host kann Spiel starten wenn alle fÃ¼r Rematch gestimmt haben
            if(isHost && totalVotes === activePlayers.length && rematchCount === activePlayers.length) {
                const startBtn = document.createElement('button');
                startBtn.className = 'btn-primary';
                startBtn.style.cssText = 'width:100%; margin-top:20px; padding:15px; font-size:1.2rem;';
                startBtn.innerText = 'ğŸ® Neue Runde starten';
                startBtn.onclick = startRematchGame;
                if(!document.getElementById('btnStartRematch')) {
                    startBtn.id = 'btnStartRematch';
                    const votingCard = document.getElementById('screen-voting');
                    if(votingCard) votingCard.appendChild(startBtn);
                }
            }
        }

        // --- VOTE REMATCH ---
        window.voteRematch = async (wantRematch) => {
            await updateDoc(doc(db, "lobbies", roomId), {
                [`rematchVotes.${myName}`]: wantRematch
            });
        };

        // --- START REMATCH ---
        window.startRematchGame = async () => {
            if(!isHost) return;
            const pClean = {};
            Object.keys(globalData.players).forEach(p => {
                const startTemp = globalData.config?.startTemp || 0;
                pClean[p] = { temp: startTemp, inventory: [], gender: globalData.players[p].gender || 'divers' };
            });
            
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'lobby',
                players: pClean,
                votes: {},
                ready: [],
                log: arrayUnion("â™»ï¸ Neue Runde gestartet! Alle Temperaturen wurden zurÃ¼ckgesetzt."),
                hotseat: "",
                roundId: 0,
                lobbyReady: {},
                countdownEnds: null,
                usedQuestions: [],
                rematchVotes: {},
                eliminatedShown: [],
                winner: null
            });
            document.body.classList.remove('final-mode');
            showToast("Neue Runde gestartet!");
        };

        // --- SHOW ATTACK ANIMATION ---
        async function showAttackAnimation(targetName, attackerName, dmg, newTemp) {
            const overlay = document.getElementById('fullscreenAnimation');
            if(!overlay) return;
            
            const emojiEl = document.getElementById('animEmoji');
            const nameEl = document.getElementById('animName');
            const textEl = document.getElementById('animText');
            const thermoEl = document.getElementById('animThermoFill');
            const tempEl = document.getElementById('animTemp');
            
            if(emojiEl) emojiEl.innerText = 'ğŸ”¥';
            if(nameEl) nameEl.innerText = targetName;
            if(textEl) textEl.innerText = `${attackerName} hat ${targetName} aufgeheizt (+${dmg}Â°C)`;
            if(tempEl) tempEl.innerText = `${newTemp}Â°C`;
            
            overlay.style.display = 'flex';
            
            // Thermometer animieren
            if(thermoEl) {
                thermoEl.style.width = '0%';
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        thermoEl.style.width = `${Math.min((newTemp / 100) * 100, 100)}%`;
                    });
                });
            }
            
            // Nach 3 Sekunden ausblenden
            await sleep(3000);
            overlay.style.display = 'none';
        }

        // --- SHOW JOKER ANIMATION ---
        async function showJokerAnimation(playerName, cardName) {
            const overlay = document.getElementById('fullscreenAnimation');
            if(!overlay) return;
            
            const emojiEl = document.getElementById('animEmoji');
            const nameEl = document.getElementById('animName');
            const textEl = document.getElementById('animText');
            const thermoEl = document.getElementById('animThermoFill');
            const tempEl = document.getElementById('animTemp');
            
            const cardInfo = {
                card_oil: { emoji: 'ğŸ›¢ï¸', name: 'Ã–lfass' },
                card_mirror: { emoji: 'ğŸª', name: 'Spiegel' },
                card_ice: { emoji: 'ğŸ§Š', name: 'EiswÃ¼rfel' }
            };
            
            const info = cardInfo[cardName] || { emoji: 'ğŸƒ', name: 'Joker' };
            
            if(emojiEl) emojiEl.innerText = info.emoji;
            if(nameEl) nameEl.innerText = playerName;
            if(textEl) textEl.innerText = `hat einen Joker gezogen: ${info.name} - Aufgepasst! ğŸƒ`;
            if(tempEl) tempEl.innerText = '';
            
            overlay.style.display = 'flex';
            
            // Thermometer ausblenden
            if(thermoEl) thermoEl.style.width = '0%';
            
            // Nach 3 Sekunden ausblenden
            await sleep(3000);
            overlay.style.display = 'none';
        }

    </script>
</body>
</html>
