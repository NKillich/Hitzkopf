<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hitzkopf ğŸ”¥ Webversion 2</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            color: #ffffff; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            text-align: center; 
            padding: 15px; 
            padding-bottom: 80px;
            min-height: 100vh;
        }
        h1 { 
            color: #ff4500; 
            margin: 0 0 15px 0; 
            text-shadow: 0 0 15px rgba(255, 69, 0, 0.7); 
            font-size: 2.2rem; 
            font-weight: 900;
        }
        
        .screen { display: none; animation: fadeIn 0.4s ease-out; }
        .screen.active { display: block; }
        
        .card { 
            background: linear-gradient(145deg, #1e1e1e, #252525);
            padding: 25px; 
            border-radius: 20px; 
            max-width: 480px; 
            margin: 0 auto 20px auto; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.8); 
            border: 1px solid #333;
        }
        
        input, select { 
            width: 100%; 
            padding: 15px; 
            margin: 10px 0; 
            border-radius: 10px; 
            border: 2px solid #444; 
            background: #2c2c2c; 
            color: white; 
            font-size: 16px; 
            text-align: center;
            transition: border-color 0.3s, background 0.3s;
        }
        input:focus, select:focus { 
            outline: none; 
            border-color: #ff4500; 
            background: #333;
        }
        
        button { 
            width: 100%; 
            padding: 16px; 
            margin: 10px 0; 
            border: none; 
            border-radius: 12px; 
            font-size: 18px; 
            font-weight: bold; 
            cursor: pointer; 
            transition: transform 0.15s, box-shadow 0.3s, opacity 0.3s;
        }
        button:hover:not(:disabled) { 
            transform: translateY(-2px); 
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }
        button:active:not(:disabled) { transform: scale(0.97); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-primary { 
            background: linear-gradient(135deg, #ff4500, #ff8c00); 
            color: white;
            box-shadow: 0 4px 15px rgba(255, 69, 0, 0.4);
        }
        .btn-secondary { background: linear-gradient(135deg, #333, #444); color: #fff; }
        .btn-danger { 
            background: linear-gradient(135deg, #dc3545, #c82333); 
            color: white; 
            font-size: 0.95rem; 
            padding: 12px;
        }
        .btn-ready { 
            background: linear-gradient(135deg, #28a745, #20c997); 
            color: white; 
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }
        .btn-ready:disabled { 
            background: #1e5e28; 
            opacity: 0.5; 
            cursor: not-allowed;
            box-shadow: none;
        }

        .thermo-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            gap: 12px; 
            margin-bottom: 20px;
        }
        .thermo-item { 
            background: linear-gradient(145deg, #1a1a1a, #252525);
            padding: 12px; 
            border-radius: 12px; 
            text-align: left; 
            border: 1px solid #333;
            transition: transform 0.2s;
        }
        .thermo-item:hover { transform: translateY(-3px); }
        .thermo-item.top-hot { border-color: #ff8c00; box-shadow: 0 0 12px rgba(255,140,0,0.4); }
        .thermo-item.is-hotseat { border-color: #ff4d4d; box-shadow: 0 0 15px rgba(255,77,77,0.6); }
        .thermo-top { 
            display: flex; 
            justify-content: space-between; 
            font-size: 0.9rem; 
            font-weight: bold; 
            margin-bottom: 8px;
            color: #fff;
        }
        .thermo-bar { 
            height: 8px; 
            background: #333; 
            border-radius: 4px; 
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }
        .thermo-fill { 
            height: 100%; 
            width: 0%; 
            transition: width 0.6s ease-out;
            box-shadow: 0 0 10px currentColor;
        }
        
        .option-row { display: flex; gap: 12px; margin-top: 20px; }
        .btn-option { 
            flex: 1; 
            background: linear-gradient(145deg, #2a2a2a, #1f1f1f);
            border: 3px solid #444; 
            padding: 30px 10px; 
            font-size: 1.2rem; 
            color: #eee;
            transition: all 0.3s;
        }
        .btn-option:hover { 
            border-color: #666;
            background: linear-gradient(145deg, #333, #2a2a2a);
        }
        .btn-option.selected { 
            border-color: #ff4500; 
            background: linear-gradient(145deg, #3e2e2e, #2a1a1a);
            color: #ff4500;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.5);
        }

        .log-box { 
            background: #0a0a0a; 
            border: 1px solid #333; 
            border-radius: 10px; 
            height: 160px; 
            overflow-y: auto; 
            padding: 12px; 
            margin-top: 15px; 
            text-align: left; 
            font-size: 0.85rem; 
            display: flex; 
            flex-direction: column; 
            gap: 8px;
        }
        .log-box::-webkit-scrollbar { width: 6px; }
        .log-box::-webkit-scrollbar-track { background: #1a1a1a; }
        .log-box::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        
        .log-entry { 
            padding: 8px 10px; 
            border-radius: 6px; 
            background: #1f1f1f; 
            border-left: 3px solid #555;
            animation: slideIn 0.3s ease-out;
        }
        .log-entry.attack { border-left-color: #dc3545; }
        
        .menu-btn { 
            position: fixed; 
            top: 15px; 
            right: 15px; 
            width: 50px; 
            height: 50px; 
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border-radius: 50%; 
            border: 2px solid #444; 
            z-index: 2000; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            font-size: 1.4rem;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
        }
        .menu-btn:hover { transform: rotate(90deg); border-color: #ff4500; }
        
        .admin-drawer { 
            position: fixed; 
            top: 0; 
            right: -280px; 
            width: 280px; 
            height: 100%; 
            background: linear-gradient(180deg, #111, #0a0a0a);
            border-left: 2px solid #ff4500; 
            z-index: 2001; 
            transition: right 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            padding: 25px; 
            text-align: left; 
            box-shadow: -8px 0 32px rgba(0,0,0,0.9);
            overflow-y: auto;
        }
        .admin-drawer.open { right: 0; }
        
        .overlay { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0,0,0,0.85); 
            z-index: 1999; 
            display: none;
            backdrop-filter: blur(4px);
        }
        .overlay.open { display: block; }

        .hidden { display: none !important; }

        .card-select-btn {
            font-size: 1rem;
            padding: 15px;
            background: linear-gradient(145deg, #2a2a2a, #1f1f1f);
            border: 2px solid #444;
            border-radius: 12px;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            gap: 6px;
            color: #fff;
        }
        .card-select-btn strong { font-size: 1.2rem; }
        .card-select-btn span { font-size: 0.85rem; color: #ddd; }
        .card-select-btn:hover { border-color: #ff8c00; transform: translateY(-2px); }

        .start-actions { display:flex; gap:12px; margin-top:15px; }
        .start-actions button { flex:1; }
        .start-panel { margin-top:15px; padding:15px; border:1px solid #2f2f2f; border-radius:12px; background:rgba(0,0,0,0.2); }
        .share-btn { margin-top:15px; background:linear-gradient(135deg,#1f1f1f,#2e2e2e); color:#fff; font-size:0.95rem; }
        .toast { position:fixed; bottom:-80px; left:50%; transform:translateX(-50%); background:#222; padding:12px 20px; border-radius:20px; color:#fff; box-shadow:0 10px 30px rgba(0,0,0,0.5); transition:bottom 0.3s; z-index:3000; }
        .toast.show { bottom:25px; }
        .attack-alert {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-120%);
            background: #ff4500;
            border: 1px solid #ff9a6b;
            color: #fff;
            padding: 12px 24px;
            border-radius: 999px;
            font-size: 0.95rem;
            font-weight: 600;
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
            transition: transform 0.4s ease, opacity 0.4s ease;
            opacity: 0;
            z-index: 2500;
        }
        .attack-alert.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        body.viewport-shake {
            animation: screenShake 0.6s cubic-bezier(.36,.07,.19,.97);
        }
        @keyframes screenShake {
            10%, 90% { transform: translate3d(-4px, 0, 0); }
            20%, 80% { transform: translate3d(5px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-8px, 0, 0); }
            40%, 60% { transform: translate3d(8px, 0, 0); }
            100% { transform: translate3d(0,0,0); }
        }
        .joker-panel {
            margin-top: 20px;
            background: rgba(255,255,255,0.03);
            border: 1px solid #2e2e2e;
            border-radius: 12px;
            padding: 12px;
        }
        .joker-panel h4 {
            margin-bottom: 8px;
            font-size: 0.95rem;
            color: #ffa45c;
        }
        .joker-strip {
            display: flex;
            gap: 8px;
            justify-content: space-between;
        }
        .joker-chip {
            flex: 1;
            border: 1px dashed #555;
            border-radius: 12px;
            padding: 10px;
            font-size: 0.85rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            color: #888;
            opacity: 0.4;
        }
        .joker-chip strong {
            font-size: 1.2rem;
        }
        .joker-chip.has {
            border-style: solid;
            border-color: #ff8c00;
            color: #fff;
            opacity: 1;
            box-shadow: 0 6px 16px rgba(255,140,0,0.25);
        }
        .joker-chip span {
            font-size: 0.75rem;
            text-align: center;
            color: inherit;
        }
        .countdown-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 4000;
        }
        .countdown-overlay.show { display: flex; }
        .countdown-text {
            font-size: 6rem;
            font-weight: 900;
            color: #ff3b00;
            text-shadow: 0 0 30px rgba(255,59,0,0.7);
            animation: pulse 1s infinite;
        }
        .countdown-sub {
            margin-top: 10px;
            font-size: 1.2rem;
            color: #fff;
            letter-spacing: 0.2rem;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        body.final-mode {
            animation: finalPulse 1.2s infinite;
            background: radial-gradient(circle at center, rgba(255,69,0,0.15), #0a0a0a 70%);
        }
        @keyframes finalPulse {
            0%,100% { background-color: #1a0a0a; }
            50% { background-color: #2d0505; }
        }
        .final-card {
            background: radial-gradient(circle at top, rgba(255,69,0,0.2), #120202);
            border: 2px solid #ff3b00;
        }
        .final-hero {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        .final-emoji {
            font-size: 5rem;
            animation: sweatShake 0.9s infinite;
        }
        @keyframes sweatShake {
            0%,100% { transform: translateY(0); }
            25% { transform: translateY(-4px); }
            50% { transform: translateY(3px); }
            75% { transform: translateY(-2px); }
        }
        .final-name {
            font-size: 2rem;
            font-weight: 800;
            color: #ffae00;
            text-shadow: 0 0 18px rgba(255,174,0,0.6);
        }
        .final-caption {
            margin-top: 8px;
            font-size: 1rem;
            color: #ffd6c1;
        }
        .final-thermo {
            margin: 20px auto;
            width: 80%;
        }
        .final-thermo-track {
            height: 20px;
            border-radius: 10px;
            background: #280000;
            overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.7);
        }
        .final-thermo-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ffae00, #ff0000);
            box-shadow: 0 0 20px rgba(255,0,0,0.7);
            transition: width 1.2s ease-out;
        }
        .final-ranking {
            margin-top: 25px;
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .final-rank-item {
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid #2d2d2d;
            display: flex;
            justify-content: space-between;
            background: rgba(0,0,0,0.35);
            font-size: 0.95rem;
        }
        .final-rank-item.coolest {
            border-color: #00d1ff;
            box-shadow: 0 0 15px rgba(0,209,255,0.3);
            color: #c8f4ff;
        }
        .final-rank-item span {
            color: #aaa;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ffd700;
            position: absolute;
            animation: confetti-fall linear forwards;
        }
        @keyframes confetti-fall {
            to {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        .spectator-mode {
            opacity: 0.6;
            pointer-events: none;
        }
        .spectator-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #ff4500, #ff8c00);
            color: white;
            padding: 15px;
            text-align: center;
            font-weight: bold;
            z-index: 3000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        @keyframes fadeIn { 
            from { opacity: 0; transform: translateY(20px); } 
            to { opacity: 1; transform: translateY(0); } 
        }
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }
        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 
            10%, 90% { transform: translate3d(-2px, 0, 0); } 
            20%, 80% { transform: translate3d(3px, 0, 0); } 
            30%, 50%, 70% { transform: translate3d(-5px, 0, 0); } 
            40%, 60% { transform: translate3d(5px, 0, 0); } 
        }
    </style>
</head>
<body>
    <div class="menu-btn" onclick="toggleMenu()">âš™ï¸</div>
    <div id="attackAlert" class="attack-alert"></div>
    <div id="countdownOverlay" class="countdown-overlay">
        <div id="countdownText" class="countdown-text" style="font-size:4rem; line-height:1.2;">Hitz<br>kopf</div>
        <div class="countdown-sub">Bereit machen...</div>
    </div>
    <div id="rulesOverlay" class="countdown-overlay" style="display:none;">
        <div style="background:linear-gradient(145deg, #1e1e1e, #252525); padding:30px; border-radius:20px; max-width:500px; margin:20px; border:2px solid #ff4500; box-shadow:0 8px 32px rgba(0,0,0,0.8);">
            <h2 style="color:#ff4500; margin-bottom:20px; font-size:1.8rem;">ğŸ“– Spielregeln</h2>
            <div style="text-align:left; font-size:1rem; line-height:1.6; color:#fff; margin-bottom:25px;">
                <p style="margin-bottom:12px;">ğŸ¯ <strong>Ziel:</strong> Errate die Antworten deiner Freunde und bringe sie zum kochen!</p>
                <p style="margin-bottom:12px;">ğŸ”¥ <strong>Verlierer:</strong> Wer als erstes 100Â° erreicht, fliegt raus.</p>
                <p style="margin-bottom:12px;">ğŸ§Š <strong>Gewinner:</strong> Bewahrst du einen kÃ¼hlen Kopf, entscheidest du das Spiel fÃ¼r dich.</p>
                <p style="margin-bottom:0;">ğŸ’¡ <strong>Tipp:</strong> Bei richtigem Raten kannst du Gegner aufheizen oder Joker ziehen!</p>
            </div>
            <button onclick="closeRulesOverlay()" class="btn-primary" style="width:100%; padding:15px; font-size:1.1rem;">Verstanden, los geht's! ğŸš€</button>
        </div>
    </div>
    <div class="overlay" id="menuOverlay" onclick="toggleMenu()"></div>
    <div class="admin-drawer" id="adminDrawer">
        <h3 style="color:#ff4500; border-bottom:2px solid #333; padding-bottom:12px; margin-bottom:15px;">âš™ï¸ MenÃ¼</h3>
        
        <div id="hostControls" style="display:none;">
            <p style="font-size:0.75rem; color:#888; margin-bottom:8px; text-transform:uppercase;">Host-Steuerung:</p>
            <button style="padding:12px; font-size:0.85rem; margin:8px 0; background:#333; border-radius:8px;" onclick="forceNextRound()">â© Runde erzwingen</button>
            <button style="padding:12px; font-size:0.85rem; margin:8px 0; background:#550000; border-radius:8px;" onclick="resetGame()">ğŸ”„ Spiel neustarten</button>
            <button style="padding:12px; font-size:0.85rem; margin:8px 0; background:#880000; border-radius:8px;" onclick="killLobby()">ğŸ§¨ Lobby lÃ¶schen</button>
            <hr style="border:none; border-top:1px solid #333; margin:20px 0;">
        </div>

        <button style="padding:12px; font-size:0.85rem; margin:8px 0; background:#444; border-radius:8px;" onclick="leaveLobby()">ğŸ‘‹ Lobby verlassen</button>
    </div>

    <h1>ğŸ”¥ Hitzkopf</h1>

    <!-- START SCREEN -->
    <div id="screen-start" class="screen active card">
        <h3 style="margin-bottom:15px; color:#ff8c00;">Wie heiÃŸt du?</h3>
        <input type="text" id="inpName" placeholder="Dein Name" maxlength="20" autocomplete="off">
        <label style="display:block; font-size:0.85rem; color:#aaa; margin-top:15px; margin-bottom:8px; font-weight:500;">WÃ¤hle dein Emoji:</label>
        <div style="position:relative; margin-bottom:15px;">
            <div id="emojiCarousel" style="display:flex; align-items:center; gap:10px; overflow:hidden; position:relative;">
                <button id="emojiPrev" onclick="changeEmoji(-1)" style="background:transparent; border:none; color:#fff; font-size:2rem; cursor:pointer; flex-shrink:0; padding:5px;">â¬…ï¸</button>
                <div id="emojiDisplay" style="flex:1; text-align:center; font-size:3rem; min-height:60px; display:flex; align-items:center; justify-content:center;">ğŸ˜Š</div>
                <button id="emojiNext" onclick="changeEmoji(1)" style="background:transparent; border:none; color:#fff; font-size:2rem; cursor:pointer; flex-shrink:0; padding:5px;">â¡ï¸</button>
            </div>
            <input type="hidden" id="inpEmoji" value="ğŸ˜Š">
        </div>
        
        <div class="start-actions">
            <button class="btn-primary" onclick="openHostSettings()">ğŸ® Spiel erstellen</button>
            <button class="btn-secondary" onclick="openJoinPanel()">ğŸšª Spiel beitreten</button>
        </div>

        <div id="hostSettings" class="start-panel hidden">
            <p style="font-size:0.85rem; color:#ccc; margin-bottom:8px; font-weight:600;">âš™ï¸ Host-Einstellungen</p>
            <label style="display:block; font-size:0.85rem; color:#aaa; margin-bottom:5px; font-weight:500;">Schaden pro Angriff:</label>
            <select id="inpDmg">
                <option value="10">10Â°C (Normal) âš–ï¸</option>
                <option value="20">20Â°C (Intensiv) ğŸ”¥</option>
                <option value="60">60Â°C (Speed-Modus) âš¡</option>
            </select>
            <label style="display:block; font-size:0.85rem; color:#aaa; margin-top:12px; margin-bottom:5px; font-weight:500;">Spielgeschwindigkeit (Multiplikator):</label>
            <select id="inpSpeed">
                <option value="1.0">1.0x (Normal) â±ï¸</option>
                <option value="0.5">0.5x (Langsam) ğŸŒ</option>
                <option value="1.5">1.5x (Schnell) âš¡</option>
                <option value="2.0">2.0x (Sehr schnell) ğŸš€</option>
            </select>
            <label style="display:block; font-size:0.85rem; color:#aaa; margin-top:12px; margin-bottom:5px; font-weight:500;">Starttemperatur:</label>
            <select id="inpStartTemp">
                <option value="0">0Â°C (Standard) â„ï¸</option>
                <option value="10">10Â°C (Warm starten) ğŸ”¥</option>
                <option value="20">20Â°C (HeiÃŸ starten) ğŸŒ¡ï¸</option>
            </select>
            <label style="display:block; font-size:0.85rem; color:#aaa; margin-top:12px; margin-bottom:5px; font-weight:500;">Maximale Temperatur:</label>
            <select id="inpMaxTemp">
                <option value="100">100Â°C (Standard) ğŸ”¥</option>
                <option value="80">80Â°C (KÃ¼rzer) âš¡</option>
                <option value="120">120Â°C (LÃ¤nger) ğŸ•</option>
            </select>
            <button class="btn-primary" onclick="createGame()" style="margin-top:15px;">ğŸ® Spiel erstellen</button>
        </div>

        <div id="joinPanel" class="start-panel hidden">
            <p style="font-size:0.85rem; color:#ccc; margin-bottom:8px; font-weight:600;">ğŸ¤ Lobby beitreten</p>
            <input type="text" id="inpCode" placeholder="Raum-Code" style="text-transform:uppercase;" maxlength="6" autocomplete="off" oninput="this.value = this.value.toUpperCase();">
            <button class="btn-secondary" onclick="joinGame()">ğŸšª Beitreten</button>
        </div>
    </div>

    <!-- LOBBY SCREEN -->
    <div id="screen-lobby" class="screen card">
        <p style="color:#aaa; margin-bottom:8px; font-size:0.9rem;">Raum-Code:</p>
        <div id="lblCode" style="font-size:3.5rem; color:#ff8c00; font-weight:900; line-height:1; letter-spacing:8px;">...</div>
        <div id="lobbyList" style="margin:25px 0; font-weight:bold; font-size:1.15rem; color:#fff;"></div>
        <div id="lobbyReadyList" style="font-size:0.9rem; color:#aaa; margin-bottom:15px;"></div>
        <button id="btnLobbyReady" class="btn-secondary" onclick="toggleLobbyReady()">âœ… Bereit</button>
        <div id="lobbyReadyStatus" style="font-size:0.85rem; color:#777; margin-top:5px;"></div>
        <button id="btnHostStart" class="btn-primary" style="display:none;" onclick="startCountdown()">ğŸ”¥ Spiel starten</button>
        <button id="btnShare" class="share-btn" style="display:none;" onclick="shareLobby()">ğŸ“¤ Link teilen</button>
        <p id="lblWait" style="color:#666; font-size:0.9rem;">â³ Warte auf Host...</p>
    </div>

    <!-- GAME SCREEN -->
    <div id="screen-game" class="screen card">
        <div id="gridGame" class="thermo-grid"></div>
        <hr style="border-color:#333; margin:15px 0;">
        
        <div style="margin-bottom:15px;">
            <span style="font-size:2rem;">ğŸ¥µ</span>
            <div id="lblHotseat" style="font-weight:bold; font-size:1.3rem; color:#ff4500;">...</div>
            <p id="lblHotseatSub" style="font-size:0.85rem; color:#aaa; margin-top:4px;"></p>
        </div>
        
        <h3 id="lblQuestion" style="margin:20px 0; min-height:60px; display:flex; align-items:center; justify-content:center;">Lade Frage...</h3>

        <div class="option-row" id="optionRow" style="margin-top:15px;">
            <button id="btnA" class="btn-option" onclick="vote('A')">A</button>
            <button id="btnB" class="btn-option" onclick="vote('B')">B</button>
        </div>

        <button id="btnLock" class="btn-primary" style="margin-top:20px;" onclick="submitVote()">ğŸ”’ Antwort absenden</button>
        <div id="lblVoteStatus" style="font-size:0.8rem; color:#888; margin-top:10px;"></div>
        <div class="joker-panel">
            <h4>Deine Joker</h4>
            <div id="myJokerListGame" class="joker-strip"></div>
        </div>
    </div>

    <!-- RESULT SCREEN -->
    <div id="screen-result" class="screen card">
        <div id="gridResult" class="thermo-grid"></div>
        
        <h3>Die Wahrheit: <span id="lblTruth" style="color:#fff;">?</span></h3>
        <h2 id="lblResultStatus" style="margin:10px 0;">...</h2>

        <div id="boxReward" style="display:none; background:#2a3a1a; padding:15px; border-radius:10px; margin-bottom:15px; border:2px solid #4a6a2a;">
            <h4 style="margin:0 0 12px 0; color:#8fef8f;">ğŸ Belohnung wÃ¤hlen:</h4>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <button onclick="chooseReward('attack')" style="background:linear-gradient(135deg, #dc3545, #c82333); color:white; padding:20px; border-radius:10px; border:none; font-size:1.1rem; font-weight:bold; cursor:pointer; transition:transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ğŸ”´ Gegner aufheizen
                </button>
                <button onclick="chooseReward('invest')" style="background:linear-gradient(135deg, #1a2a3a, #2a3a4a); color:white; padding:20px; border-radius:10px; border:none; font-size:1.1rem; font-weight:bold; cursor:pointer; transition:transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ğŸƒ Joker ziehen
                </button>
            </div>
        </div>

        <div id="boxAttack" style="display:none; background:#3a1a1a; padding:10px; border-radius:10px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0;">ğŸ”¥ Wen angreifen?</h4>
            <div id="divTargets" style="display:grid; grid-template-columns:1fr 1fr; gap:5px;"></div>
            <div style="display:flex; gap:5px; margin-top:10px;">
                <button style="flex:1; background:transparent; border:1px solid #666; color:#aaa; font-size:0.85rem; padding:8px;" onclick="goBackToReward()">â† ZurÃ¼ck</button>
                <button style="flex:1; background:transparent; border:1px solid #666; color:#aaa; font-size:0.85rem; padding:8px;" onclick="skipAttack()">Angriff Ã¼berspringen</button>
            </div>
        </div>

        <div id="boxShop" style="display:none; background:#1a2a3a; padding:10px; border-radius:10px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0;">ğŸƒ Joker-Karte wÃ¤hlen:</h4>
            <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px;">
                <button class="card-select-btn" onclick="takeCard('card_oil')">
                    <strong>ğŸ›¢ï¸ Ã–lfass</strong>
                    <span>Verdoppelt deinen nÃ¤chsten Angriff.</span>
                </button>
                <button class="card-select-btn" onclick="takeCard('card_mirror')">
                    <strong>ğŸª Spiegel</strong>
                    <span>Der nÃ¤chste Angriff prallt zurÃ¼ck.</span>
                </button>
                <button class="card-select-btn" onclick="takeCard('card_ice')">
                    <strong>ğŸ§Š EiswÃ¼rfel</strong>
                    <span>KÃ¼hlt dich in der nÃ¤chsten Runde automatisch ab.</span>
                </button>
            </div>
            <button style="width:100%; background:transparent; border:1px solid #666; color:#aaa; font-size:0.85rem; margin-top:10px; padding:8px;" onclick="goBackToReward()">â† ZurÃ¼ck</button>
        </div>

        <div style="text-align:left; font-size:0.7rem; color:#666; margin-bottom:5px;">ğŸ“‹ Spielverlauf:</div>
        <div id="divLog" class="log-box"></div>

        <button id="btnReady" class="btn-ready" onclick="setReady()">ğŸ‘ Bereit</button>
        <div id="lblReady" style="font-size:0.8rem; color:#666; margin-top:5px;"></div>
        <div class="joker-panel" style="margin-top:20px;">
            <h4>Deine Joker</h4>
            <div id="myJokerListResult" class="joker-strip"></div>
        </div>
    </div>

    <!-- FULLSCREEN ANIMATION OVERLAY -->
    <div id="fullscreenAnimation" class="countdown-overlay" style="display:none;">
        <div style="background:linear-gradient(145deg, #1e1e1e, #252525); padding:40px; border-radius:20px; max-width:600px; margin:20px; border:2px solid #ff4500; box-shadow:0 8px 32px rgba(0,0,0,0.8); text-align:center;">
            <div id="animEmoji" style="font-size:5rem; margin-bottom:20px; animation:sweatShake 0.9s infinite;">ğŸ¥µ</div>
            <div id="animName" style="font-size:2.5rem; font-weight:800; color:#ff4500; margin-bottom:15px; text-shadow:0 0 18px rgba(255,69,0,0.6);">...</div>
            <div id="animText" style="font-size:1.2rem; color:#fff; margin-bottom:25px;">...</div>
            <div style="width:80%; margin:0 auto 20px auto;">
                <div style="height:25px; border-radius:12px; background:#280000; overflow:hidden; box-shadow:inset 0 0 10px rgba(0,0,0,0.7);">
                    <div id="animThermoFill" style="height:100%; width:0%; background:linear-gradient(90deg, #ffae00, #ff0000); box-shadow:0 0 20px rgba(255,0,0,0.7); transition:width 1.2s ease-out;"></div>
                </div>
                <div id="animTemp" style="font-size:1.5rem; font-weight:bold; color:#ff4500; margin-top:10px;">0Â°C</div>
            </div>
            <div id="animCounter" style="font-size:0.9rem; color:#888; margin-top:15px; display:none;">Angriff 1 von 3</div>
        </div>
    </div>

    <!-- ROUND RECAP OVERLAY -->
    <div id="roundRecapOverlay" class="countdown-overlay" style="display:none;">
        <div style="background:linear-gradient(145deg, #1e1e1e, #252525); padding:40px; border-radius:20px; max-width:700px; margin:20px; border:2px solid #ff4500; box-shadow:0 8px 32px rgba(0,0,0,0.8); text-align:center;">
            <h2 style="color:#ff4500; margin-bottom:30px; font-size:2rem;">ğŸ“Š Runden-Rekapitulation</h2>
            <div id="recapContent" style="min-height:400px;">
                <!-- Wird dynamisch gefÃ¼llt -->
            </div>
            <button onclick="closeRoundRecap()" class="btn-primary" style="margin-top:20px; padding:15px 30px; font-size:1.1rem;">Weiter â­ï¸</button>
        </div>
    </div>

    <!-- WINNER SCREEN -->
    <div id="screen-winner" class="screen card" style="background:radial-gradient(circle at center, rgba(0,209,255,0.15), #0a0a0a 70%); border:2px solid #00d1ff;">
        <div id="confetti-container" style="position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:5000;"></div>
        <div style="text-align:center; position:relative; z-index:1;">
            <div id="winnerEmoji" style="font-size:6rem; margin-bottom:20px; animation:sweatShake 0.9s infinite;">ğŸ˜</div>
            <div id="winnerName" style="font-size:3rem; font-weight:900; color:#00d1ff; margin-bottom:15px; text-shadow:0 0 30px rgba(0,209,255,0.7);">...</div>
            <div style="font-size:1.3rem; color:#c8f4ff; margin-bottom:30px;">ist cool geblieben und gewinnt diese Runde Hitzkopf! ğŸ§Š</div>
            <div style="width:80%; margin:0 auto 30px auto;">
                <div style="height:30px; border-radius:15px; background:#001a28; overflow:hidden; box-shadow:inset 0 0 15px rgba(0,0,0,0.7);">
                    <div id="winnerThermoFill" style="height:100%; width:0%; background:linear-gradient(90deg, #00d1ff, #0080ff); box-shadow:0 0 25px rgba(0,209,255,0.7); transition:width 1.5s ease-out;"></div>
                </div>
                <div id="winnerTemp" style="font-size:2rem; font-weight:bold; color:#00d1ff; margin-top:15px;">0Â°C</div>
            </div>
            <hr style="border-color:#003d5c; margin:30px 0;">
            <div id="rankingList" style="text-align:left; margin-top:20px;">
                <!-- Wird dynamisch gefÃ¼llt -->
            </div>
        </div>
    </div>

    <!-- VOTING SCREEN -->
    <div id="screen-voting" class="screen card">
        <h2 style="color:#ff8c00; margin-bottom:20px;">ğŸ® Spiel beendet!</h2>
        <p style="color:#aaa; margin-bottom:30px;">MÃ¶chtest du noch eine Runde spielen?</p>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:20px;">
            <button id="btnVoteRematch" class="btn-primary" onclick="voteRematch(true)" style="padding:20px; font-size:1.2rem;">âœ… Nochmal spielen</button>
            <button id="btnVoteLeave" class="btn-secondary" onclick="voteRematch(false)" style="padding:20px; font-size:1.2rem;">ğŸšª Verlassen</button>
        </div>
        <div id="votingStatus" style="font-size:0.9rem; color:#888; margin-top:15px;">Warte auf andere Spieler...</div>
        <div id="votingResults" style="margin-top:20px; font-size:0.85rem; color:#aaa;"></div>
    </div>

    <!-- GAMEOVER SCREEN (fÃ¼r rausgeflogene Spieler) -->
    <div id="screen-gameover" class="screen card final-card">
        <div class="final-hero">
            <div id="finalEmoji" class="final-emoji">ğŸ¥µ</div>
            <div>
                <div id="lblLoser" class="final-name">...</div>
                <div id="lblFinalText" class="final-caption">...</div>
            </div>
        </div>
        <div class="final-thermo">
            <div class="final-thermo-track">
                <div id="finalThermoFill" class="final-thermo-fill"></div>
            </div>
        </div>
        <div id="finalRanking" class="final-ranking"></div>
        <button id="btnRematch" style="background:#ff4500; margin-top:25px;" onclick="rematchGame()">â™»ï¸ Revanche starten</button>
        <button style="background:#444; margin-top:10px;" onclick="leaveLobby()">ğŸšª Lobby verlassen</button>
    </div>
    <div id="toast" class="toast"></div>
    <script type="module">
        // --- FIREBASE SETUP ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, arrayUnion, arrayRemove, onSnapshot, increment, deleteDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBQ7c9JkZ3zWlyIjZLl1O1sJJOrKfYJbmA",
            authDomain: "hitzkopf-f0ea6.firebaseapp.com",
            projectId: "hitzkopf-f0ea6",
            storageBucket: "hitzkopf-f0ea6.firebasestorage.app",
            messagingSenderId: "828164655874",
            appId: "1:828164655874:web:1cab759bdb03bfb736101b"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- STATE ---
        let myName = sessionStorage.getItem("hk_name") || "";
        let myEmoji = sessionStorage.getItem("hk_emoji") || "ğŸ˜Š";
        let myGender = sessionStorage.getItem("hk_gender") || "divers"; // Deaktiviert, aber behalten
        let roomId = sessionStorage.getItem("hk_room") || "";
        let isHost = false;
        let localActionDone = false;
        let mySelection = null;
        let myStrategy = null;
        let globalData = null;
        let lastRoundId = null;
        let loggedRoundResult = null;
        let lobbyClosedHandled = false;
        let lastTemps = {};
        let lastMyTemp = null;
        let attackAlertTimer = null;
        let countdownInterval = null;
        let countdownTarget = null;
        let rulesShown = false;
        
        // --- EMOJI SELECTION ---
        const availableEmojis = ['ğŸ˜Š', 'ğŸ˜', 'ğŸ¤ ', 'ğŸ¥³', 'ğŸ˜„', 'ğŸ¤©', 'ğŸ˜‡', 'ğŸ§', 'ğŸ¤“', 'ğŸ˜‹', 'ğŸ·', 'ğŸ‘»', 'ğŸ„', 'ğŸ¶', 'ğŸ±', 'ğŸ¼', 'ğŸ¦', 'ğŸ¸', 'ğŸ¦Š', 'ğŸ¨'];
        let currentEmojiIndex = 0;
        
        window.changeEmoji = (direction) => {
            currentEmojiIndex = (currentEmojiIndex + direction + availableEmojis.length) % availableEmojis.length;
            const emoji = availableEmojis[currentEmojiIndex];
            document.getElementById('emojiDisplay').innerText = emoji;
            document.getElementById('inpEmoji').value = emoji;
            myEmoji = emoji;
        };
        
        // Touch-Swipe fÃ¼r Emoji-Auswahl
        let touchStartX = 0;
        let touchEndX = 0;
        
        // Initialisiere Emoji-Auswahl
        if(document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initEmojiCarousel);
        } else {
            initEmojiCarousel();
        }
        
        function initEmojiCarousel() {
            const emojiCarousel = document.getElementById('emojiCarousel');
            if(emojiCarousel) {
                emojiCarousel.addEventListener('touchstart', (e) => {
                    touchStartX = e.changedTouches[0].screenX;
                });
                emojiCarousel.addEventListener('touchend', (e) => {
                    touchEndX = e.changedTouches[0].screenX;
                    handleSwipe();
                });
            }
            
            // Initialisiere Emoji-Anzeige
            const emojiDisplay = document.getElementById('emojiDisplay');
            const inpEmoji = document.getElementById('inpEmoji');
            if(emojiDisplay && inpEmoji) {
                emojiDisplay.innerText = myEmoji;
                inpEmoji.value = myEmoji;
                currentEmojiIndex = availableEmojis.indexOf(myEmoji);
                if(currentEmojiIndex === -1) currentEmojiIndex = 0;
            }
        }
        
        function handleSwipe() {
            if(touchEndX < touchStartX - 50) {
                changeEmoji(1); // Swipe left = next
            }
            if(touchEndX > touchStartX + 50) {
                changeEmoji(-1); // Swipe right = prev
            }
        }
        
        // --- GENDERING FUNCTION ---
        function genderText(text, gender = myGender) {
            if(!text || typeof text !== 'string') return text;
            const patterns = {
                mÃ¤nnlich: { 'er/ihn': 'er', 'ihn': 'ihn', 'sein': 'sein', 'seine': 'seine', 'seinen': 'seinen', 'seiner': 'seiner' },
                weiblich: { 'er/ihn': 'sie', 'ihn': 'sie', 'sein': 'ihr', 'seine': 'ihre', 'seinen': 'ihren', 'seiner': 'ihrer' },
                divers: { 'er/ihn': 'sie', 'ihn': 'sie', 'sein': 'ihr', 'seine': 'ihre', 'seinen': 'ihren', 'seiner': 'ihrer' }
            };
            const replacements = patterns[gender] || patterns.divers;
            let result = text;
            Object.keys(replacements).forEach(key => {
                const regex = new RegExp(`\\b${key}\\b`, 'gi');
                result = result.replace(regex, replacements[key]);
            });
            return result;
        }
        
        function getGenderPronoun(gender = myGender) {
            const pronouns = {
                mÃ¤nnlich: { subject: 'er', object: 'ihn', possessive: 'sein', possessiveAdj: 'seine' },
                weiblich: { subject: 'sie', object: 'sie', possessive: 'ihr', possessiveAdj: 'ihre' },
                divers: { subject: 'sie', object: 'sie', possessive: 'ihr', possessiveAdj: 'ihre' }
            };
            return pronouns[gender] || pronouns.divers;
        }

        const sleep = (ms = 0) => new Promise(res => setTimeout(res, ms));

        const questions = [
            { q: "Lieber Butter oder Margarine?", a: "Butter ğŸ§ˆ", b: "Margarine ğŸ¥„" },
            { q: "Lieber Kaffee oder Tee?", a: "Kaffee â˜•", b: "Tee ğŸµ" },
            { q: "Lieber Film oder Serie?", a: "Film ğŸ¬", b: "Serie ğŸ“º" },
            { q: "Lieber Hund oder Katze?", a: "Hund ğŸ•", b: "Katze ğŸˆ" },
            { q: "Lieber Sommer oder Winter?", a: "Sommer â˜€ï¸", b: "Winter â„ï¸" },
            { q: "Lieber Urlaub am Strand oder in den Bergen?", a: "Strand ğŸ–ï¸", b: "Berge â›°ï¸" },
            { q: "Lieber Pizza oder Pasta?", a: "Pizza ğŸ•", b: "Pasta ğŸ" },
            { q: "Lieber FrÃ¼haufsteher oder LangschlÃ¤fer?", a: "FrÃ¼h â°â˜€ï¸", b: "SpÃ¤t ğŸŒ™ğŸ’¤" },
            { q: "Lieber Bar oder Club?", a: "Bar ğŸ¸", b: "Club ğŸ¶" },
            { q: "Lieber Konsole oder PC?", a: "Konsole ğŸ®", b: "PC ğŸ’»" },
            { q: "Lieber Schokolade oder GummibÃ¤rchen?", a: "Schokolade ğŸ«", b: "GummibÃ¤rchen ğŸ»" },
            { q: "Lieber Burger oder DÃ¶ner?", a: "Burger ğŸ”", b: "DÃ¶ner ğŸ¥™" },
            { q: "Lieber kochen oder bestellen?", a: "Kochen ğŸ§‘â€ğŸ³", b: "Bestellen ğŸ›µ" },
            { q: "Lieber Apple oder Android?", a: "Apple ğŸ", b: "Android ğŸ¤–" },
            { q: "Lieber Sport im Team oder allein?", a: "Team âš½", b: "Allein ğŸƒâ€â™€ï¸" },
            { q: "Lieber Buch oder HÃ¶rbuch?", a: "Buch ğŸ“š", b: "HÃ¶rbuch ğŸ§" },
            { q: "Lieber Bargeld oder Karte?", a: "Bargeld ğŸ’µ", b: "Karte ğŸ’³" },
            { q: "Lieber Rock oder Pop?", a: "Rock ğŸ¸", b: "Pop ğŸ¤" },
            { q: "Lieber Vanille oder Schokoeis?", a: "Vanille ğŸ¤ğŸ¦", b: "Schoko ğŸ¤ğŸ¦" },
            { q: "Lieber StÃ¤dtetrip oder Wellness?", a: "StÃ¤dtetrip ğŸ™ï¸", b: "Wellness ğŸ§˜â€â™€ï¸" },
            { q: "Lieber Popcorn sÃ¼ÃŸ oder salzig?", a: "SÃ¼ÃŸ ğŸ¬ğŸ¿", b: "Salzig ğŸ§‚ğŸ¿" },
            { q: "Lieber duschen oder baden?", a: "Duschen ğŸš¿", b: "Baden ğŸ›" },
            { q: "Lieber Wein oder Bier?", a: "Wein ğŸ·", b: "Bier ğŸº" },
            { q: "Lieber Sneaker oder Stiefel?", a: "Sneaker ğŸ‘Ÿ", b: "Stiefel ğŸ‘¢" },
            { q: "Lieber Auto oder Bahn?", a: "Auto ğŸš—", b: "Bahn ğŸš‚" },
            { q: "Lieber KÃ¤se oder Wurst?", a: "KÃ¤se ğŸ§€", b: "Wurst ğŸ¥“" },
            { q: "Lieber Spiegelei oder RÃ¼hrei?", a: "Spiegelei ğŸ³ğŸ‘ï¸", b: "RÃ¼hrei ğŸ¥šğŸ¥£" },
            { q: "Lieber WhatsApp oder Anruf?", a: "WhatsApp ğŸ’¬", b: "Anruf ğŸ“" },
            { q: "Lieber Limo oder Saft?", a: "Limo ğŸ¥¤", b: "Saft ğŸ§ƒ" },
            { q: "Lieber Holz- oder MetallmÃ¶bel?", a: "Holz ğŸªµ", b: "Metall ğŸ”©" },
            { q: "Lieber Jeans oder Stoffhose?", a: "Jeans ğŸ‘–", b: "Stoffhose ğŸ©³" },
            { q: "Lieber laut oder leise Musik hÃ¶ren?", a: "Laut ğŸ”ŠğŸ¶", b: "Leise ğŸ¤«ğŸ§" },
            { q: "Lieber Torte oder Kuchen?", a: "Torte ğŸ‚", b: "Kuchen ğŸ°" },
            { q: "Lieber drinnen oder drauÃŸen feiern?", a: "Drinnen ğŸ ğŸ‰", b: "DrauÃŸen ğŸŒ³ğŸ¥³" },
            { q: "Lieber Socken an oder barfuÃŸ?", a: "Socken an ğŸ§¦", b: "BarfuÃŸ ğŸ¦¶" },
            { q: "Lieber Couch oder Sessel?", a: "Couch ğŸ›‹ï¸", b: "Sessel ğŸª‘" },
            { q: "Lieber Ketchup oder Mayo?", a: "Ketchup ğŸ…", b: "Mayo ğŸ¥š" },
            { q: "Lieber Stadt oder Land?", a: "Stadt ğŸ™ï¸", b: "Land ğŸï¸" },
            { q: "Lieber Meer oder See?", a: "Meer ğŸŒŠ", b: "See ğŸï¸ğŸ’§" },
            { q: "Lieber Salat oder Suppe?", a: "Salat ğŸ¥—", b: "Suppe ğŸ¥£" },
            { q: "Lieber Netflix oder YouTube?", a: "Netflix ğŸŸ¥", b: "YouTube â–¶ï¸" },
            { q: "Lieber Smartphone oder Laptop?", a: "Smartphone ğŸ“±", b: "Laptop ğŸ’»" },
            { q: "Lieber FrÃ¼hling oder Herbst?", a: "FrÃ¼hling ğŸŒ·", b: "Herbst ğŸ‚" },
            { q: "Lieber aufstehen oder liegen bleiben?", a: "Aufstehen ğŸš¶â€â™€ï¸", b: "Liegen ğŸ›Œ" },
            { q: "Lieber Bleistift oder Kugelschreiber?", a: "Bleistift âœï¸", b: "Kugelschreiber ğŸ–Šï¸" },
            { q: "Lieber Marmelade oder Honig?", a: "Marmelade ğŸ“", b: "Honig ğŸ¯" },
            { q: "Lieber Kartoffeln oder Reis?", a: "Kartoffeln ğŸ¥”", b: "Reis ğŸš" },
            { q: "Lieber Schreibtisch oder Homeoffice?", a: "BÃ¼ro ğŸ¢", b: "Homeoffice ğŸ¡" },
            { q: "Lieber Feste planen oder spontan sein?", a: "Planen ğŸ—“ï¸", b: "Spontan ğŸ‰" },
            { q: "Lieber Duschgel oder Seife?", a: "Duschgel ğŸ§´", b: "Seife ğŸ§¼" },
            { q: "Lieber sÃ¼ÃŸ oder herzhaft frÃ¼hstÃ¼cken?", a: "SÃ¼ÃŸ ğŸ¥ğŸ¬", b: "Herzhaft ğŸ¥“ğŸ³" },
            { q: "Lieber KÃ¤seplatte oder Obstteller?", a: "KÃ¤se ğŸ§€ğŸ‡", b: "Obst ğŸ¥ğŸ" },
            { q: "Lieber drinnen lesen oder drauÃŸen spazieren?", a: "Drinnen lesen ğŸ“–ğŸ ", b: "DrauÃŸen spazieren ğŸš¶â€â™‚ï¸ğŸŒ²" },
            { q: "Lieber Zelt oder Hotel?", a: "Zelt â›º", b: "Hotel ğŸ¨" },
            { q: "Lieber Apfelkuchen oder KÃ¤sekuchen?", a: "Apfelkuchen ğŸğŸ°", b: "KÃ¤sekuchen ğŸ§€ğŸ°" },
            { q: "Lieber Nachrichten lesen oder hÃ¶ren?", a: "Lesen ğŸ“°ğŸ‘€", b: "HÃ¶ren ğŸ“»ğŸ‘‚" },
            { q: "Lieber Kerzenlicht oder helles Licht?", a: "Kerzenlicht ğŸ”¥ğŸ•¯ï¸", b: "Helles Licht ğŸ’¡âœ¨" },
            { q: "Lieber Sport gucken oder selber machen?", a: "Gucken ğŸŸï¸ğŸ‘€", b: "Machen ğŸ¤¸â€â™‚ï¸ğŸ’ª" },
            { q: "Lieber kurze oder lange Haare?", a: "Kurz ğŸ’‡â€â™€ï¸âœ‚ï¸", b: "Lang ğŸ‘±â€â™€ï¸ğŸ¦’" },
            { q: "Lieber Ananas auf Pizza: Ja oder Nein?", a: "Ananas: Ja ğŸğŸ•ğŸ‘", b: "Ananas: Nein ğŸğŸ•ğŸ‘" },
            { q: "Lieber Stille oder HintergrundgerÃ¤usche beim Arbeiten?", a: "Stille ğŸ¤«ğŸ”‡", b: "Hintergrund ğŸ§ğŸµ" },
            { q: "Lieber Bleistift oder Marker?", a: "Bleistift âœï¸", b: "Marker ğŸ–ï¸" },
            { q: "Lieber Wandern oder Radfahren?", a: "Wandern ğŸš¶â€â™€ï¸ğŸ”ï¸", b: "Radfahren ğŸš²ğŸŒ³" },
            { q: "Lieber Eis im Becher oder in der Waffel?", a: "Becher ğŸ¨", b: "Waffel ğŸ¦" },
            { q: "Lieber am Fenster sitzen oder am Gang (Flugzeug/Bahn)?", a: "Fenster ğŸ–¼ï¸", b: "Gang ğŸšª" },
            { q: "Lieber eine saubere, leere Wohnung oder eine unordentliche, gemÃ¼tliche?", a: "Sauber & Leer âœ¨ğŸ“¦", b: "Unordentlich & GemÃ¼tlich ğŸ›‹ï¸ğŸ˜Œ" },
            { q: "Lieber Kissen weich oder hart?", a: "Weich â˜ï¸", b: "Hart ğŸ§±" },
            { q: "Lieber Laufen oder Schwimmen?", a: "Laufen ğŸƒ", b: "Schwimmen ğŸŠ" },
            { q: "Lieber ein Leben lang nur noch Toast oder nur noch BrÃ¶tchen essen?", a: "Toast ğŸ", b: "BrÃ¶tchen ğŸ¥" },
            { q: "Lieber in der ersten oder letzten Reihe sitzen (Kino/Theater)?", a: "Erste Reihe ğŸ¥‡", b: "Letzte Reihe ğŸ”š" },
            { q: "Lieber Videospiele spielen oder Brettspiele?", a: "Video ğŸ®", b: "Brett ğŸ²" },
            { q: "Lieber Marmelade oder Nutella?", a: "Marmelade ğŸ“", b: "Nutella ğŸ«" },
            { q: "Lieber warm oder kalt trinken?", a: "Warm â™¨ï¸â˜•", b: "Kalt ğŸ§ŠğŸ¥¤" },
            { q: "Lieber Fleisch oder Fisch?", a: "Fleisch ğŸ¥©", b: "Fisch ğŸŸ" },
            { q: "Lieber SÃ¼ÃŸkartoffel oder normale Kartoffel?", a: "SÃ¼ÃŸ ğŸ ", b: "Normal ğŸ¥”" },
            { q: "Lieber Hemd oder T-Shirt?", a: "Hemd ğŸ‘”", b: "T-Shirt ğŸ‘•" },
            { q: "Lieber im Hotel frÃ¼hstÃ¼cken oder im CafÃ©?", a: "Hotel ğŸ¨ğŸ³", b: "CafÃ© â˜•ğŸ¥" },
            { q: "Lieber Scharf oder Mild essen?", a: "Scharf ğŸŒ¶ï¸ğŸ”¥", b: "Mild ğŸ¥›ğŸ˜Œ" },
            { q: "Lieber E-Book oder gedrucktes Buch?", a: "E-Book ğŸ“±ğŸ“š", b: "Gedruckt ğŸ“–ğŸŒ³" },
            { q: "Lieber mit Ã¶ffentlichen Verkehrsmitteln oder mit dem Rad zur Arbeit?", a: "Ã–ffentlich ğŸšŒğŸš†", b: "Fahrrad ğŸš²" },
            { q: "Lieber Rotwein oder WeiÃŸwein?", a: "Rotwein ğŸ·ğŸ”´", b: "WeiÃŸwein ğŸ¥‚âšª" },
            { q: "Lieber in der KÃ¼che oder im Wohnzimmer essen?", a: "KÃ¼che ğŸ§‘â€ğŸ³ğŸ½ï¸", b: "Wohnzimmer ğŸ›‹ï¸ğŸ“º" },
            { q: "Lieber SalzgebÃ¤ck oder Chips?", a: "SalzgebÃ¤ck ğŸ¥¨", b: "Chips ğŸ¥”ğŸ’¸" },
            { q: "Lieber morgens oder abends trainieren?", a: "Morgens ğŸŒ…ğŸƒ", b: "Abends ğŸŒ™ğŸ’ª" },
            { q: "Lieber schreiben oder lesen?", a: "Schreiben âœï¸", b: "Lesen ğŸ“–" },
            { q: "Lieber Krawatte oder Fliege?", a: "Krawatte ğŸ‘”", b: "Fliege ğŸ€" },
            { q: "Lieber glatt oder lockig?", a: "Glatt ğŸ’‡â€â™€ï¸ğŸ“", b: "Lockig ğŸ’†â€â™€ï¸ğŸŒ€" },
            { q: "Lieber Taschenlampe oder Kerze?", a: "Taschenlampe ğŸ”¦", b: "Kerze ğŸ•¯ï¸" },
            { q: "Lieber nur noch GemÃ¼se oder nur noch Obst essen?", a: "GemÃ¼se ğŸ¥¦ğŸ¥¬", b: "Obst ğŸğŸŠ" },
            { q: "Lieber online shoppen oder im Laden?", a: "Online ğŸ›’ğŸ’»", b: "Im Laden ğŸ›ï¸ğŸš¶" },
            { q: "Lieber nur noch MÃ¼tzen oder nur noch Schals tragen?", a: "MÃ¼tzen ğŸ§¢ğŸ‘’", b: "Schals ğŸ§£ğŸ§£" },
            { q: "Lieber immer pÃ¼nktlich oder immer gute Laune?", a: "PÃ¼nktlich â°âœ…", b: "Gute Laune ğŸ˜„ğŸ¥³" },
            { q: "Lieber Suppe mit Einlage oder pur?", a: "Mit Einlage ğŸœğŸ²", b: "Pur ğŸ¥£ğŸ’§" },
            { q: "Lieber SÃ¼ÃŸigkeiten im KÃ¼hlschrank oder ungekÃ¼hlt?", a: "Kalt ğŸ§ŠğŸ¬", b: "Zimmerwarm ğŸŒ¡ï¸ğŸ­" },
            { q: "Lieber einmal viel Geld oder jeden Tag ein bisschen?", a: "Einmal viel ğŸ’°ğŸ’¥", b: "Jeden Tag etwas ğŸ’¸ğŸ—“ï¸" },
            { q: "Lieber auf dem Bauch oder auf der Seite schlafen?", a: "Bauch â¬‡ï¸ğŸ›Œ", b: "Seite â†ªï¸ğŸ˜´" },
            { q: "Lieber Jeans mit LÃ¶chern oder ohne?", a: "Mit LÃ¶chern ğŸ‘–ğŸ•³ï¸", b: "Ohne LÃ¶cher ğŸ‘–âœ¨" },
            { q: "Lieber weiÃŸe oder bunte WÃ¤sche?", a: "WeiÃŸe âšªğŸ§º", b: "Bunte ğŸŒˆğŸ‘•" },
            { q: "Lieber Nudeln al dente oder weich?", a: "Al Dente ğŸ‘ŒğŸ", b: "Weich ğŸ˜´ğŸœ" },
            { q: "Lieber Musik mit oder ohne Text?", a: "Mit Text ğŸ—£ï¸ğŸµ", b: "Instrumental ğŸ¼ğŸ§" },
            { q: "Lieber FÃ¼ller oder Kugelschreiber?", a: "FÃ¼ller ğŸ–‹ï¸âœ¨", b: "Kugelschreiber ğŸ–Šï¸ğŸ’ª" }
        ];
        
        function getRandomUnusedQuestion(usedQuestions = []) {
            if(!questions || questions.length === 0) {
                console.error('Keine Fragen verfÃ¼gbar!');
                return { question: { q: "Keine Frage verfÃ¼gbar", a: "A", b: "B" }, index: -1 };
            }
            const available = questions.filter((q, idx) => !usedQuestions.includes(idx));
            if(available.length === 0) {
                const randomIdx = Math.floor(Math.random() * questions.length);
                const q = questions[randomIdx];
                if(!q || !q.q) {
                    console.error('UngÃ¼ltige Frage gefunden:', q);
                    return { question: questions[0] || { q: "Fehler", a: "A", b: "B" }, index: 0 };
                }
                return { question: q, index: randomIdx };
            }
            const randomQ = available[Math.floor(Math.random() * available.length)];
            if(!randomQ || !randomQ.q) {
                console.error('UngÃ¼ltige Frage gefunden:', randomQ);
                return { question: questions[0] || { q: "Fehler", a: "A", b: "B" }, index: 0 };
            }
            return { question: randomQ, index: questions.indexOf(randomQ) };
        }
        const cardInfo = {
            card_oil: { label: "ğŸ›¢ï¸ Ã–lfass", desc: "Verdoppelt deinen nÃ¤chsten Angriff." },
            card_mirror: { label: "ğŸª Spiegel", desc: "Der nÃ¤chste Angriff prallt zurÃ¼ck." },
            card_ice: { label: "ğŸ§Š EiswÃ¼rfel", desc: "KÃ¼hlt dich in der nÃ¤chsten Runde automatisch ab." }
        };

        // --- AUTO LOGIN ---
        if(myName && roomId) {
            document.getElementById('inpName').value = myName;
            if(document.getElementById('inpEmoji')) {
                document.getElementById('inpEmoji').value = myEmoji;
                document.getElementById('emojiDisplay').innerText = myEmoji;
                currentEmojiIndex = availableEmojis.indexOf(myEmoji);
                if(currentEmojiIndex === -1) currentEmojiIndex = 0;
            }
            document.getElementById('inpCode').value = roomId;
            setTimeout(() => joinGame(), 500);
        }

        // --- MENU / START CONTROLS ---
        window.toggleMenu = () => {
            document.getElementById('adminDrawer').classList.toggle('open');
            document.getElementById('menuOverlay').classList.toggle('open');
        };
        function ensureName() {
            const name = document.getElementById('inpName').value.trim();
            if(!name) {
                showToast("Bitte gib zuerst deinen Namen ein.");
                document.getElementById('inpName').focus();
                return false;
            }
            return true;
        }

        window.openHostSettings = () => {
            if(!ensureName()) return;
            const panel = document.getElementById('hostSettings');
            const join = document.getElementById('joinPanel');
            join.classList.add('hidden');
            panel.classList.toggle('hidden');
            if(!panel.classList.contains('hidden')) {
                document.getElementById('inpDmg').focus();
            }
        };
        window.openJoinPanel = () => {
            if(!ensureName()) return;
            const panel = document.getElementById('joinPanel');
            const host = document.getElementById('hostSettings');
            host.classList.add('hidden');
            panel.classList.toggle('hidden');
            if(!panel.classList.contains('hidden')) {
                document.getElementById('inpCode').focus();
            }
        };
        window.toggleLobbyReady = async () => {
            if(!roomId) return;
            const current = !!(globalData?.lobbyReady?.[myName]);
            await updateDoc(doc(db, "lobbies", roomId), {
                [`lobbyReady.${myName}`]: !current
            });
        };

        // --- CREATE GAME ---
        window.createGame = async () => {
            const name = document.getElementById('inpName').value.trim();
            const emoji = document.getElementById('inpEmoji').value || 'ğŸ˜Š';
            const gender = "divers"; // Deaktiviert, aber behalten
            const dmg = parseInt(document.getElementById('inpDmg').value);
            const speed = parseFloat(document.getElementById('inpSpeed').value);
            const startTemp = parseInt(document.getElementById('inpStartTemp').value);
            const maxTemp = parseInt(document.getElementById('inpMaxTemp').value);
            if(!name) {
                showToast("Bitte gib einen Namen ein!");
                return;
            }
            
            const code = Math.random().toString(36).substring(2,6).toUpperCase();
            myName = name;
            myEmoji = emoji;
            myGender = gender;
            roomId = code;
            sessionStorage.setItem("hk_name", name);
            sessionStorage.setItem("hk_emoji", emoji);
            sessionStorage.setItem("hk_gender", gender);
            sessionStorage.setItem("hk_room", code);

            await setDoc(doc(db, "lobbies", code), {
                host: name,
                status: "lobby",
                players: { [name]: { temp: startTemp, inventory: [], gender: gender, emoji: emoji } },
                config: { dmg: dmg, speed: speed, startTemp: startTemp, maxTemp: maxTemp },
                votes: {},
                ready: [],
                log: [],
                hotseat: "",
                currentQ: questions[0],
                roundId: 0,
                lobbyReady: {},
                countdownEnds: null,
                usedQuestions: [],
                eliminatedShown: [],
                rematchVotes: {},
                winner: null
            });
            connectToLobby();
        };

        // --- JOIN GAME ---
        window.joinGame = async () => {
            const name = document.getElementById('inpName').value.trim();
            const emoji = document.getElementById('inpEmoji').value || 'ğŸ˜Š';
            const gender = "divers"; // Deaktiviert, aber behalten
            const code = document.getElementById('inpCode').value.trim().toUpperCase();
            if(!name || !code) {
                showToast("Bitte gib Name und Code ein!");
                return;
            }
            
            myName = name;
            myEmoji = emoji;
            myGender = gender;
            roomId = code;
            sessionStorage.setItem("hk_name", name);
            sessionStorage.setItem("hk_emoji", emoji);
            sessionStorage.setItem("hk_gender", gender);
            sessionStorage.setItem("hk_room", code);

            const ref = doc(db, "lobbies", code);
            const snap = await getDoc(ref);
            if(!snap.exists()) {
                showToast("Lobby nicht gefunden! PrÃ¼fe den Code.");
                return;
            }

            const data = snap.data();
            const startTemp = data.config?.startTemp || 0;
            if(!data.players[name]) {
                await updateDoc(ref, { [`players.${name}`]: { temp: startTemp, inventory: [], gender: gender, emoji: emoji } });
            } else {
                // Emoji und Geschlecht aktualisieren falls bereits vorhanden
                await updateDoc(ref, { 
                    [`players.${name}.gender`]: gender,
                    [`players.${name}.emoji`]: emoji
                });
            }
            connectToLobby();
        };

        // --- CONNECT TO LOBBY ---
        function connectToLobby() {
            onSnapshot(doc(db, "lobbies", roomId), (snap) => {
                if(!snap.exists()) { 
                    sessionStorage.clear(); 
                    location.reload(); 
                    return; 
                }
                const data = snap.data();
                globalData = data;

                const meState = data.players?.[myName];
                if(meState) {
                    if(lastMyTemp != null && meState.temp > lastMyTemp) {
                        const delta = meState.temp - lastMyTemp;
                        const latestAttack = findLatestAttackOnMe(data.log);
                        const attacker = latestAttack?.attacker || "Jemand";
                        const dmgShown = latestAttack?.dmg || delta;
                        triggerAttackFeedback(attacker, dmgShown);
                    }
                    lastMyTemp = meState.temp;
                } else {
                    lastMyTemp = null;
                }

                if(data.status === 'closed') {
                    if(!lobbyClosedHandled) {
                        lobbyClosedHandled = true;
                        showToast("ğŸ›‘ Host hat die Lobby beendet.");
                    }
                    sessionStorage.clear();
                    setTimeout(() => location.reload(), 200);
                    return;
                }
                
                isHost = (data.host === myName);
                if(isHost) {
                    document.getElementById('hostControls').style.display = 'block';
                    document.getElementById('btnHostStart').style.display = 'block';
                    document.getElementById('lblWait').style.display = 'none';
                }

                // RENDER
                renderThermos(data.players, 'gridGame');
                renderThermos(data.players, 'gridResult');
                renderLog(data.log);

                // DEATH CHECK - Spieler mit 100Â° fliegen raus, kÃ¶nnen aber zuschauen
                const maxTemp = data.config?.maxTemp || 100;
                const activePlayers = Object.keys(data.players).filter(p => data.players[p].temp < maxTemp);
                const eliminatedPlayers = Object.keys(data.players).filter(p => data.players[p].temp >= maxTemp);
                
                // PrÃ¼fe ob Spieler gerade rausgeflogen ist (fÃ¼r Animation)
                if(eliminatedPlayers.length > 0 && isHost) {
                    eliminatedPlayers.forEach(eliminated => {
                        const eliminatedShown = data.eliminatedShown || [];
                        if(!eliminatedShown.includes(eliminated)) {
                            // Markiere als gezeigt
                            updateDoc(doc(db, "lobbies", roomId), {
                                eliminatedShown: arrayUnion(eliminated)
                            }).catch(console.error);
                        }
                    });
                }
                
                // Zeige Animation fÃ¼r alle (auch wenn nicht Host)
                eliminatedPlayers.forEach(eliminated => {
                    const eliminatedShown = data.eliminatedShown || [];
                    if(eliminatedShown.includes(eliminated)) {
                        // Nur einmal zeigen
                        return;
                    }
                    // Zeige Animation fÃ¼r rausgeflogenen Spieler
                    showEliminationAnimation(eliminated, data.players[eliminated].temp);
                });

                // PrÃ¼fe ob nur noch ein Spieler Ã¼brig ist (Gewinner)
                if(activePlayers.length === 1 && data.status !== 'winner' && data.status !== 'voting') {
                    const winner = activePlayers[0];
                    if(isHost) {
                        updateDoc(doc(db, "lobbies", roomId), {
                            status: 'winner',
                            winner: winner
                        }).catch(console.error);
                    }
                } else if(activePlayers.length === 0 && data.status !== 'voting') {
                    // Fallback: Wenn alle raus sind, gewinnt der mit niedrigster Temperatur
                    let minTemp = 999;
                    let winner = null;
                    Object.keys(data.players).forEach(p => {
                        if(data.players[p].temp < minTemp) {
                            minTemp = data.players[p].temp;
                            winner = p;
                        }
                    });
                    if(winner && isHost) {
                        updateDoc(doc(db, "lobbies", roomId), {
                            status: 'winner',
                            winner: winner
                        }).catch(console.error);
                    }
                }

                // PrÃ¼fe ob Spieler rausgeflogen ist (fÃ¼r Spectator-Mode)
                if(eliminatedPlayers.includes(myName)) {
                    showSpectatorMode();
                } else {
                    hideSpectatorMode();
                }

                // ROUTER
                const shareBtn = document.getElementById('btnShare');
                const readyBtn = document.getElementById('btnLobbyReady');
                const readyStatus = document.getElementById('lobbyReadyStatus');
                const readyList = document.getElementById('lobbyReadyList');
                const hostStartBtn = document.getElementById('btnHostStart');
                if(data.status === 'lobby') {
                    showScreen('screen-lobby');
                    document.getElementById('lblCode').innerText = roomId;
                    const players = Object.keys(data.players);
                    document.getElementById('lobbyList').innerHTML = players.map(p => 
                        `<div>${p}${p === data.host ? ' ğŸ‘‘' : ''}</div>`
                    ).join('');
                    const readyObj = data.lobbyReady || {};
                    if(readyList) {
                        readyList.innerHTML = players.map(p => {
                            const ready = readyObj[p];
                            const icon = ready ? 'âœ…' : 'â³';
                            const playerData = data.players[p];
                            const playerEmoji = playerData?.emoji || 'ğŸ˜Š';
                            return `<div>${icon} ${playerEmoji} ${p}</div>`;
                        }).join('');
                    }
                    const readyCount = players.filter(p => readyObj[p]).length;
                    if(readyStatus) readyStatus.innerText = `Bereit: ${readyCount}/${players.length}`;
                    if(readyBtn) {
                        readyBtn.style.display = 'block';
                        readyBtn.innerText = readyObj[myName] ? "âŒ Nicht bereit" : "âœ… Bereit";
                        readyBtn.classList.toggle('btn-primary', !readyObj[myName]);
                        readyBtn.classList.toggle('btn-secondary', !!readyObj[myName]);
                    }
                    if(hostStartBtn) {
                        hostStartBtn.style.display = isHost ? 'block' : 'none';
                        hostStartBtn.disabled = !(isHost && readyCount === players.length && players.length >= 2);
                    }
                    lastTemps = {};
                    if(shareBtn) shareBtn.style.display = 'block';
                }
                else if(data.status === 'countdown') {
                    showScreen('screen-lobby');
                    if(readyBtn) readyBtn.style.display = 'none';
                    if(readyStatus) readyStatus.innerText = "";
                    if(readyList) readyList.innerHTML = "";
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) {
                        hostStartBtn.disabled = true;
                        hostStartBtn.style.display = 'none';
                    }
                }
                else if(data.status === 'game') {
                    // Sicherstellen, dass currentQ gesetzt ist und korrekt formatiert
                    let currentQ = data.currentQ;
                    if(currentQ && typeof currentQ === 'object') {
                        // PrÃ¼fe ob es ein Firebase Timestamp oder Map ist
                        if(currentQ.toDate || currentQ.toMillis) currentQ = null;
                    }
                    if(!currentQ || typeof currentQ.q !== 'string' || !currentQ.q) {
                        if(isHost) {
                            const usedQuestions = data.usedQuestions || [];
                            const { question: q } = getRandomUnusedQuestion(usedQuestions);
                            updateDoc(doc(db, "lobbies", roomId), { currentQ: q }).catch(console.error);
                            data.currentQ = q;
                        } else {
                            // Fallback fÃ¼r Nicht-Hosts
                            data.currentQ = questions[0] || { q: "Lade Frage...", a: "A", b: "B" };
                        }
                    } else {
                        data.currentQ = currentQ; // Verwende das bereinigte currentQ
                    }
                    if(readyBtn) readyBtn.style.display = 'none';
                    if(readyStatus) readyStatus.innerText = "";
                    if(readyList) readyList.innerHTML = "";
                    showScreen('screen-game');
                    renderGame(data);
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) hostStartBtn.style.display = 'none';
                    // Host Auto-Advance
                    if(isHost && Object.keys(data.votes).length >= Object.keys(data.players).length) {
                        setTimeout(() => {
                            updateDoc(doc(db, "lobbies", roomId), { status: 'result' });
                        }, 500);
                    }
                }
                else if(data.status === 'result') {
                    // Sicherstellen, dass currentQ gesetzt ist und korrekt formatiert
                    let currentQ = data.currentQ;
                    if(currentQ && typeof currentQ === 'object') {
                        // PrÃ¼fe ob es ein Firebase Timestamp oder Map ist
                        if(currentQ.toDate || currentQ.toMillis) currentQ = null;
                    }
                    if(!currentQ || typeof currentQ.q !== 'string' || !currentQ.q) {
                        if(isHost) {
                            const usedQuestions = data.usedQuestions || [];
                            const { question: q } = getRandomUnusedQuestion(usedQuestions);
                            updateDoc(doc(db, "lobbies", roomId), { currentQ: q }).catch(console.error);
                            data.currentQ = q;
                        } else {
                            // Fallback fÃ¼r Nicht-Hosts
                            data.currentQ = questions[0] || { q: "Lade Frage...", a: "A", b: "B" };
                        }
                    } else {
                        data.currentQ = currentQ; // Verwende das bereinigte currentQ
                    }
                    if(readyBtn) readyBtn.style.display = 'none';
                    if(readyStatus) readyStatus.innerText = "";
                    if(readyList) readyList.innerHTML = "";
                    showScreen('screen-result');
                    renderResult(data);
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) hostStartBtn.style.display = 'none';
                    // Host Auto-Next
                    if(isHost && data.ready.length >= Object.keys(data.players).length) {
                        setTimeout(() => nextRound(), 1000);
                    }
                }
                else if(data.status === 'winner') {
                    showScreen('screen-winner');
                    renderWinner(data.winner, data.players);
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) hostStartBtn.style.display = 'none';
                    // Nach 5 Sekunden zum Voting-Screen
                    if(isHost) {
                        setTimeout(() => {
                            updateDoc(doc(db, "lobbies", roomId), { status: 'voting' }).catch(console.error);
                        }, 5000);
                    }
                }
                else if(data.status === 'voting') {
                    showScreen('screen-voting');
                    renderVoting(data);
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) hostStartBtn.style.display = 'none';
                }
                handleCountdownOverlay(data);
            });
        }
        // --- RENDER GAME ---
        function renderGame(data) {
            const roundId = data.roundId ?? 0;
            const btnLock = document.getElementById('btnLock');
            const btnA = document.getElementById('btnA');
            const btnB = document.getElementById('btnB');
            const lblHotseat = document.getElementById('lblHotseat');
            const lblHotseatSub = document.getElementById('lblHotseatSub');

            if(lastRoundId !== roundId) {
                lastRoundId = roundId;
                localActionDone = false;
                mySelection = null;
                btnA.classList.remove('selected');
                btnB.classList.remove('selected');
                btnLock.disabled = true;
                // A/B Buttons werden spÃ¤ter aktiviert, wenn hotseat gesetzt ist
            }

            if(data.votes[myName]) {
                btnLock.classList.add('hidden');
                // Wenn bereits abgestimmt, A/B Buttons deaktivieren
                const optionRow = document.getElementById('optionRow');
                if(optionRow) {
                    optionRow.style.opacity = '0.5';
                    optionRow.style.pointerEvents = 'none';
                }
            } else {
                btnLock.classList.remove('hidden');
                // Strategie ist nur eine Vorauswahl, nicht mehr zwingend
                btnLock.disabled = !mySelection;
            }

            // Robustere Behandlung von currentQ (Firebase kann Objekte anders serialisieren)
            let currentQ = data.currentQ;
            if(currentQ && typeof currentQ === 'object') {
                // PrÃ¼fe ob es ein Firebase Timestamp oder Map ist
                if(currentQ.toDate) currentQ = null; // Timestamp, ignorieren
                if(currentQ.toMillis) currentQ = null; // Timestamp, ignorieren
            }
            
            if(currentQ && currentQ.q && typeof currentQ.q === 'string') {
                document.getElementById('lblQuestion').innerText = currentQ.q;
                btnA.innerText = currentQ.a || 'A';
                btnB.innerText = currentQ.b || 'B';
            } else {
                // Fallback falls currentQ fehlt oder falsch formatiert
                console.warn('currentQ fehlt oder ist falsch formatiert:', currentQ);
                const fallbackQ = questions[0] || { q: "Lade Frage...", a: "A", b: "B" };
                document.getElementById('lblQuestion').innerText = fallbackQ.q;
                btnA.innerText = fallbackQ.a;
                btnB.innerText = fallbackQ.b;
                
                // Versuche currentQ zu reparieren (nur als Host)
                if(isHost && globalData) {
                    const usedQuestions = globalData.usedQuestions || [];
                    const { question: q } = getRandomUnusedQuestion(usedQuestions);
                    updateDoc(doc(db, "lobbies", roomId), { currentQ: q }).catch(console.error);
                }
            }
            
            if(!data.hotseat) {
                lblHotseat.innerText = "Runde wird vorbereitet...";
                lblHotseatSub.innerText = "Bitte kurz warten.";
                // A/B Buttons aktivieren
                const optionRow = document.getElementById('optionRow');
                if(optionRow) {
                    optionRow.style.opacity = '1';
                    optionRow.style.pointerEvents = 'auto';
                }
            } else if(myName === data.hotseat) {
                lblHotseat.innerText = "Du beantwortest die Frage!";
                lblHotseatSub.innerText = "Antworte ehrlich â€“ die anderen versuchen deine Wahl zu erraten.";
                // Hotseat kann direkt A/B wÃ¤hlen
                const optionRow = document.getElementById('optionRow');
                if(optionRow) {
                    optionRow.style.opacity = '1';
                    optionRow.style.pointerEvents = 'auto';
                }
            } else {
                lblHotseat.innerText = `${data.hotseat} beantwortet die Frage!`;
                lblHotseatSub.innerText = "Errate die Wahl, um anzugreifen oder Joker zu ziehen.";
                // A/B Buttons aktivieren
                const optionRow = document.getElementById('optionRow');
                if(optionRow) {
                    optionRow.style.opacity = '1';
                    optionRow.style.pointerEvents = 'auto';
                }
            }
            
            const players = Object.keys(data.players);
            const voted = players.filter(p => data.votes[p]);
            const pending = players.filter(p => !data.votes[p]);
            const voteStatusEl = document.getElementById('lblVoteStatus');
            const voteText = voted.length ? voted.join(', ') : 'Niemand';
            const pendingText = pending.length ? pending.join(', ') : 'Niemand';
            voteStatusEl.innerHTML = `âœ… Abgegeben: ${voteText}<br>ğŸ¤” Ãœberlegen: ${pendingText}`;
            if(data.players[myName]) {
                renderMyJokers('myJokerListGame', data.players[myName]);
            }
        }

        // --- RENDER RESULT ---
        function renderResult(data) {
            const truth = data.votes[data.hotseat]?.choice;
            let truthText = '?';
            
            // Robustere Behandlung von currentQ (Firebase kann Objekte anders serialisieren)
            let currentQ = data.currentQ;
            if(currentQ && typeof currentQ === 'object') {
                // PrÃ¼fe ob es ein Firebase Timestamp oder Map ist
                if(currentQ.toDate) currentQ = null; // Timestamp, ignorieren
                if(currentQ.toMillis) currentQ = null; // Timestamp, ignorieren
            }
            
            if(truth && currentQ && typeof currentQ.a === 'string' && typeof currentQ.b === 'string') {
                truthText = truth === 'A' ? currentQ.a : currentQ.b;
            } else if(truth) {
                // Fallback falls currentQ fehlt
                console.warn('currentQ fehlt in renderResult:', currentQ);
                truthText = truth === 'A' ? 'A' : 'B';
            }
            document.getElementById('lblTruth').innerText = truthText;

            const myVote = data.votes[myName];
            const statusEl = document.getElementById('lblResultStatus');
            const boxAttack = document.getElementById('boxAttack');
            const boxShop = document.getElementById('boxShop');
            const btnReady = document.getElementById('btnReady');

            // Reset Boxes
            boxAttack.style.display = 'none';
            boxShop.style.display = 'none';
            
            // Ready Status
            document.getElementById('lblReady').innerText = 
                `Bereit: ${data.ready.length}/${Object.keys(data.players).length}`;
            
            if(data.ready.includes(myName)) {
                btnReady.disabled = true;
                btnReady.innerText = "â³ Warte...";
                return;
            } else {
                btnReady.disabled = false;
                btnReady.innerText = "ğŸ‘ Bereit";
            }

            if(isHost) {
                maybeLogRoundSummary(data, truthText, truth);
            }

            // Zeige Rekapitulation wenn alle bereit sind (nur einmal pro Runde)
            if(data.ready.length >= Object.keys(data.players).length && !data.roundRecapShown) {
                if(isHost) {
                    updateDoc(doc(db, "lobbies", roomId), { roundRecapShown: true }).catch(console.error);
                }
                // Zeige Rekapitulation nach kurzer VerzÃ¶gerung
                setTimeout(() => {
                    showRoundRecap(data);
                }, 1500);
            }

            if(myName === data.hotseat) {
                statusEl.innerText = "Du hast die Frage beantwortet.";
                statusEl.style.color = "#aaa";
            } else {
                if(myVote && myVote.choice === truth) {
                    statusEl.innerHTML = "âœ… <strong>RICHTIG GERATEN!</strong><br><span style='font-size:0.9rem; font-weight:normal;'>Hier ist deine Belohnung, wie mÃ¶chtest du vorgehen?</span>";
                    statusEl.style.color = "#0f0";

                    if(!localActionDone) {
                        btnReady.disabled = true;
                        btnReady.innerText = "âš¡ WÃ¤hle deine Belohnung!";
                        
                        // Zeige immer beide Optionen an, unabhÃ¤ngig von der vorherigen Strategie
                        const rewardBoxEl = document.getElementById('boxReward');
                        if(rewardBoxEl) {
                            rewardBoxEl.style.display = 'block';
                        }
                    }
                } else {
                    if(!myVote) {
                        statusEl.innerText = "âŒ› Keine Antwort abgegeben.";
                        statusEl.style.color = "#ccc";
                    } else {
                        statusEl.innerText = "âŒ FALSCH";
                        statusEl.style.color = "#f00";
                    }
                    localActionDone = true;
                }
            }
            if(data.players[myName]) {
                renderMyJokers('myJokerListResult', data.players[myName]);
            }
        }

        // --- RENDER TARGETS ---
        window.renderTargets = (players) => {
            const div = document.getElementById('divTargets');
            div.innerHTML = "";
            const dmg = globalData?.config?.dmg || 10;
            Object.keys(players).forEach(p => {
                if(p !== myName) {
                    const b = document.createElement('button');
                    b.className = 'btn-danger';
                    b.innerText = `${p} (+${dmg}Â°C)`;
                    b.onclick = () => doAttack(p);
                    div.appendChild(b);
                }
            });
        };

        // --- SELECT STRATEGY ---
        window.selectStrategy = (strat) => {
            myStrategy = strat;
            const btnAttack = document.getElementById('btnStratAttack');
            const btnInvest = document.getElementById('btnStratInvest');
            const lockBtn = document.getElementById('btnLock');
            
            // Buttons markieren (nur visuelle Vorauswahl)
            if(btnAttack) {
                btnAttack.classList.toggle('selected', strat === 'attack');
            }
            if(btnInvest) {
                btnInvest.classList.toggle('selected', strat === 'invest');
            }
            
            // Lock-Button aktivieren, wenn bereits A/B gewÃ¤hlt wurde
            if(lockBtn && mySelection) {
                lockBtn.disabled = false;
            }
        };

        // --- VOTE ---
        window.vote = (opt) => {
            // Strategie ist nur eine Vorauswahl, nicht mehr zwingend erforderlich
            mySelection = opt;
            document.getElementById('btnA').classList.toggle('selected', opt === 'A');
            document.getElementById('btnB').classList.toggle('selected', opt === 'B');
            const lockBtn = document.getElementById('btnLock');
            lockBtn.disabled = false;
        };

        // --- SUBMIT VOTE ---
        window.submitVote = async () => {
            // PrÃ¼fe ob Hotseat (dann keine Strategie nÃ¶tig)
            const stratSection = document.getElementById('stratSection');
            const isHotseat = stratSection && stratSection.classList.contains('hidden');
            
            if(!mySelection) {
                showToast("Bitte wÃ¤hle zuerst eine Antwort (A oder B)!");
                return;
            }
            
            // Strategie ist nur eine Vorauswahl, wird nicht mehr bindend gespeichert
            // Die finale Entscheidung wird im Result-Screen getroffen
            let strat = myStrategy || 'none'; // Vorauswahl oder 'none' als Fallback
            
            // Hotseat braucht keine Strategie (wird ignoriert)
            if(isHotseat) {
                strat = 'none'; // Placeholder fÃ¼r Hotseat
            }
            
            document.getElementById('btnLock').classList.add('hidden');
            
            await updateDoc(doc(db, "lobbies", roomId), {
                [`votes.${myName}`]: { choice: mySelection, strategy: strat }
            });
        };

        // --- CHOOSE REWARD ---
        window.chooseReward = (rewardType) => {
            const rewardBox = document.getElementById('boxReward');
            if(rewardBox) rewardBox.style.display = 'none';
            
            const boxAttack = document.getElementById('boxAttack');
            const boxShop = document.getElementById('boxShop');
            
            if(rewardType === 'attack') {
                boxAttack.style.display = 'block';
                renderTargets(globalData.players);
            } else if(rewardType === 'invest') {
                boxShop.style.display = 'block';
            }
        };

        // --- GO BACK TO REWARD ---
        window.goBackToReward = () => {
            const rewardBox = document.getElementById('boxReward');
            const boxAttack = document.getElementById('boxAttack');
            const boxShop = document.getElementById('boxShop');
            
            if(rewardBox) rewardBox.style.display = 'block';
            if(boxAttack) boxAttack.style.display = 'none';
            if(boxShop) boxShop.style.display = 'none';
        };

        // --- ATTACK ---
        window.doAttack = async (target) => {
            localActionDone = true;
            const rewardBox = document.getElementById('boxReward');
            if(rewardBox) rewardBox.style.display = 'none';
            document.getElementById('boxAttack').style.display = 'none';
            document.getElementById('btnReady').disabled = false;
            
            const baseDmg = globalData?.config?.dmg || 10;
            const ref = doc(db, "lobbies", roomId);
            const attackerState = globalData?.players?.[myName] || {};
            const targetState = globalData?.players?.[target] || {};
            const hasOil = attackerState.inventory?.includes('card_oil');
            const targetHasMirror = targetState.inventory?.includes('card_mirror');
            const dmg = baseDmg * (hasOil ? 2 : 1);
            const attackMsg = hasOil 
                ? `ğŸ”¥ ${myName} greift ${target} mit dem Ã–lfass an (+${dmg}Â°C)`
                : `ğŸ”¥ ${myName} greift ${target} an (+${dmg}Â°C)`;

            await updateDoc(ref, { log: arrayUnion(attackMsg) });

            if(hasOil) {
                await updateDoc(ref, { [`players.${myName}.inventory`]: arrayRemove('card_oil') });
            }

            if(targetHasMirror) {
                await updateDoc(ref, {
                    [`players.${target}.inventory`]: arrayRemove('card_mirror'),
                    log: arrayUnion(`ğŸª ${target} spiegelt den Angriff auf ${myName} zurÃ¼ck! (+${dmg}Â°C)`)
                });
                await sleep(400);
                await updateDoc(ref, {
                    [`players.${myName}.temp`]: increment(dmg)
                });
                return;
            }

            await sleep(700);
            const newTemp = (targetState.temp || 0) + dmg;
            await updateDoc(ref, {
                [`players.${target}.temp`]: increment(dmg)
            });
            
            // Zeige Animation
            await showAttackAnimation(target, myName, dmg, newTemp);
        };

        // --- TAKE CARD ---
        window.takeCard = async (card) => {
            localActionDone = true;
            const rewardBox = document.getElementById('boxReward');
            if(rewardBox) rewardBox.style.display = 'none';
            document.getElementById('boxShop').style.display = 'none';
            document.getElementById('btnReady').disabled = false;

            const inventory = globalData?.players?.[myName]?.inventory || [];
            if(inventory.includes(card)) {
                showToast("Du besitzt diesen Joker bereits! Du kannst jeden Joker nur einmal haben.");
                return;
            }

            await updateDoc(doc(db, "lobbies", roomId), {
                [`players.${myName}.inventory`]: arrayUnion(card),
                log: arrayUnion(`ğŸƒ ${myName} zieht eine geheime Karte.`)
            });
            
            // Zeige Animation
            await showJokerAnimation(myName, card);
            
            showToast(`${cardInfo[card].label} erhalten! ${cardInfo[card].desc}`);
        };

        // --- SKIP ATTACK ---
        window.skipAttack = async () => {
            localActionDone = true;
            const rewardBox = document.getElementById('boxReward');
            if(rewardBox) rewardBox.style.display = 'none';
            document.getElementById('boxAttack').style.display = 'none';
            document.getElementById('btnReady').disabled = false;
            document.getElementById('btnReady').innerText = "ğŸ‘ Bereit";
            await updateDoc(doc(db, "lobbies", roomId), {
                log: arrayUnion(`ğŸ•Šï¸ ${myName} verzichtet auf einen Angriff.`)
            });
        };

        // --- SET READY ---
        window.setReady = async () => {
            await updateDoc(doc(db, "lobbies", roomId), { 
                ready: arrayUnion(myName) 
            });
        };
        // --- START GAME (COUNTDOWN) ---
        window.startCountdown = async () => {
            if(!isHost || !globalData) return;
            const players = Object.keys(globalData.players);
            if(players.length < 2) {
                showToast("Mindestens 2 Spieler benÃ¶tigt!");
                return;
            }
            const readyObj = globalData.lobbyReady || {};
            const unready = players.filter(p => !readyObj[p]);
                if(unready.length) {
                showToast(`Noch nicht alle bereit: ${unready.join(', ')}`);
                return;
            }
            
            // Zeige Regeln beim ersten Start (fÃ¼r alle Spieler)
            if(!rulesShown) {
                const rulesOverlay = document.getElementById('rulesOverlay');
                if(rulesOverlay) {
                    rulesOverlay.style.display = 'flex';
                    // Warte auf SchlieÃŸen der Regeln
                    return;
                }
            }
            
            await applyIceCooling(globalData.players);
            const usedQuestions = globalData.usedQuestions || [];
            const { question: q, index: qIdx } = getRandomUnusedQuestion(usedQuestions);
            const nextRoundId = (globalData?.roundId ?? 0) + 1;
            const countdownEnds = Date.now() + 3000;
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'countdown',
                hotseat: players[0],
                currentQ: q,
                votes: {},
                ready: [],
                roundId: nextRoundId,
                countdownEnds,
                lobbyReady: {},
                usedQuestions: [...usedQuestions, qIdx]
            });
            setTimeout(() => {
                updateDoc(doc(db, "lobbies", roomId), { status: 'game', countdownEnds: null });
            }, 3300);
        };
        
        // Starte Spiel nach SchlieÃŸen der Regeln
        window.closeRulesOverlay = () => {
            const overlay = document.getElementById('rulesOverlay');
            if(overlay) {
                overlay.style.display = 'none';
                rulesShown = true;
                // Starte das Spiel nach SchlieÃŸen der Regeln
                if(isHost && globalData) {
                    startCountdownAfterRules();
                }
            }
        };
        
        async function startCountdownAfterRules() {
            await applyIceCooling(globalData.players);
            const usedQuestions = globalData.usedQuestions || [];
            const { question: q, index: qIdx } = getRandomUnusedQuestion(usedQuestions);
            const nextRoundId = (globalData?.roundId ?? 0) + 1;
            const countdownEnds = Date.now() + 3000;
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'countdown',
                hotseat: Object.keys(globalData.players)[0],
                currentQ: q,
                votes: {},
                ready: [],
                roundId: nextRoundId,
                countdownEnds,
                lobbyReady: {},
                usedQuestions: [...usedQuestions, qIdx]
            });
            setTimeout(() => {
                updateDoc(doc(db, "lobbies", roomId), { status: 'game', countdownEnds: null });
            }, 3300);
        }

        // --- NEXT ROUND ---
        window.nextRound = async () => {
            const maxTemp = globalData?.config?.maxTemp || 100;
            const activePlayers = Object.keys(globalData.players).filter(p => 
                (globalData.players[p].temp || 0) < maxTemp
            );
            
            if(activePlayers.length === 0) {
                // Fallback: Alle sind raus, nimm alle Spieler
                activePlayers.push(...Object.keys(globalData.players));
            }
            
            if(activePlayers.length === 1) {
                // Nur noch ein Spieler Ã¼brig - Gewinner!
                if(isHost) {
                    await updateDoc(doc(db, "lobbies", roomId), {
                        status: 'winner',
                        winner: activePlayers[0]
                    });
                }
                return;
            }
            
            const curr = globalData.hotseat;
            let nextIdx = activePlayers.indexOf(curr);
            if(nextIdx === -1) nextIdx = 0;
            nextIdx = (nextIdx + 1) % activePlayers.length;
            
            const usedQuestions = globalData.usedQuestions || [];
            const { question: q, index: qIdx } = getRandomUnusedQuestion(usedQuestions);
            const nextRoundId = (globalData?.roundId ?? 0) + 1;
            await applyIceCooling(globalData.players);
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'game',
                hotseat: activePlayers[nextIdx],
                currentQ: q,
                votes: {},
                ready: [],
                roundId: nextRoundId,
                usedQuestions: [...usedQuestions, qIdx],
                roundRecapShown: false
            });
        };

        // --- FORCE NEXT ROUND ---
        window.forceNextRound = async () => {
            if(!isHost) return;
            if(!confirm("MÃ¶chtest du wirklich zur nÃ¤chsten Runde springen?")) return;
            await nextRound();
            toggleMenu();
        };

        // --- RESET GAME ---
        window.resetGame = async () => {
            if(!isHost) return;
            if(!confirm("MÃ¶chtest du das Spiel wirklich neustarten? Alle Temperaturen werden zurÃ¼ckgesetzt.")) return;
            
            const pClean = {};
            Object.keys(globalData.players).forEach(p => {
                pClean[p] = {temp: 0, inventory: []};
            });
            
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'lobby', 
                players: pClean, 
                votes: {}, 
                ready: [], 
                log: [],
                hotseat: "",
                roundId: 0,
                lobbyReady: {},
                countdownEnds: null,
                usedQuestions: []
            });
            toggleMenu();
            document.body.classList.remove('final-mode');
        };

        // --- KILL LOBBY ---
        window.killLobby = async () => {
            if(!isHost) return;
            if(!confirm("Lobby wirklich lÃ¶schen? Alle Spieler werden ausgeworfen und die Lobby ist danach nicht mehr verfÃ¼gbar!")) return;
            const ref = doc(db, "lobbies", roomId);
            await updateDoc(ref, {
                status: 'closed',
                log: arrayUnion(`ğŸ›‘ ${myName} hat die Lobby beendet.`)
            });
            setTimeout(() => deleteDoc(ref), 1200);
        };

        // --- LEAVE LOBBY ---
        window.leaveLobby = () => {
            if(confirm("Lobby wirklich verlassen?")) {
                document.body.classList.remove('final-mode');
                sessionStorage.clear();
                location.reload();
            }
        };
        
        window.shareLobby = async () => {
            if(!roomId) {
                showToast("Kein aktiver Raum zum Teilen verfÃ¼gbar.");
                return;
            }
            const text = `ğŸ”¥ Hitzkopf-Code: ${roomId} â€“ komm in meine Lobby!`;
            try {
                if(navigator.share) {
                    await navigator.share({ title: "Hitzkopf Lobby", text, url: location.href });
                    showToast("Link erfolgreich geteilt!");
                } else if(navigator.clipboard) {
                    await navigator.clipboard.writeText(text);
                    showToast("Link kopiert! Teile ihn mit deinen Freunden.");
                } else {
                    prompt("Code kopieren:", text);
                }
            } catch (err) {
                console.warn(err);
                showToast("Teilen wurde abgebrochen.");
            }
        };

        window.rematchGame = async () => {
            if(!globalData) return;
            if(globalData.host !== myName) {
                showToast("Nur der Host kann eine Revanche starten.");
                return;
            }
            if(!confirm("MÃ¶chtest du eine Revanche starten? Alle Temperaturen werden zurÃ¼ckgesetzt.")) return;
            const pClean = {};
            Object.keys(globalData.players).forEach(p => {
                pClean[p] = { temp: 0, inventory: [] };
            });
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'lobby',
                players: pClean,
                votes: {},
                ready: [],
                log: arrayUnion("â™»ï¸ Revanche gestartet! Alle Temperaturen wurden zurÃ¼ckgesetzt."),
                hotseat: "",
                roundId: (globalData.roundId ?? 0) + 1,
                lobbyReady: {},
                countdownEnds: null,
                usedQuestions: []
            });
            document.body.classList.remove('final-mode');
            showToast("Revanche gestartet! Alle zurÃ¼ck in die Lobby.");
        };

        // --- RENDER HELPERS ---
        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        function renderGameOver(loser, players) {
            showScreen('screen-gameover');
            document.body.classList.add('final-mode');
            const nameEl = document.getElementById('lblLoser');
            const captionEl = document.getElementById('lblFinalText');
            const fillEl = document.getElementById('finalThermoFill');
            const emojiEl = document.getElementById('finalEmoji');
            const btnRematch = document.getElementById('btnRematch');
            nameEl.innerText = loser;
            captionEl.innerText = `${loser} hat 100Â°C erreicht â€“ ein echter Hitzkopf! ğŸ”¥`;
            if(emojiEl) emojiEl.innerText = 'ğŸ¥µ';
            if(fillEl) {
                fillEl.style.width = '0%';
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        const temp = Math.min(players[loser]?.temp ?? 120, 120);
                        fillEl.style.width = `${Math.min(temp, 120)}%`;
                    });
                });
            }
            const rankingEl = document.getElementById('finalRanking');
            if(rankingEl) {
                const survivors = Object.keys(players).filter(p => p !== loser)
                    .sort((a,b) => players[a].temp - players[b].temp);
                if(!survivors.length) {
                    rankingEl.innerHTML = `<div class="final-rank-item">Keine weiteren Spieler.</div>`;
                } else {
                    const coolest = survivors[0];
                    rankingEl.innerHTML = survivors.map((p, idx) => `
                        <div class="final-rank-item ${p === coolest ? 'coolest' : ''}">
                            <span>${idx + 1}. ${p}</span>
                            <span>${players[p].temp}Â°C ${p === coolest ? 'ğŸ§Š' : ''}</span>
                        </div>
                    `).join('');
                }
            if(btnRematch) {
                if(isHost) {
                    btnRematch.disabled = false;
                    btnRematch.innerText = "â™»ï¸ Revanche starten";
                } else {
                    btnRematch.disabled = true;
                    btnRematch.innerText = "â³ Host entscheidet...";
                }
            }
            }
        }

        function renderThermos(players, targetId) {
            const div = document.getElementById(targetId);
            if(!div) return;
            
            const order = Object.keys(players).sort((a,b) => players[b].temp - players[a].temp);
            let html = "";
            const newTemps = {};
            order.forEach((p, idx) => {
                const d = players[p];
                const percent = Math.min(d.temp, 100);
                let color = '#0f0';
                if(d.temp >= 80) color = '#ff4500';
                else if(d.temp >= 50) color = '#ff8c00';
                else if(d.temp >= 30) color = '#ffa500';
                
                const inventory = d.inventory?.length > 0 ? 
                    ` <span style="font-size:0.7rem;">ğŸ´${d.inventory.length}</span>` : '';
                const classes = ['thermo-item'];
                const isHotseat = globalData?.hotseat === p;
                if(idx === 0) classes.push('top-hot');
                if(isHotseat) classes.push('is-hotseat');
                if(targetId === 'gridGame' && lastTemps[p] != null && d.temp > lastTemps[p]) {
                    classes.push('shake');
                }
                const playerEmoji = d.emoji || 'ğŸ˜Š';
                const prefix = isHotseat ? 'ğŸ¥µ ' : (idx === 0 ? 'ğŸ”¥ ' : '');
                const nameLabel = `${prefix}${playerEmoji} ${p}${inventory}`;
                
                html += `
                    <div class="${classes.join(' ')}">
                        <div class="thermo-top">
                            <span>${nameLabel}</span>
                            <span>${d.temp}Â°C</span>
                        </div>
                        <div class="thermo-bar">
                            <div class="thermo-fill" style="width:${percent}%; background:${color}"></div>
                        </div>
                    </div>
                `;
                newTemps[p] = d.temp;
            });
            div.innerHTML = html;
            if(targetId === 'gridGame') {
                lastTemps = newTemps;
            }
        }

        function renderLog(log) {
            const el = document.getElementById('divLog');
            if(!el || !log) return;
            
            el.innerHTML = log.slice(-10).reverse().map(l => {
                let className = 'log-entry';
                if(l.includes('ğŸ”¥')) className += ' attack';
                return `<div class="${className}">${l}</div>`;
            }).join('');
            
            // Auto-scroll to top (newest)
            el.scrollTop = 0;
        }

        async function maybeLogRoundSummary(data, truthText, truthKey) {
            if(!isHost) return;
            if(data.roundId == null) return;
            if(loggedRoundResult === data.roundId) return;
            if(!truthKey) return;

            loggedRoundResult = data.roundId;
            const players = Object.keys(data.players).filter(p => p !== data.hotseat);
            const correct = players.filter(p => data.votes[p]?.choice === truthKey);
            const wrong = players.filter(p => !correct.includes(p));
            const entries = [
                `ğŸ§  Wahrheit (${data.hotseat}): ${truthText}`
            ];

            if(correct.length) {
                entries.push(`âœ… Richtige Spieler: ${correct.join(', ')}`);
                if(wrong.length) entries.push(`âŒ Daneben: ${wrong.join(', ')}`);
            } else {
                entries.push('âšª Niemand lag richtig â€“ keine Aktionen in dieser Runde.');
            }

            await updateDoc(doc(db, "lobbies", roomId), {
                log: arrayUnion(...entries)
            });
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            if(!toast) return;
            toast.innerText = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2500);
        }

        function renderMyJokers(targetId, playerData) {
            const container = document.getElementById(targetId);
            if(!container) return;
            const inventory = playerData?.inventory || [];
            const cards = Object.keys(cardInfo);
            container.innerHTML = cards.map(key => {
                const info = cardInfo[key];
                const has = inventory.includes(key);
                return `
                    <div class="joker-chip ${has ? 'has' : ''}">
                        <strong>${info.label}</strong>
                        <span>${info.desc}</span>
                    </div>
                `;
            }).join('');
        }

        async function applyIceCooling(players) {
            if(!players) return;
            const ref = doc(db, "lobbies", roomId);
            const coolValue = globalData?.config?.dmg || 10;
            for(const name of Object.keys(players)) {
                if(players[name].inventory?.includes('card_ice')) {
                    const reduction = Math.min(coolValue, players[name].temp);
                    await updateDoc(ref, {
                        [`players.${name}.temp`]: increment(-reduction),
                        [`players.${name}.inventory`]: arrayRemove('card_ice'),
                        log: arrayUnion(`ğŸ§Š ${name} kÃ¼hlt sich ab (-${reduction}Â°C)`)
                    });
                }
            }
        }

        function findLatestAttackOnMe(log = []) {
            if(!log || !Array.isArray(log)) return null;
            for(let i = log.length - 1; i >= 0; i--) {
                const entry = log[i];
                const match = entry?.match(/ğŸ”¥\s(.+?)\s+greift\s+(.+?)\san\s\(\+(\d+)Â°C\)/);
                if(match && match[2] === myName) {
                    return { attacker: match[1], dmg: parseInt(match[3], 10) || null };
                }
            }
            return null;
        }

        function triggerAttackFeedback(attacker, dmg) {
            const body = document.body;
            body.classList.add('viewport-shake');
            setTimeout(() => body.classList.remove('viewport-shake'), 600);

            const alert = document.getElementById('attackAlert');
            if(!alert) return;
            alert.innerText = `ğŸ”¥ ${attacker} hat dich aufgeheizt (+${dmg}Â°C)`;
            alert.classList.add('show');
            if(attackAlertTimer) clearTimeout(attackAlertTimer);
            attackAlertTimer = setTimeout(() => alert.classList.remove('show'), 2600);
        }

        function handleCountdownOverlay(data) {
            const overlay = document.getElementById('countdownOverlay');
            if(!overlay) return;
            if(data.status === 'countdown' && data.countdownEnds) {
                countdownTarget = data.countdownEnds;
                overlay.classList.add('show');
                startCountdownTicker();
            } else {
                overlay.classList.remove('show');
                stopCountdownTicker();
            }
        }

        function startCountdownTicker() {
            updateCountdownText();
            if(countdownInterval) clearInterval(countdownInterval);
            countdownInterval = setInterval(updateCountdownText, 250);
        }

        function stopCountdownTicker() {
            if(countdownInterval) clearInterval(countdownInterval);
            countdownInterval = null;
            countdownTarget = null;
        }

        function updateCountdownText() {
            if(!countdownTarget) return;
            const textEl = document.getElementById('countdownText');
            if(!textEl) return;
            const remainingMs = countdownTarget - Date.now();
            const seconds = Math.max(0, Math.ceil(remainingMs / 1000));
            if(seconds > 0) {
                textEl.innerHTML = seconds.toString();
            } else {
                textEl.innerHTML = "Hitz<br>kopf";
            }
        }

        // --- SPECTATOR MODE ---
        function showSpectatorMode() {
            const banner = document.getElementById('spectatorBanner');
            if(!banner) {
                const newBanner = document.createElement('div');
                newBanner.id = 'spectatorBanner';
                newBanner.className = 'spectator-banner';
                newBanner.innerText = 'ğŸ”¥ Du bist ein Hitzkopf! Bis zur nÃ¤chsten Runde bist du leider raus. Zeit abzukÃ¼hlen.';
                document.body.appendChild(newBanner);
            }
            document.body.classList.add('spectator-mode');
        }

        function hideSpectatorMode() {
            const banner = document.getElementById('spectatorBanner');
            if(banner) banner.remove();
            document.body.classList.remove('spectator-mode');
        }

        // --- ELIMINATION ANIMATION ---
        function showEliminationAnimation(playerName, temp) {
            const overlay = document.getElementById('fullscreenAnimation');
            if(!overlay) return;
            
            const emojiEl = document.getElementById('animEmoji');
            const nameEl = document.getElementById('animName');
            const textEl = document.getElementById('animText');
            const thermoEl = document.getElementById('animThermoFill');
            const tempEl = document.getElementById('animTemp');
            
            if(emojiEl) emojiEl.innerText = 'ğŸ¥µ';
            if(nameEl) nameEl.innerText = playerName;
            if(textEl) textEl.innerText = 'ist ein Hitzkopf und fliegt raus! ğŸ”¥';
            if(tempEl) tempEl.innerText = `${temp}Â°C`;
            
            overlay.style.display = 'flex';
            
            // Thermometer animieren
            if(thermoEl) {
                thermoEl.style.width = '0%';
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        thermoEl.style.width = `${Math.min(temp, 120)}%`;
                    });
                });
            }
            
            // Nach 3 Sekunden ausblenden
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 3000);
        }

        // --- RENDER WINNER ---
        function renderWinner(winnerName, players) {
            const nameEl = document.getElementById('winnerName');
            const emojiEl = document.getElementById('winnerEmoji');
            const tempEl = document.getElementById('winnerTemp');
            const thermoEl = document.getElementById('winnerThermoFill');
            const rankingEl = document.getElementById('rankingList');
            
            const winnerData = players[winnerName];
            const winnerEmoji = winnerData?.emoji || 'ğŸ˜';
            
            if(nameEl) nameEl.innerText = winnerName;
            if(emojiEl) emojiEl.innerText = winnerEmoji;
            const temp = winnerData?.temp || 0;
            if(tempEl) tempEl.innerText = `${temp}Â°C`;
            
            // Thermometer animieren
            if(thermoEl) {
                thermoEl.style.width = '0%';
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        thermoEl.style.width = `${Math.min((temp / 100) * 100, 100)}%`;
                    });
                });
            }
            
            // Ranking: Andere Spieler nach Reihenfolge des Rausfliegens
            const maxTemp = globalData?.config?.maxTemp || 100;
            const eliminated = Object.keys(players)
                .filter(p => p !== winnerName && (players[p].temp || 0) >= maxTemp)
                .sort((a, b) => (players[b].temp || 0) - (players[a].temp || 0)); // HÃ¶chste zuerst (zuletzt rausgeflogen)
            
            if(rankingEl && eliminated.length > 0) {
                rankingEl.innerHTML = eliminated.map((p, idx) => {
                    const playerData = players[p];
                    const playerEmoji = playerData?.emoji || 'ğŸ¥µ';
                    const playerTemp = playerData?.temp || 0;
                    return `
                        <div style="padding:12px; margin-bottom:8px; background:rgba(255,69,0,0.1); border:1px solid rgba(255,69,0,0.3); border-radius:10px; display:flex; justify-content:space-between; align-items:center;">
                            <div>
                                <span style="font-size:1.5rem; margin-right:10px;">${playerEmoji}</span>
                                <span style="font-size:1.1rem; font-weight:bold; color:#ff8c00;">${p}</span>
                            </div>
                            <div style="font-size:1rem; color:#ff4500; font-weight:bold;">${playerTemp}Â°C</div>
                        </div>
                    `;
                }).join('');
            } else if(rankingEl) {
                rankingEl.innerHTML = '<div style="text-align:center; color:#888; padding:20px;">Keine weiteren Spieler</div>';
            }
            
            // Konfetti starten
            startConfetti();
        }

        // --- CONFETTI ---
        function startConfetti() {
            const container = document.getElementById('confetti-container');
            if(!container) return;
            
            const colors = ['#ffd700', '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7'];
            
            for(let i = 0; i < 100; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
                    confetti.style.animationDelay = Math.random() * 0.5 + 's';
                    container.appendChild(confetti);
                    
                    setTimeout(() => confetti.remove(), 5000);
                }, i * 20);
            }
        }

        // --- RENDER VOTING ---
        function renderVoting(data) {
            const votingStatus = document.getElementById('votingStatus');
            const votingResults = document.getElementById('votingResults');
            const btnRematch = document.getElementById('btnVoteRematch');
            const btnLeave = document.getElementById('btnVoteLeave');
            
            const votes = data.rematchVotes || {};
            const players = Object.keys(data.players);
            const activePlayers = players.filter(p => (data.players[p].temp || 0) < (data.config?.maxTemp || 100));
            
            const rematchCount = activePlayers.filter(p => votes[p] === true).length;
            const leaveCount = activePlayers.filter(p => votes[p] === false).length;
            const totalVotes = rematchCount + leaveCount;
            
            if(votingStatus) {
                votingStatus.innerText = `Abgestimmt: ${totalVotes}/${activePlayers.length}`;
            }
            
            if(votingResults) {
                votingResults.innerHTML = `
                    <div style="margin-bottom:10px;">âœ… Nochmal spielen: ${rematchCount}</div>
                    <div>ğŸšª Verlassen: ${leaveCount}</div>
                `;
            }
            
            // Buttons deaktivieren wenn bereits abgestimmt
            if(votes[myName] !== undefined) {
                if(btnRematch) btnRematch.disabled = true;
                if(btnLeave) btnLeave.disabled = true;
                if(votes[myName]) {
                    if(btnRematch) btnRematch.innerText = 'âœ… GewÃ¤hlt';
                    if(btnLeave) btnLeave.innerText = 'ğŸšª Verlassen';
                } else {
                    if(btnRematch) btnRematch.innerText = 'âœ… Nochmal spielen';
                    if(btnLeave) btnLeave.innerText = 'ğŸšª GewÃ¤hlt';
                }
            } else {
                if(btnRematch) btnRematch.disabled = false;
                if(btnLeave) btnLeave.disabled = false;
            }
            
            // Host kann Spiel starten wenn alle fÃ¼r Rematch gestimmt haben
            if(isHost && totalVotes === activePlayers.length && rematchCount === activePlayers.length) {
                const startBtn = document.createElement('button');
                startBtn.className = 'btn-primary';
                startBtn.style.cssText = 'width:100%; margin-top:20px; padding:15px; font-size:1.2rem;';
                startBtn.innerText = 'ğŸ® Neue Runde starten';
                startBtn.onclick = startRematchGame;
                if(!document.getElementById('btnStartRematch')) {
                    startBtn.id = 'btnStartRematch';
                    const votingCard = document.getElementById('screen-voting');
                    if(votingCard) votingCard.appendChild(startBtn);
                }
            }
        }

        // --- VOTE REMATCH ---
        window.voteRematch = async (wantRematch) => {
            await updateDoc(doc(db, "lobbies", roomId), {
                [`rematchVotes.${myName}`]: wantRematch
            });
        };

        // --- START REMATCH ---
        window.startRematchGame = async () => {
            if(!isHost) return;
            const pClean = {};
            Object.keys(globalData.players).forEach(p => {
                const startTemp = globalData.config?.startTemp || 0;
                pClean[p] = { temp: startTemp, inventory: [], gender: globalData.players[p].gender || 'divers' };
            });
            
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'lobby',
                players: pClean,
                votes: {},
                ready: [],
                log: arrayUnion("â™»ï¸ Neue Runde gestartet! Alle Temperaturen wurden zurÃ¼ckgesetzt."),
                hotseat: "",
                roundId: 0,
                lobbyReady: {},
                countdownEnds: null,
                usedQuestions: [],
                rematchVotes: {},
                eliminatedShown: [],
                winner: null
            });
            document.body.classList.remove('final-mode');
            showToast("Neue Runde gestartet!");
        };

        // --- SHOW ATTACK ANIMATION ---
        async function showAttackAnimation(targetName, attackerName, dmg, newTemp) {
            const overlay = document.getElementById('fullscreenAnimation');
            if(!overlay) return;
            
            const emojiEl = document.getElementById('animEmoji');
            const nameEl = document.getElementById('animName');
            const textEl = document.getElementById('animText');
            const thermoEl = document.getElementById('animThermoFill');
            const tempEl = document.getElementById('animTemp');
            
            if(emojiEl) emojiEl.innerText = 'ğŸ”¥';
            if(nameEl) nameEl.innerText = targetName;
            if(textEl) textEl.innerText = `${attackerName} hat ${targetName} aufgeheizt (+${dmg}Â°C)`;
            if(tempEl) tempEl.innerText = `${newTemp}Â°C`;
            
            overlay.style.display = 'flex';
            
            // Thermometer animieren
            if(thermoEl) {
                thermoEl.style.width = '0%';
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        thermoEl.style.width = `${Math.min((newTemp / 100) * 100, 100)}%`;
                    });
                });
            }
            
            // Nach 3 Sekunden ausblenden
            await sleep(3000);
            overlay.style.display = 'none';
        }

        // --- SHOW JOKER ANIMATION ---
        async function showJokerAnimation(playerName, cardName) {
            const overlay = document.getElementById('fullscreenAnimation');
            if(!overlay) return;
            
            const emojiEl = document.getElementById('animEmoji');
            const nameEl = document.getElementById('animName');
            const textEl = document.getElementById('animText');
            const thermoEl = document.getElementById('animThermoFill');
            const tempEl = document.getElementById('animTemp');
            
            const cardInfo = {
                card_oil: { emoji: 'ğŸ›¢ï¸', name: 'Ã–lfass' },
                card_mirror: { emoji: 'ğŸª', name: 'Spiegel' },
                card_ice: { emoji: 'ğŸ§Š', name: 'EiswÃ¼rfel' }
            };
            
            const info = cardInfo[cardName] || { emoji: 'ğŸƒ', name: 'Joker' };
            
            if(emojiEl) emojiEl.innerText = info.emoji;
            if(nameEl) nameEl.innerText = playerName;
            if(textEl) textEl.innerText = `hat einen Joker gezogen: ${info.name} - Aufgepasst! ğŸƒ`;
            if(tempEl) tempEl.innerText = '';
            
            overlay.style.display = 'flex';
            
            // Thermometer ausblenden
            if(thermoEl) thermoEl.style.width = '0%';
            
            // Nach 3 Sekunden ausblenden
            await sleep(3000);
            overlay.style.display = 'none';
        }

    </script>
</body>
</html>
