<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hitzkopf üî•15</title>
    <style>
        * { 
            box-sizing: border-box; 
            margin: 0; 
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }
        
        :root {
            --primary: #ff6b35;
            --primary-dark: #e55a2b;
            --primary-light: #ff8c69;
            --secondary: #4ecdc4;
            --success: #51cf66;
            --danger: #ff6b6b;
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --glass-bg: rgba(22, 27, 34, 0.8);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.4);
            --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.5);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.6);
            --shadow-xl: 0 12px 48px rgba(0, 0, 0, 0.7);
            --shadow-glow: 0 0 24px rgba(255, 107, 53, 0.4);
        }
        
        @supports (padding: max(0px)) {
            body {
                padding-left: max(15px, env(safe-area-inset-left));
                padding-right: max(15px, env(safe-area-inset-right));
                padding-top: max(15px, env(safe-area-inset-top));
                padding-bottom: max(80px, env(safe-area-inset-bottom));
            }
        }
        
        body { 
            background: linear-gradient(135deg, #0d1117 0%, #161b22 50%, #0d1117 100%);
            background-attachment: fixed;
            color: var(--text-primary); 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-align: center; 
            padding: 15px; 
            padding-bottom: 80px;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(255, 107, 53, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(78, 205, 196, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }
        
        h1 { 
            color: var(--primary); 
            margin: 0 0 20px 0; 
            text-shadow: 0 0 20px rgba(255, 107, 53, 0.6), 0 4px 8px rgba(0, 0, 0, 0.5); 
            font-size: clamp(1.75rem, 5vw, 2.5rem); 
            font-weight: 800;
            letter-spacing: -0.02em;
            position: relative;
            z-index: 1;
        }
        
        .screen { 
            display: none; 
            animation: fadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 1;
        }
        .screen.active { display: block; }
        
        .card { 
            background: var(--glass-bg);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            padding: 24px; 
            border-radius: 24px; 
            max-width: 480px; 
            margin: 0 auto 20px auto; 
            box-shadow: var(--shadow-lg), inset 0 1px 0 rgba(255, 255, 255, 0.05); 
            border: 1px solid var(--glass-border);
            position: relative;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.3s ease;
        }
        
        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            border-radius: 24px 24px 0 0;
        }
        
        input, select { 
            width: 100%; 
            padding: 16px 20px; 
            margin: 12px 0; 
            border-radius: 16px; 
            border: 1.5px solid var(--glass-border); 
            background: rgba(22, 27, 34, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: var(--text-primary); 
            font-size: 16px; 
            font-weight: 500;
            text-align: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-sm), inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }
        input:focus, select:focus { 
            outline: none; 
            border-color: var(--primary); 
            background: rgba(255, 107, 53, 0.1);
            box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.2), var(--shadow-md);
            transform: translateY(-1px);
        }
        
        button { 
            width: 100%; 
            padding: 18px 24px; 
            margin: 12px 0; 
            border: none; 
            border-radius: 16px; 
            font-size: 17px; 
            font-weight: 600;
            letter-spacing: 0.01em;
            cursor: pointer; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            min-height: 56px; /* Touch-friendly */
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        button:active:not(:disabled)::before {
            width: 300px;
            height: 300px;
        }
        
        button:hover:not(:disabled) { 
            transform: translateY(-2px); 
            box-shadow: var(--shadow-lg);
        }
        button:active:not(:disabled) { 
            transform: translateY(0) scale(0.98); 
        }
        button:disabled { 
            opacity: 0.5; 
            cursor: not-allowed;
            transform: none !important;
        }
        
        .btn-primary { 
            background: linear-gradient(135deg, var(--primary), var(--primary-dark)); 
            color: white;
            box-shadow: var(--shadow-md), var(--shadow-glow);
        }
        .btn-primary:hover:not(:disabled) {
            box-shadow: var(--shadow-xl), 0 0 32px rgba(255, 107, 53, 0.5);
        }
        
        .btn-secondary { 
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1.5px solid var(--glass-border);
            color: var(--text-primary); 
            box-shadow: var(--shadow-sm);
        }
        .btn-secondary:hover:not(:disabled) {
            border-color: rgba(255, 255, 255, 0.2);
            background: rgba(22, 27, 34, 0.9);
        }
        
        .btn-danger { 
            background: linear-gradient(135deg, var(--danger), #e55a5a); 
            color: white; 
            font-size: 15px; 
            padding: 14px 20px;
            box-shadow: var(--shadow-md), 0 0 20px rgba(255, 107, 107, 0.3);
        }
        
        .btn-ready { 
            background: linear-gradient(135deg, var(--success), #40c057); 
            color: white; 
            margin-top: 20px;
            box-shadow: var(--shadow-md), 0 0 24px rgba(81, 207, 102, 0.4);
        }
        .btn-ready:hover:not(:disabled) {
            box-shadow: var(--shadow-xl), 0 0 32px rgba(81, 207, 102, 0.5);
        }
        .btn-ready:disabled { 
            background: rgba(30, 94, 40, 0.5); 
            opacity: 0.6; 
            cursor: not-allowed;
            box-shadow: none;
        }

        .thermo-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            gap: 16px; 
            margin-bottom: 24px;
        }
        .thermo-item { 
            background: var(--glass-bg);
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            padding: 16px; 
            border-radius: 20px; 
            text-align: left; 
            border: 1.5px solid var(--glass-border);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-md), inset 0 1px 0 rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
        }
        .thermo-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        }
        .thermo-item:hover { 
            transform: translateY(-4px); 
            box-shadow: var(--shadow-lg);
            border-color: rgba(255, 255, 255, 0.15);
        }
        .thermo-item.top-hot { 
            border-color: var(--primary); 
            box-shadow: var(--shadow-md), 0 0 24px rgba(255, 107, 53, 0.4);
        }
        .thermo-item.is-hotseat { 
            border-color: var(--secondary); 
            box-shadow: var(--shadow-md), 0 0 28px rgba(78, 205, 196, 0.5);
        }
        .thermo-top { 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            font-size: 0.95rem; 
            font-weight: 600; 
            margin-bottom: 12px;
            color: var(--text-primary);
        }
        .thermo-bar { 
            height: 10px; 
            background: rgba(0, 0, 0, 0.4); 
            border-radius: 8px; 
            overflow: hidden;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.6);
            position: relative;
        }
        .thermo-fill { 
            height: 100%; 
            width: 0%; 
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 16px currentColor, inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
        }
        .thermo-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .option-row { display: flex; gap: 16px; margin-top: 24px; }
        .btn-option { 
            flex: 1; 
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 2px solid var(--glass-border); 
            padding: 24px 16px; 
            font-size: 1.1rem; 
            font-weight: 600;
            color: var(--text-primary);
            border-radius: 20px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-sm);
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn-option:hover { 
            border-color: rgba(255, 255, 255, 0.2);
            background: rgba(22, 27, 34, 0.9);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        .btn-option.selected { 
            border-color: var(--primary); 
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.2), rgba(255, 107, 53, 0.1));
            color: var(--primary);
            box-shadow: var(--shadow-md), var(--shadow-glow);
            transform: translateY(-2px);
        }
        
        .category-card {
            aspect-ratio: 1;
            background: var(--glass-bg);
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            border: 2px solid var(--glass-border);
            border-radius: 20px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            opacity: 0.5;
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
        }
        .category-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        }
        .category-card:hover {
            opacity: 0.8;
            transform: translateY(-4px) scale(1.02);
            box-shadow: var(--shadow-md);
            border-color: rgba(255, 255, 255, 0.15);
        }
        .category-card.selected {
            opacity: 1;
            border-color: var(--primary);
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.25), rgba(255, 107, 53, 0.1));
            box-shadow: var(--shadow-lg), var(--shadow-glow);
            transform: translateY(-2px) scale(1.03);
        }
        .category-card.selected:hover {
            opacity: 1;
            transform: translateY(-4px) scale(1.05);
        }
        .category-card .category-emoji {
            font-size: 2.5rem;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
            transition: transform 0.3s ease;
        }
        .category-card.selected .category-emoji {
            transform: scale(1.1);
        }
        .category-card .category-name {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            letter-spacing: 0.01em;
        }
        .category-card.selected .category-name {
            color: var(--text-primary);
            font-weight: 700;
        }
        
        /* Angriffsziele-Karten (√§hnlich wie Kategorien-Karten) */
        .target-card {
            aspect-ratio: 1;
            background: var(--glass-bg);
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            border: 2px solid var(--glass-border);
            border-radius: 20px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
        }
        
        .target-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        }
        
        .target-card:hover {
            border-color: var(--primary);
            transform: translateY(-4px) scale(1.02);
            box-shadow: var(--shadow-md), 0 0 24px rgba(255, 107, 53, 0.3);
        }
        
        .target-card.selected {
            border-color: var(--primary);
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.25), rgba(255, 107, 53, 0.1));
            box-shadow: var(--shadow-lg), var(--shadow-glow);
            transform: translateY(-2px) scale(1.03);
        }
        
        .target-card .target-emoji {
            font-size: 3rem;
            margin-bottom: 6px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
            transition: transform 0.3s ease;
        }
        
        .target-card.selected .target-emoji {
            transform: scale(1.1);
        }
        
        .target-card .target-name {
            font-size: 0.95rem;
            color: var(--text-primary);
            font-weight: 600;
            margin-bottom: 4px;
            text-align: center;
        }
        
        .target-card .target-dmg {
            font-size: 0.8rem;
            color: var(--primary);
            font-weight: 700;
            text-align: center;
        }
        
        .game-mode-card {
            aspect-ratio: 1;
            background: var(--glass-bg);
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            border: 2px solid var(--glass-border);
            border-radius: 20px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
        }
        
        .game-mode-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        }
        
        .game-mode-card:hover {
            border-color: rgba(255, 255, 255, 0.2);
            background: rgba(22, 27, 34, 0.9);
            transform: translateY(-4px) scale(1.02);
            box-shadow: var(--shadow-md);
        }
        .game-mode-card.selected {
            border-color: var(--primary);
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.25), rgba(255, 107, 53, 0.1));
            box-shadow: var(--shadow-lg), var(--shadow-glow);
            transform: translateY(-2px) scale(1.03);
        }
        .game-mode-card .mode-emoji {
            font-size: 2.5rem;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
            transition: transform 0.3s ease;
        }
        .game-mode-card.selected .mode-emoji {
            transform: scale(1.1);
        }
        .game-mode-card .mode-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        .game-mode-card.selected .mode-name {
            color: var(--primary);
            font-weight: 700;
        }

        .log-box { 
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1.5px solid var(--glass-border); 
            border-radius: 20px; 
            height: 180px; 
            overflow-y: auto; 
            padding: 16px; 
            margin-top: 20px; 
            text-align: left; 
            font-size: 0.875rem; 
            display: flex; 
            flex-direction: column; 
            gap: 10px;
            box-shadow: var(--shadow-sm), inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }
        .log-box::-webkit-scrollbar { width: 8px; }
        .log-box::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.2); border-radius: 4px; }
        .log-box::-webkit-scrollbar-thumb { 
            background: rgba(255, 255, 255, 0.2); 
            border-radius: 4px; 
            transition: background 0.3s;
        }
        .log-box::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.3); }
        
        .log-entry { 
            padding: 12px 16px; 
            border-radius: 12px; 
            background: rgba(22, 27, 34, 0.6);
            border-left: 3px solid var(--glass-border);
            animation: slideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            transition: all 0.3s ease;
            font-weight: 500;
        }
        .log-entry:hover {
            background: rgba(22, 27, 34, 0.8);
            transform: translateX(4px);
        }
        .log-entry.attack { 
            border-left-color: var(--primary);
            background: rgba(255, 107, 53, 0.1);
        }
        
        .menu-btn { 
            position: fixed; 
            top: max(15px, env(safe-area-inset-top));
            right: max(15px, env(safe-area-inset-right));
            width: 56px; 
            height: 56px; 
            background: var(--glass-bg);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border-radius: 18px; 
            border: 1.5px solid var(--glass-border); 
            z-index: 3000; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-lg);
            pointer-events: auto;
        }
        .menu-btn:hover { 
            transform: rotate(90deg) scale(1.05); 
            border-color: var(--primary);
            box-shadow: var(--shadow-xl), var(--shadow-glow);
        }
        .menu-btn:active {
            transform: rotate(90deg) scale(0.95);
        }
        
        .admin-drawer { 
            position: fixed; 
            top: 0;
            right: -320px; 
            width: min(320px, 85vw);
            height: 100%; 
            background: var(--glass-bg);
            backdrop-filter: blur(30px) saturate(180%);
            -webkit-backdrop-filter: blur(30px) saturate(180%);
            border-left: 1.5px solid var(--glass-border); 
            z-index: 2001; 
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 24px; 
            text-align: left; 
            box-shadow: var(--shadow-xl);
            overflow-y: auto;
        }
        .admin-drawer.open { 
            right: 0;
        }
        .admin-drawer::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        }
        
        .overlay { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0, 0, 0, 0.75); 
            z-index: 1999; 
            display: none;
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            animation: fadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .overlay.open { 
            display: block; 
        }

        .hidden { display: none !important; }

        .card-select-btn {
            font-size: 1rem;
            padding: 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1.5px solid var(--glass-border);
            border-radius: 20px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            gap: 8px;
            color: var(--text-primary);
            box-shadow: var(--shadow-sm);
        }
        .card-select-btn strong { 
            font-size: 1.25rem;
            font-weight: 700;
        }
        .card-select-btn span { 
            font-size: 0.875rem; 
            color: var(--text-secondary); 
        }
        .card-select-btn:hover { 
            border-color: var(--primary);
            transform: translateY(-4px);
            box-shadow: var(--shadow-md), 0 0 24px rgba(255, 107, 53, 0.3);
        }

        .start-actions { 
            display: flex; 
            gap: 16px; 
            margin-top: 20px; 
        }
        .start-actions button { 
            flex: 1; 
        }
        .start-panel { 
            margin-top: 20px; 
            padding: 20px; 
            border: 1.5px solid var(--glass-border); 
            border-radius: 20px; 
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: var(--shadow-sm);
        }
        .share-btn { 
            margin-top: 20px; 
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1.5px solid var(--glass-border);
            color: var(--text-primary); 
            font-size: 15px; 
        }
        .toast { 
            position: fixed; 
            bottom: -100px;
            left: 50%; 
            transform: translateX(-50%); 
            background: var(--glass-bg);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            padding: 16px 24px; 
            border-radius: 24px; 
            border: 1.5px solid var(--glass-border);
            color: var(--text-primary); 
            box-shadow: var(--shadow-xl); 
            transition: bottom 0.4s cubic-bezier(0.4, 0, 0.2, 1), transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease; 
            z-index: 3000;
            font-weight: 500;
            opacity: 0;
            max-width: 90vw;
        }
        .toast.show { 
            bottom: max(25px, env(safe-area-inset-bottom) + 25px);
            opacity: 1;
        }
        .attack-alert {
            position: fixed;
            top: max(20px, env(safe-area-inset-top) + 20px);
            left: 50%;
            transform: translateX(-50%) translateY(-150%);
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            border: 1.5px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 16px 28px;
            border-radius: 32px;
            font-size: 15px;
            font-weight: 600;
            box-shadow: var(--shadow-xl), var(--shadow-glow);
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.5s ease;
            opacity: 0;
            z-index: 2500;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        .attack-alert.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        #hotseatAlert {
            border-radius: 24px;
            padding: 32px 40px;
            max-width: min(400px, 90vw);
            text-align: center;
            background: var(--glass-bg);
            backdrop-filter: blur(30px) saturate(180%);
            -webkit-backdrop-filter: blur(30px) saturate(180%);
            border: 1.5px solid var(--glass-border);
            box-shadow: var(--shadow-xl);
        }
        #hotseatAlert button {
            margin-top: 20px;
            padding: 16px 36px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1.5px solid rgba(255, 255, 255, 0.3);
            border-radius: 24px;
            color: #fff;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-sm);
        }
        #hotseatAlert button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px) scale(1.02);
            box-shadow: var(--shadow-md);
        }
        body.viewport-shake {
            animation: screenShake 0.6s cubic-bezier(.36,.07,.19,.97) !important;
        }
        @keyframes screenShake {
            0%, 100% { transform: translate3d(0, 0, 0); }
            10%, 90% { transform: translate3d(-4px, 0, 0); }
            20%, 80% { transform: translate3d(5px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-8px, 0, 0); }
            40%, 60% { transform: translate3d(8px, 0, 0); }
        }
        .joker-panel {
            margin-top: 24px;
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1.5px solid var(--glass-border);
            border-radius: 20px;
            padding: 20px;
            box-shadow: var(--shadow-sm);
        }
        .joker-panel h4 {
            margin-bottom: 12px;
            font-size: 1rem;
            font-weight: 600;
            color: var(--primary-light);
            letter-spacing: 0.01em;
        }
        .joker-strip {
            display: flex;
            gap: 12px;
            justify-content: space-between;
        }
        .joker-chip {
            flex: 1;
            border: 2px dashed var(--glass-border);
            border-radius: 16px;
            padding: 12px;
            font-size: 0.875rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
            opacity: 0.5;
            background: rgba(0, 0, 0, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .joker-chip strong {
            font-size: 1.4rem;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        .joker-chip.has {
            border-style: solid;
            border-color: var(--primary);
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.2), rgba(255, 107, 53, 0.1));
            color: var(--text-primary);
            opacity: 1;
            box-shadow: var(--shadow-md), 0 0 20px rgba(255, 140, 0, 0.3);
            transform: translateY(-2px);
        }
        .joker-chip span {
            font-size: 0.8rem;
            text-align: center;
            color: inherit;
            font-weight: 500;
        }
        .countdown-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 4000;
            animation: fadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .countdown-overlay.show { 
            display: flex; 
        }
        .countdown-text {
            font-size: clamp(4rem, 20vw, 8rem);
            font-weight: 900;
            color: var(--primary);
            text-shadow: 0 0 40px rgba(255, 107, 53, 0.8), 0 0 80px rgba(255, 107, 53, 0.4);
            animation: pulse 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            letter-spacing: -0.02em;
        }
        .countdown-sub {
            margin-top: 16px;
            font-size: clamp(1rem, 4vw, 1.5rem);
            color: var(--text-primary);
            letter-spacing: 0.3em;
            font-weight: 600;
            opacity: 0.9;
        }
        @keyframes pulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 1;
            }
            50% { 
                transform: scale(1.1);
                opacity: 0.9;
            }
        }
        body.final-mode {
            animation: finalPulse 2s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            background: radial-gradient(circle at center, rgba(255, 107, 53, 0.2), var(--bg-primary) 70%);
        }
        @keyframes finalPulse {
            0%, 100% { 
                background: radial-gradient(circle at center, rgba(255, 107, 53, 0.2), var(--bg-primary) 70%);
            }
            50% { 
                background: radial-gradient(circle at center, rgba(255, 107, 53, 0.3), var(--bg-primary) 70%);
            }
        }
        .final-card {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.3), rgba(255, 107, 53, 0.1));
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 2px solid var(--primary);
            box-shadow: var(--shadow-xl), var(--shadow-glow);
        }
        .final-hero {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
            margin-bottom: 24px;
        }
        .final-emoji {
            font-size: clamp(4rem, 15vw, 6rem);
            animation: sweatShake 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            filter: drop-shadow(0 4px 12px rgba(255, 107, 53, 0.5));
        }
        @keyframes sweatShake {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-6px) rotate(-2deg); }
            50% { transform: translateY(4px) rotate(2deg); }
            75% { transform: translateY(-3px) rotate(-1deg); }
        }
        .final-name {
            font-size: clamp(1.5rem, 8vw, 2.5rem);
            font-weight: 800;
            color: var(--primary-light);
            text-shadow: 0 0 24px rgba(255, 140, 53, 0.8), 0 4px 8px rgba(0, 0, 0, 0.5);
            letter-spacing: -0.02em;
        }
        .final-caption {
            margin-top: 12px;
            font-size: clamp(0.9rem, 3vw, 1.1rem);
            color: rgba(255, 214, 193, 0.9);
            font-weight: 500;
        }
        .final-thermo {
            margin: 24px auto;
            width: 85%;
        }
        .final-thermo-track {
            height: 24px;
            border-radius: 12px;
            background: rgba(40, 0, 0, 0.6);
            overflow: hidden;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.8), var(--shadow-sm);
            border: 1px solid rgba(255, 107, 53, 0.2);
        }
        .final-thermo-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--primary-light), var(--primary));
            box-shadow: 0 0 24px rgba(255, 107, 53, 0.8), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transition: width 1.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }
        .final-thermo-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: shimmer 2s infinite;
        }
        .final-ranking {
            margin-top: 28px;
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .final-rank-item {
            padding: 14px 18px;
            border-radius: 16px;
            border: 1.5px solid var(--glass-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            font-size: 0.95rem;
            font-weight: 500;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
        }
        .final-rank-item:hover {
            transform: translateX(4px);
            box-shadow: var(--shadow-md);
        }
        .final-rank-item.coolest {
            border-color: var(--secondary);
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(78, 205, 196, 0.1));
            box-shadow: var(--shadow-md), 0 0 24px rgba(78, 205, 196, 0.4);
            color: var(--text-primary);
        }
        .final-rank-item span {
            color: var(--text-secondary);
            font-weight: 600;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ffd700;
            position: absolute;
            animation: confetti-fall linear forwards;
        }
        @keyframes confetti-fall {
            to {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        .spectator-mode {
            opacity: 0.6;
            pointer-events: none;
        }
        .spectator-mode .menu-btn {
            pointer-events: auto !important;
            opacity: 1 !important;
        }
        
        .emoji-card {
            aspect-ratio: 1;
            min-width: 80px;
            width: 80px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 2px solid var(--glass-border);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            flex-shrink: 0;
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
        }
        .emoji-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        }
        .emoji-card.selected {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.3), rgba(255, 107, 53, 0.15));
            border-color: var(--primary);
            box-shadow: var(--shadow-lg), var(--shadow-glow);
            transform: scale(1.15);
        }
        .emoji-card:hover {
            background: rgba(22, 27, 34, 0.8);
            border-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.08);
            box-shadow: var(--shadow-md);
        }
        
        #emojiGallery {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 12px 0;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
            position: relative;
        }
        
        /* Spacer-Elemente f√ºr zentriertes Scrollen */
        .emoji-spacer {
            flex-shrink: 0;
            width: calc(50% - 40px);
            min-width: calc(50% - 40px);
            pointer-events: none;
        }
        .emoji-gallery-wrapper {
            position: relative;
        }
        .emoji-gallery-wrapper::after {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 50%;
            background: linear-gradient(to right, transparent, var(--bg-primary));
            pointer-events: none;
            z-index: 10;
        }
        #emojiGallery::-webkit-scrollbar {
            height: 8px;
        }
        #emojiGallery::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        #emojiGallery::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            transition: background 0.3s;
        }
        #emojiGallery::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .spectator-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 3000;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            padding: 16px;
            text-align: center;
            font-weight: 700;
            font-size: 15px;
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        @keyframes fadeIn { 
            from { 
                opacity: 0; 
                transform: translateY(20px) scale(0.95); 
            } 
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            } 
        }
        @keyframes slideIn {
            from { 
                opacity: 0; 
                transform: translateX(-20px); 
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
            }
        }
        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 
            10%, 90% { transform: translate3d(-2px, 0, 0); } 
            20%, 80% { transform: translate3d(3px, 0, 0); } 
            30%, 50%, 70% { transform: translate3d(-5px, 0, 0); } 
            40%, 60% { transform: translate3d(5px, 0, 0); } 
        }
    </style>
</head>
<body>
    <div class="menu-btn" onclick="toggleMenu()">‚öôÔ∏è</div>
    <div id="attackAlert" class="attack-alert"></div>
    <div id="hotseatAlert" class="attack-alert"></div>
    <!-- Attack Modal -->
    <div id="attackModal" class="countdown-overlay" style="display:none;">
        <div id="attackModalContainer" style="background:linear-gradient(145deg, #1e1e1e, #252525); padding:40px; border-radius:20px; max-width:500px; margin:20px; border:2px solid #ff4500; box-shadow:0 8px 32px rgba(0,0,0,0.8); text-align:center;">
            <div id="attackModalEmoji" style="font-size:5rem; margin-bottom:20px;">üî•</div>
            <div id="attackModalName" style="font-size:2.5rem; font-weight:800; color:#ff4500; margin-bottom:15px; text-shadow:0 0 18px rgba(255,69,0,0.6);">...</div>
            <div id="attackModalText" style="font-size:1.2rem; color:#fff; margin-bottom:15px;">...</div>
            <div id="attackModalDetails" style="font-size:0.9rem; color:#aaa; margin-bottom:25px; text-align:left; max-width:80%; margin-left:auto; margin-right:auto;">
                <!-- Wird dynamisch gef√ºllt -->
            </div>
            <div style="width:80%; margin:0 auto 20px auto;">
                <div style="height:25px; border-radius:12px; background:#280000; overflow:hidden; box-shadow:inset 0 0 10px rgba(0,0,0,0.7);">
                    <div id="attackModalThermoFill" style="height:100%; width:0%; background:linear-gradient(90deg, #ffae00, #ff0000); box-shadow:0 0 20px rgba(255,0,0,0.7); transition:width 1.2s ease-out;"></div>
                </div>
                <div id="attackModalTemp" style="font-size:1.5rem; font-weight:bold; color:#ff4500; margin-top:10px;">0¬∞C</div>
            </div>
            <button onclick="closeAttackModal()" class="btn-primary" style="margin-top:20px; padding:15px 30px; font-size:1.1rem;">Verstanden</button>
        </div>
    </div>
    <!-- Hotseat Modal -->
    <div id="hotseatModal" class="countdown-overlay" style="display:none;">
        <div style="background:linear-gradient(145deg, #1e1e1e, #252525); padding:40px; border-radius:20px; max-width:500px; margin:20px; border:2px solid #ff4500; box-shadow:0 8px 32px rgba(0,0,0,0.8); text-align:center;">
            <div id="hotseatModalEmoji" style="font-size:5rem; margin-bottom:20px;">üéØ</div>
            <div id="hotseatModalName" style="font-size:2.5rem; font-weight:800; color:#ff4500; margin-bottom:15px; text-shadow:0 0 18px rgba(255,69,0,0.6);">...</div>
            <div id="hotseatModalText" style="font-size:1.2rem; color:#fff; margin-bottom:25px;">...</div>
            <button onclick="closeHotseatModal()" class="btn-primary" style="margin-top:20px; padding:15px 30px; font-size:1.1rem;">Los geht's</button>
        </div>
    </div>
    <div id="countdownOverlay" class="countdown-overlay">
        <div id="countdownText" class="countdown-text" style="font-size:4rem; line-height:1.2;">Hitz<br>kopf</div>
        <div class="countdown-sub">Bereit machen...</div>
    </div>
    <!-- ANLEITUNG OVERLAY -->
    <div id="rulesOverlay" class="countdown-overlay" style="display:none;">
        <div style="background:linear-gradient(145deg, #1e1e1e, #252525); padding:30px; border-radius:20px; max-width:500px; margin:20px; border:2px solid #ff4500; box-shadow:0 8px 32px rgba(0,0,0,0.8);">
            <h2 style="color:#ff4500; margin-bottom:20px; font-size:1.8rem;">üìñ Anleitung</h2>
            <div style="text-align:left; font-size:1rem; line-height:1.6; color:#fff; margin-bottom:25px;">
                <p style="margin-bottom:12px;">üéØ <strong>Ziel:</strong> Errate die Antworten deiner Freunde und bringe sie zum kochen!</p>
                <p style="margin-bottom:12px;">üî• <strong>Verlierer:</strong> Wer als erstes 100¬∞ erreicht, fliegt raus.</p>
                <p style="margin-bottom:12px;">üßä <strong>Gewinner:</strong> Bewahrst du einen k√ºhlen Kopf, entscheidest du das Spiel f√ºr dich.</p>
            </div>
            <button onclick="closeRulesOverlay()" class="btn-primary" style="width:100%; padding:15px; font-size:1.1rem;">Verstanden ‚úì</button>
        </div>
    </div>
    <div class="overlay" id="menuOverlay" onclick="toggleMenu()"></div>
    <div class="admin-drawer" id="adminDrawer">
        <h3 style="color:#ff4500; border-bottom:2px solid #333; padding-bottom:12px; margin-bottom:15px;">‚öôÔ∏è Men√º</h3>
        
        <div id="hostControls" style="display:none;">
            <p style="font-size:0.75rem; color:#888; margin-bottom:8px; text-transform:uppercase;">Host-Steuerung:</p>
            <button style="padding:12px; font-size:0.85rem; margin:8px 0; background:#333; border-radius:8px;" onclick="forceNextRound()">‚è© Runde erzwingen</button>
            <button style="padding:12px; font-size:0.85rem; margin:8px 0; background:#550000; border-radius:8px;" onclick="resetGame()">üîÑ Spiel neustarten</button>
            <button style="padding:12px; font-size:0.85rem; margin:8px 0; background:#880000; border-radius:8px;" onclick="killLobby()">üß® Lobby l√∂schen</button>
            <hr style="border:none; border-top:1px solid #333; margin:20px 0;">
        </div>

        <hr style="border:none; border-top:1px solid #333; margin:20px 0;">
        <p style="font-size:0.75rem; color:#888; margin-bottom:8px; text-transform:uppercase;">Spielverlauf:</p>
        <div id="divLogMenu" class="log-box" style="max-height:200px; font-size:0.75rem; margin-bottom:15px;"></div>
        
        <button style="padding:12px; font-size:0.85rem; margin:8px 0; background:#444; border-radius:8px;" onclick="leaveLobby()">üëã Lobby verlassen</button>
    </div>

    <h1>üî• Hitzkopf</h1>

    <!-- START SCREEN -->
    <div id="screen-start" class="screen active card">
        <h3 style="margin-bottom:15px; color:#ff8c00;">Wie hei√üt du?</h3>
        <input type="text" id="inpName" placeholder="Dein Name" maxlength="20" autocomplete="off">
        <label style="display:block; font-size:0.85rem; color:#aaa; margin-top:15px; margin-bottom:8px; font-weight:500;">W√§hle deinen Charakter:</label>
        <div class="emoji-gallery-wrapper" style="position:relative; margin-bottom:15px;">
            <div id="emojiGallery" style="display:flex; gap:10px; overflow-x:auto; overflow-y:hidden; padding:10px 0; scroll-behavior:smooth; -webkit-overflow-scrolling:touch; width:100%; max-width:100%;">
                <!-- Wird dynamisch gef√ºllt -->
            </div>
            <input type="hidden" id="inpEmoji" value="">
        </div>
        
        <div class="start-actions">
            <button class="btn-primary" onclick="openHostSettings()">üéÆ Spiel erstellen</button>
            <button class="btn-secondary" onclick="openJoinPanel()">üö™ Spiel beitreten</button>
        </div>

        <div id="hostSettings" class="start-panel hidden">
            <p style="font-size:0.85rem; color:#ccc; margin-bottom:8px; font-weight:600;">‚öôÔ∏è Host-Einstellungen</p>
            <label style="display:block; font-size:0.85rem; color:#aaa; margin-bottom:5px; font-weight:500;">Spielmodus:</label>
            <div id="gameModeSelection" style="display:grid; grid-template-columns:repeat(2, 1fr); gap:10px; margin-top:10px; margin-bottom:15px;">
                <div class="game-mode-card selected" data-mode="party" onclick="toggleGameMode('party')">
                    <div class="mode-emoji">‚ö°</div>
                    <div class="mode-name">Party-Modus</div>
                    <div style="font-size:0.7rem; color:#aaa; margin-top:5px;">Schnell & einfach</div>
                </div>
                <div class="game-mode-card" data-mode="strategisch" onclick="toggleGameMode('strategisch')">
                    <div class="mode-emoji">üïê</div>
                    <div class="mode-name">Strategie-Modus</div>
                    <div style="font-size:0.7rem; color:#aaa; margin-top:5px;">Mit Joker & Taktik</div>
                </div>
            </div>
            <label style="display:block; font-size:0.85rem; color:#aaa; margin-top:12px; margin-bottom:5px; font-weight:500;">W√§hle Fragenkategorien:</label>
            <div id="categorySelection" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(140px, 1fr)); gap:10px; margin-top:10px; margin-bottom:15px;">
                <!-- Wird dynamisch gef√ºllt -->
            </div>
            <label style="display:block; font-size:0.85rem; color:#aaa; margin-top:15px; margin-bottom:5px; font-weight:500;">üîí Raum-Passwort (optional):</label>
            <input type="password" id="inpRoomPassword" placeholder="Leer lassen f√ºr √∂ffentlichen Raum" style="margin-bottom:5px;" autocomplete="off">
            <p style="font-size:0.7rem; color:#666; margin-top:5px; margin-bottom:15px;">‚ö†Ô∏è Mit Passwort k√∂nnen nur Spieler mit dem Code + Passwort beitreten</p>
            <button class="btn-primary" onclick="createGame()" style="margin-top:15px;">üéÆ Spiel erstellen</button>
        </div>

        <div id="joinPanel" class="start-panel hidden">
            <p style="font-size:0.85rem; color:#ccc; margin-bottom:8px; font-weight:600;">ü§ù Spiel beitreten</p>
            <div id="roomList" style="max-height:300px; overflow-y:auto; margin-bottom:15px; display:none;">
                <!-- Wird dynamisch gef√ºllt -->
            </div>
            <input type="text" id="inpCode" placeholder="Raum-Code" style="text-transform:uppercase; display:none;" maxlength="6" autocomplete="off" oninput="this.value = this.value.toUpperCase();">
            <input type="password" id="inpPassword" placeholder="Passwort (optional)" style="display:none; margin-top:10px;" autocomplete="off">
            <button class="btn-secondary" onclick="joinGame()" id="btnJoinGame">üö™ Beitreten</button>
            <button class="btn-secondary" onclick="loadRoomList()" style="margin-top:10px; font-size:0.9rem; padding:10px;">üîÑ R√§ume aktualisieren</button>
        </div>
    </div>
    
    <!-- ANLEITUNG BUTTON (au√üerhalb des Kastens, nur auf Start-Screen) -->
    <div id="anleitungButton" style="max-width:480px; margin:20px auto 0 auto; display:none;">
        <button onclick="openRulesOverlay()" class="btn-secondary" style="width:100%; padding:12px; font-size:0.95rem; margin-top:10px;">üìñ Anleitung</button>
    </div>

    <!-- LOBBY SCREEN -->
    <div id="screen-lobby" class="screen card">
        <div id="lobbyList" style="margin:25px 0; font-weight:bold; font-size:1.15rem; color:#fff;"></div>
        <div id="lobbyReadyList" style="font-size:0.9rem; color:#aaa; margin-bottom:15px;"></div>
        <button id="btnLobbyReady" class="btn-secondary" onclick="toggleLobbyReady()">‚úÖ Bereit</button>
        <div id="lobbyReadyStatus" style="font-size:0.85rem; color:#777; margin-top:5px;"></div>
        <button id="btnHostStart" class="btn-primary" style="display:none;" onclick="startCountdown()">üî• Spiel starten</button>
        <button id="btnShare" class="share-btn" style="display:none;" onclick="shareLobby()">üì§ Link teilen</button>
        <p id="lblWait" style="color:#666; font-size:0.9rem;">‚è≥ Warte auf Host...</p>
    </div>

    <!-- GAME SCREEN -->
    <div id="screen-game" class="screen card">
        <div id="gridGame" class="thermo-grid"></div>
        <hr style="border-color:#333; margin:15px 0;">
        
        <div style="margin-bottom:15px;">
            <span style="font-size:2rem;">üéØ</span>
            <div id="lblHotseat" style="font-weight:bold; font-size:1.3rem; color:#ff4500;">...</div>
            <p id="lblHotseatSub" style="font-size:0.85rem; color:#aaa; margin-top:4px;"></p>
        </div>
        
        <h3 id="lblQuestion" style="margin:20px 0; min-height:60px; display:flex; align-items:center; justify-content:center;">Lade Frage...</h3>
        <p id="lblQuestionCategory" style="font-size:0.8rem; color:#888; margin-top:-10px; margin-bottom:10px; font-style:italic;"></p>

        <div class="option-row" id="optionRow" style="margin-top:15px;">
            <button id="btnA" class="btn-option" onclick="vote('A')">A</button>
            <button id="btnB" class="btn-option" onclick="vote('B')">B</button>
        </div>

        <button id="btnLock" class="btn-primary" style="margin-top:20px;" onclick="submitVote()">üîí Antwort absenden</button>
        <div id="lblVoteStatus" style="font-size:0.8rem; color:#888; margin-top:10px;"></div>
        <div class="joker-panel" id="jokerPanelGame">
            <h4>Deine Joker</h4>
            <div id="myJokerListGame" class="joker-strip"></div>
        </div>
    </div>

    <!-- RESULT SCREEN -->
    <div id="screen-result" class="screen card">
        <div id="gridResult" class="thermo-grid"></div>
        
        <h2 id="lblResultStatus" style="margin:20px 0 15px 0;">...</h2>
        <p id="lblResultCategory" style="font-size:0.8rem; color:#888; margin-bottom:15px; font-style:italic;"></p>

        <div id="boxReward" style="display:none; background:#2a3a1a; padding:15px; border-radius:10px; margin-bottom:15px; border:2px solid #4a6a2a;">
            <h4 style="margin:0 0 12px 0; color:#8fef8f;">üéÅ Belohnung w√§hlen:</h4>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                <button onclick="chooseReward('attack')" style="background:linear-gradient(135deg, #dc3545, #c82333); color:white; padding:20px; border-radius:10px; border:none; font-size:1.1rem; font-weight:bold; cursor:pointer; transition:transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    üî¥ Gegner aufheizen
                </button>
                <button onclick="chooseReward('invest')" style="background:linear-gradient(135deg, #1a2a3a, #2a3a4a); color:white; padding:20px; border-radius:10px; border:none; font-size:1.1rem; font-weight:bold; cursor:pointer; transition:transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    üÉè Joker ziehen
                </button>
            </div>
        </div>

        <div id="boxAttack" style="display:none; background:#3a1a1a; padding:10px; border-radius:10px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0;" id="attackTitle">üî• Wen aufheizen?</h4>
            <div id="divTargets" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(120px, 1fr)); gap:12px; margin-top:10px;"></div>
            <div style="display:flex; gap:5px; margin-top:10px;" id="attackControls">
                <button style="flex:1; background:transparent; border:1px solid #666; color:#aaa; font-size:0.85rem; padding:8px; display:none;" onclick="goBackToReward()" id="btnBackFromAttack">‚Üê Zur√ºck</button>
                <button style="flex:1; background:transparent; border:1px solid #666; color:#aaa; font-size:0.85rem; padding:8px; display:none;" onclick="skipAttack()" id="btnSkipAttack">Angriff √ºberspringen</button>
            </div>
        </div>

        <div id="boxShop" style="display:none; background:#1a2a3a; padding:10px; border-radius:10px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0;">üÉè Joker-Karte w√§hlen:</h4>
            <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px;">
                <button class="card-select-btn" onclick="takeCard('card_oil')">
                    <strong>üõ¢Ô∏è √ñlfass</strong>
                    <span>Verdoppelt deinen n√§chsten Angriff.</span>
                </button>
                <button class="card-select-btn" onclick="takeCard('card_mirror')">
                    <strong>ü™û Spiegel</strong>
                    <span>Der n√§chste Angriff prallt zur√ºck.</span>
                </button>
                <button class="card-select-btn" onclick="takeCard('card_ice')">
                    <strong>üßä Eisw√ºrfel</strong>
                    <span>K√ºhlt dich in der n√§chsten Runde automatisch ab.</span>
                </button>
            </div>
            <button style="width:100%; background:transparent; border:1px solid #666; color:#aaa; font-size:0.85rem; margin-top:10px; padding:8px;" onclick="goBackToReward()">‚Üê Zur√ºck</button>
        </div>


        <button id="btnReady" class="btn-ready" onclick="setReady()">üëç Bereit</button>
        <div id="lblReady" style="font-size:0.8rem; color:#666; margin-top:5px;"></div>
        <div class="joker-panel" style="margin-top:20px;">
            <h4>Deine Joker</h4>
            <div id="myJokerListResult" class="joker-strip"></div>
        </div>
    </div>

    <!-- FULLSCREEN ANIMATION OVERLAY -->
    <div id="fullscreenAnimation" class="countdown-overlay" style="display:none;">
        <div style="background:linear-gradient(145deg, #1e1e1e, #252525); padding:40px; border-radius:20px; max-width:600px; margin:20px; border:2px solid #ff4500; box-shadow:0 8px 32px rgba(0,0,0,0.8); text-align:center;">
            <div id="animEmoji" style="font-size:5rem; margin-bottom:20px; animation:sweatShake 0.9s infinite;">ü•µ</div>
            <div id="animName" style="font-size:2.5rem; font-weight:800; color:#ff4500; margin-bottom:15px; text-shadow:0 0 18px rgba(255,69,0,0.6);">...</div>
            <div id="animText" style="font-size:1.2rem; color:#fff; margin-bottom:25px;">...</div>
            <div style="width:80%; margin:0 auto 20px auto;">
                <div style="height:25px; border-radius:12px; background:#280000; overflow:hidden; box-shadow:inset 0 0 10px rgba(0,0,0,0.7);">
                    <div id="animThermoFill" style="height:100%; width:0%; background:linear-gradient(90deg, #ffae00, #ff0000); box-shadow:0 0 20px rgba(255,0,0,0.7); transition:width 1.2s ease-out;"></div>
                </div>
                <div id="animTemp" style="font-size:1.5rem; font-weight:bold; color:#ff4500; margin-top:10px;">0¬∞C</div>
            </div>
            <div id="animCounter" style="font-size:0.9rem; color:#888; margin-top:15px; display:none;">Angriff 1 von 3</div>
        </div>
    </div>

    <!-- ROUND RECAP OVERLAY -->
    <div id="roundRecapOverlay" class="countdown-overlay" style="display:none;">
        <div style="background:linear-gradient(145deg, #1e1e1e, #252525); padding:40px; border-radius:20px; max-width:700px; margin:20px; border:2px solid #ff4500; box-shadow:0 8px 32px rgba(0,0,0,0.8); text-align:center;">
            <h2 style="color:#ff4500; margin-bottom:30px; font-size:2rem;">üìä Runden-Rekapitulation</h2>
            <div id="recapContent" style="min-height:400px;">
                <!-- Wird dynamisch gef√ºllt -->
            </div>
            <button onclick="closeRoundRecap()" class="btn-primary" style="margin-top:20px; padding:15px 30px; font-size:1.1rem;">Weiter ‚è≠Ô∏è</button>
        </div>
    </div>

    <!-- WINNER SCREEN -->
    <div id="screen-winner" class="screen card" style="background:radial-gradient(circle at center, rgba(0,209,255,0.15), #0a0a0a 70%); border:2px solid #00d1ff;">
        <div id="confetti-container" style="position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:5000;"></div>
        <div style="text-align:center; position:relative; z-index:1;">
            <div id="winnerEmoji" style="font-size:6rem; margin-bottom:20px; animation:sweatShake 0.9s infinite;">üòé</div>
            <div id="winnerName" style="font-size:3rem; font-weight:900; color:#00d1ff; margin-bottom:15px; text-shadow:0 0 30px rgba(0,209,255,0.7);">...</div>
            <div style="font-size:1.3rem; color:#c8f4ff; margin-bottom:30px;">ist cool geblieben und gewinnt diese Runde Hitzkopf! üßä</div>
            <div style="width:80%; margin:0 auto 30px auto;">
                <div style="height:30px; border-radius:15px; background:#001a28; overflow:hidden; box-shadow:inset 0 0 15px rgba(0,0,0,0.7);">
                    <div id="winnerThermoFill" style="height:100%; width:0%; background:linear-gradient(90deg, #00d1ff, #0080ff); box-shadow:0 0 25px rgba(0,209,255,0.7); transition:width 1.5s ease-out;"></div>
                </div>
                <div id="winnerTemp" style="font-size:2rem; font-weight:bold; color:#00d1ff; margin-top:15px;">0¬∞C</div>
            </div>
            <hr style="border-color:#003d5c; margin:30px 0;">
            <div id="rankingList" style="text-align:left; margin-top:20px; margin-bottom:30px;">
                <!-- Wird dynamisch gef√ºllt -->
            </div>
            
            <!-- Voting-Bereich -->
            <hr style="border-color:#003d5c; margin:30px 0;">
            <h2 style="color:#ff8c00; margin-bottom:20px; font-size:1.5rem;">üéÆ Noch eine Runde?</h2>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:20px; max-width:600px; margin-left:auto; margin-right:auto;">
                <button id="btnVoteRematch" class="btn-primary" onclick="voteRematch(true)" style="padding:20px; font-size:1.2rem;">‚úÖ Nochmal spielen</button>
                <button id="btnVoteLeave" class="btn-secondary" onclick="leaveLobby()" style="padding:20px; font-size:1.2rem;">üö™ Verlassen</button>
            </div>
            <div id="votingStatus" style="font-size:0.9rem; color:#888; margin-top:15px;">Warte auf andere Spieler...</div>
            <div id="votingResults" style="margin-top:20px; font-size:0.85rem; color:#aaa;"></div>
            <div id="hostRematchSettings" style="margin-top:20px;">
                <!-- Wird dynamisch f√ºr Host gef√ºllt -->
            </div>
        </div>
    </div>

    <!-- VOTING SCREEN -->
    <div id="screen-voting" class="screen card">
        <h2 style="color:#ff8c00; margin-bottom:20px;">üéÆ Spiel beendet!</h2>
        <p style="color:#aaa; margin-bottom:30px;">M√∂chtest du noch eine Runde spielen?</p>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:20px;">
            <button id="btnVoteRematch" class="btn-primary" onclick="voteRematch(true)" style="padding:20px; font-size:1.2rem;">‚úÖ Nochmal spielen</button>
            <button id="btnVoteLeave" class="btn-secondary" onclick="leaveLobby()" style="padding:20px; font-size:1.2rem;">üö™ Verlassen</button>
        </div>
        <div id="votingStatus" style="font-size:0.9rem; color:#888; margin-top:15px;">Warte auf andere Spieler...</div>
        <div id="votingResults" style="margin-top:20px; font-size:0.85rem; color:#aaa;"></div>
    </div>

    <!-- GAMEOVER SCREEN (f√ºr rausgeflogene Spieler) -->
    <div id="screen-gameover" class="screen card final-card">
        <div class="final-hero">
            <div id="finalEmoji" class="final-emoji">ü•µ</div>
            <div>
                <div id="lblLoser" class="final-name">...</div>
                <div id="lblFinalText" class="final-caption">...</div>
            </div>
        </div>
        <div class="final-thermo">
            <div class="final-thermo-track">
                <div id="finalThermoFill" class="final-thermo-fill"></div>
            </div>
        </div>
        <div id="finalRanking" class="final-ranking"></div>
        <button id="btnRematch" style="background:#ff4500; margin-top:25px;" onclick="rematchGame()">‚ôªÔ∏è Revanche starten</button>
        <button style="background:#444; margin-top:10px;" onclick="leaveLobby()">üö™ Lobby verlassen</button>
    </div>
    <div id="toast" class="toast"></div>
    <script type="module">
        // --- FIREBASE SETUP ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, arrayUnion, arrayRemove, onSnapshot, increment, deleteDoc, deleteField, collection, query, where, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBQ7c9JkZ3zWlyIjZLl1O1sJJOrKfYJbmA",
            authDomain: "hitzkopf-f0ea6.firebaseapp.com",
            projectId: "hitzkopf-f0ea6",
            storageBucket: "hitzkopf-f0ea6.firebasestorage.app",
            messagingSenderId: "828164655874",
            appId: "1:828164655874:web:1cab759bdb03bfb736101b"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- STATE ---
        let myName = sessionStorage.getItem("hk_name") || "";
        let myEmoji = sessionStorage.getItem("hk_emoji") || null;
        let myGender = sessionStorage.getItem("hk_gender") || "divers"; // Deaktiviert, aber behalten
        let roomId = sessionStorage.getItem("hk_room") || "";
        let isHost = false;
        let localActionDone = false;
        let mySelection = null;
        let myStrategy = null;
        let globalData = null;
        let lastRoundId = null;
        let loggedRoundResult = null;
        let lobbyClosedHandled = false;
        let lastTemps = {};
        let lastMyTemp = null;
        let attackAlertTimer = null;
        let countdownInterval = null;
        let countdownTarget = null;
        let rulesShown = false;
        let lastAttackResultKey = null; // Verhindert mehrfache Popup-Anzeige
        let isOpeningAttackModal = false; // Verhindert gleichzeitige Modal-√ñffnungen
        let unsubscribeListener = null; // F√ºr Cleanup des onSnapshot Listeners (Memory Leak Fix)
        
        // --- PERFORMANCE-OPTIMIERUNG: DOM-ELEMENTE CACHEN ---
        // Cache f√ºr h√§ufig verwendete DOM-Elemente (verhindert wiederholte getElementById/querySelector Aufrufe)
        const domCache = {
            elements: {},
            get: function(id) {
                if(!this.elements[id]) {
                    this.elements[id] = document.getElementById(id);
                }
                return this.elements[id];
            },
            query: function(selector) {
                const cacheKey = 'query_' + selector;
                if(!this.elements[cacheKey]) {
                    this.elements[cacheKey] = document.querySelector(selector);
                }
                return this.elements[cacheKey];
            },
            queryAll: function(selector) {
                // querySelectorAll wird nicht gecached da es ein NodeList zur√ºckgibt die sich √§ndern kann
                return document.querySelectorAll(selector);
            },
            clear: function() {
                this.elements = {};
            }
        };
        
        // --- SICHERHEITS-UTILITY-FUNKTIONEN ---
        
        // Funktion zum Escaping von HTML (XSS-Schutz)
        function escapeHtml(text) {
            if(!text || typeof text !== 'string') return '';
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        // Funktion zur Input-Validierung und Sanitierung
        function sanitizeInput(input, type = 'name') {
            if(!input || typeof input !== 'string') return '';
            
            let sanitized = input.trim();
            
            if(type === 'name') {
                // Maximal 20 Zeichen, nur alphanumerische Zeichen, Leerzeichen, Umlaute, Emojis
                sanitized = sanitized.substring(0, 20);
                // Entferne potenziell gef√§hrliche Zeichen, aber erlaube Umlaute und Emojis
                sanitized = sanitized.replace(/[<>"']/g, '');
            } else if(type === 'emoji') {
                // Emojis sollten nur ein Zeichen sein (oder mehrere zusammenh√§ngende Emojis)
                sanitized = sanitized.substring(0, 10); // Max 10 Zeichen f√ºr zusammenh√§ngende Emojis
            } else if(type === 'password') {
                // Passwort: Max 50 Zeichen, entferne gef√§hrliche Zeichen
                sanitized = sanitized.substring(0, 50);
                sanitized = sanitized.replace(/[<>"']/g, '');
            }
            
            return sanitized;
        }
        
        // --- EMOJI SELECTION ---
        // 15 Emojis: Prim√§r Tiergesichter, wenn nicht genug dann mit anderen Wesen auff√ºllen
        const baseEmojis = [
            // Tiergesichter (prim√§r)
            'üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ',
            'ü¶Å', 'üêÆ', 'üê∑', 'üê∏', 'üêµ',
            // Falls nicht genug Tiergesichter, mit anderen Wesen auff√ºllen (bereits 15 erreicht)
        ];
        // Zuf√§llige Reihenfolge der Emojis
        const availableEmojis = [...baseEmojis].sort(() => Math.random() - 0.5);
        let currentEmojiIndex = 0;
        
        window.selectEmoji = (emoji) => {
            const gallery = document.getElementById('emojiGallery');
            if(!gallery) return;
            
            myEmoji = emoji;
            const inpEmoji = document.getElementById('inpEmoji');
            if(inpEmoji) inpEmoji.value = emoji;
            
            currentEmojiIndex = availableEmojis.indexOf(emoji);
            
            // Aktualisiere visuelle Auswahl
            gallery.querySelectorAll('.emoji-card').forEach((card) => {
                const cardEmoji = card.getAttribute('data-emoji');
                if(cardEmoji === emoji) {
                    card.classList.add('selected');
                    
                    // Zentriere das ausgew√§hlte Emoji manuell f√ºr bessere Kontrolle
                    requestAnimationFrame(() => {
                        const galleryWidth = gallery.clientWidth;
                        const cardWidth = card.offsetWidth;
                        const cardLeft = card.offsetLeft;
                        const scrollPosition = cardLeft - (galleryWidth / 2) + (cardWidth / 2);
                        gallery.scrollTo({
                            left: Math.max(0, scrollPosition),
                            behavior: 'smooth'
                        });
                    });
                } else {
                    card.classList.remove('selected');
                }
            });
        };
        
        // Initialisiere Emoji-Galerie
        if(document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initEmojiGallery);
        } else {
            initEmojiGallery();
        }
        
        function initEmojiGallery() {
            const gallery = document.getElementById('emojiGallery');
            const inpEmoji = document.getElementById('inpEmoji');
            if(!gallery || !inpEmoji) return;
            
            // Finde aktuelles Emoji - wenn kein gespeichertes vorhanden, w√§hle das mittlere
            let currentEmoji = myEmoji;
            if(!currentEmoji || !availableEmojis.includes(currentEmoji)) {
                // W√§hle das mittlere Emoji aus der Liste
                const middleIndex = Math.floor(availableEmojis.length / 2);
                currentEmoji = availableEmojis[middleIndex];
            }
            currentEmojiIndex = availableEmojis.indexOf(currentEmoji);
            
            // Erstelle Galerie mit Spacern vor und nach den Emojis f√ºr zentriertes Scrollen
            const emojisHtml = availableEmojis.map((emoji, idx) => {
                const isSelected = emoji === currentEmoji;
                return `
                    <div class="emoji-card ${isSelected ? 'selected' : ''}" onclick="selectEmoji('${emoji}')" data-emoji="${emoji}">
                        ${emoji}
                    </div>
                `;
            }).join('');
            
            // F√ºge Spacer vor und nach den Emojis hinzu, damit zentriertes Scrollen m√∂glich ist
            gallery.innerHTML = `<div class="emoji-spacer"></div>${emojisHtml}<div class="emoji-spacer"></div>`;
            
            inpEmoji.value = currentEmoji;
            myEmoji = currentEmoji;
            
            // Zentriere das ausgew√§hlte Emoji - warte bis alles gerendert ist
            const centerSelectedEmoji = () => {
                const selectedCard = gallery.querySelector('.emoji-card.selected');
                if(!selectedCard) {
                    return;
                }
                
                // Warte auf Layout-Berechnung mit mehreren Animation Frames
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            // Hole alle notwendigen Dimensionen
                            const galleryWidth = gallery.clientWidth;
                            const cardWidth = selectedCard.offsetWidth;
                            const cardLeft = selectedCard.offsetLeft;
                            
                            // Berechne die Scroll-Position, um das Emoji zu zentrieren
                            // cardLeft ist die Position relativ zum scrollbaren Container (inkl. Spacer)
                            // Wir wollen das Emoji in der Mitte der sichtbaren Breite positionieren
                            const scrollPosition = cardLeft - (galleryWidth / 2) + (cardWidth / 2);
                            
                            // Setze die Scroll-Position (mit Spacern sollte dies immer >= 0 sein)
                            gallery.scrollLeft = scrollPosition;
                        });
                    });
                });
            };
            
            // Mehrere Versuche mit unterschiedlichen Delays, um sicherzustellen, dass es funktioniert
            // Wichtig: Warte bis die Spacer gerendert sind
            setTimeout(centerSelectedEmoji, 100);
            setTimeout(centerSelectedEmoji, 300);
            setTimeout(centerSelectedEmoji, 600);
            
            // Initialisiere Anleitung-Button Sichtbarkeit
            const anleitungBtn = document.getElementById('anleitungButton');
            const startScreen = document.getElementById('screen-start');
            if(anleitungBtn && startScreen) {
                anleitungBtn.style.display = startScreen.classList.contains('active') ? 'block' : 'none';
            }
        }
        
        // --- GENDERING FUNCTION ---
        function genderText(text, gender = myGender) {
            if(!text || typeof text !== 'string') return text;
            const patterns = {
                m√§nnlich: { 'er/ihn': 'er', 'ihn': 'ihn', 'sein': 'sein', 'seine': 'seine', 'seinen': 'seinen', 'seiner': 'seiner' },
                weiblich: { 'er/ihn': 'sie', 'ihn': 'sie', 'sein': 'ihr', 'seine': 'ihre', 'seinen': 'ihren', 'seiner': 'ihrer' },
                divers: { 'er/ihn': 'sie', 'ihn': 'sie', 'sein': 'ihr', 'seine': 'ihre', 'seinen': 'ihren', 'seiner': 'ihrer' }
            };
            const replacements = patterns[gender] || patterns.divers;
            let result = text;
            Object.keys(replacements).forEach(key => {
                const regex = new RegExp(`\\b${key}\\b`, 'gi');
                result = result.replace(regex, replacements[key]);
            });
            return result;
        }
        
        function getGenderPronoun(gender = myGender) {
            const pronouns = {
                m√§nnlich: { subject: 'er', object: 'ihn', possessive: 'sein', possessiveAdj: 'seine' },
                weiblich: { subject: 'sie', object: 'sie', possessive: 'ihr', possessiveAdj: 'ihre' },
                divers: { subject: 'sie', object: 'sie', possessive: 'ihr', possessiveAdj: 'ihre' }
            };
            return pronouns[gender] || pronouns.divers;
        }

        const sleep = (ms = 0) => new Promise(res => setTimeout(res, ms));

        // Fragenstruktur in Kategorien organisiert
        const questionCategories = {
            "astronomie_geographie": {
                name: "Astronomie & Geographie",
                emoji: "üåç",
                questions: [
                    { q: "Lieber Tag oder Nacht?", a: "Tag ‚òÄÔ∏è", b: "Nacht üåô" },
                    { q: "Lieber Regenwald oder W√ºste?", a: "Regenwald üå≥üíß", b: "W√ºste üèúÔ∏è‚òÄÔ∏è" },
                    { q: "Lieber Ozean oder Gebirge?", a: "Ozean üåä", b: "Gebirge ‚õ∞Ô∏è" },
                    { q: "Lieber Nordpol oder S√ºdpol?", a: "Nordpol üêª‚Äç‚ùÑÔ∏è", b: "S√ºdpol üêß" },
                    { q: "Lieber St√§dtereise oder Naturreise?", a: "Stadt üèôÔ∏è", b: "Natur üèûÔ∏è" },
                    { q: "Lieber Kontinental oder Insel?", a: "Kontinental üó∫Ô∏è", b: "Insel üèùÔ∏è" },
                    { q: "Lieber hei√üe oder kalte Klimazone?", a: "Hei√ü üåû", b: "Kalt ‚ùÑÔ∏è" },
                    { q: "Lieber Regen oder Schnee?", a: "Regen üåßÔ∏è", b: "Schnee ‚ùÑÔ∏è" },
                    { q: "Lieber Sonne oder Mond beobachten?", a: "Sonne ‚òÄÔ∏è", b: "Mond üåô" },
                    { q: "Lieber Flachland oder Hochland?", a: "Flachland üåæ", b: "Hochland üèîÔ∏è" },
                    { q: "Lieber Fluss oder See?", a: "Fluss üåä", b: "See üèûÔ∏è" },
                    { q: "Lieber tropisch oder gem√§√üigt?", a: "Tropisch üå¥", b: "Gem√§√üigt üçÉ" },
                    { q: "Lieber Meeresk√ºste oder Seenlandschaft?", a: "Meeresk√ºste üåä", b: "Seenlandschaft üèûÔ∏è" },
                    { q: "Lieber Vulkan oder Geysir?", a: "Vulkan üåã", b: "Geysir üí®" },
                    { q: "Lieber Regenzeit oder Trockenzeit?", a: "Regenzeit üåßÔ∏è", b: "Trockenzeit ‚òÄÔ∏è" },
                    { q: "Lieber Polarlicht oder Sonnenuntergang?", a: "Polarlicht üåå", b: "Sonnenuntergang üåÖ" },
                    { q: "Lieber Kontinent oder Ozean?", a: "Kontinent üó∫Ô∏è", b: "Ozean üåä" },
                    { q: "Lieber Wettervorhersage oder √ºberrascht werden?", a: "Vorhersage üì°", b: "√úberraschung üé≤" },
                    { q: "Lieber H√∂henluft oder Meeresh√∂he?", a: "H√∂henluft ‚õ∞Ô∏è", b: "Meeresh√∂he üèñÔ∏è" },
                    { q: "Lieber Erdmagnetfeld oder Schwerkraft?", a: "Magnetfeld üß≤", b: "Schwerkraft ‚¨áÔ∏è" }
                ]
            },
            "essen_trinken": {
                name: "Essen & Trinken",
                emoji: "üçΩÔ∏è",
                questions: [
                    { q: "Lieber Butter oder Margarine?", a: "Butter üßà", b: "Margarine ü•Ñ" },
                    { q: "Lieber Kaffee oder Tee?", a: "Kaffee ‚òï", b: "Tee üçµ" },
                    { q: "Lieber Pizza oder Pasta?", a: "Pizza üçï", b: "Pasta üçù" },
                    { q: "Lieber Schokolade oder Gummib√§rchen?", a: "Schokolade üç´", b: "Gummib√§rchen üêª" },
                    { q: "Lieber Burger oder D√∂ner?", a: "Burger üçî", b: "D√∂ner ü•ô" },
                    { q: "Lieber kochen oder bestellen?", a: "Kochen üßë‚Äçüç≥", b: "Bestellen üõµ" },
                    { q: "Lieber Vanille oder Schokoeis?", a: "Vanille ü§çüç¶", b: "Schoko ü§éüç¶" },
                    { q: "Lieber Popcorn s√º√ü oder salzig?", a: "S√º√ü üç¨üçø", b: "Salzig üßÇüçø" },
                    { q: "Lieber Wein oder Bier?", a: "Wein üç∑", b: "Bier üç∫" },
                    { q: "Lieber K√§se oder Wurst?", a: "K√§se üßÄ", b: "Wurst ü•ì" },
                    { q: "Lieber Spiegelei oder R√ºhrei?", a: "Spiegelei üç≥üëÅÔ∏è", b: "R√ºhrei ü•öü•£" },
                    { q: "Lieber Limo oder Saft?", a: "Limo ü•§", b: "Saft üßÉ" },
                    { q: "Lieber Torte oder Kuchen?", a: "Torte üéÇ", b: "Kuchen üç∞" },
                    { q: "Lieber Ketchup oder Mayo?", a: "Ketchup üçÖ", b: "Mayo ü•ö" },
                    { q: "Lieber Salat oder Suppe?", a: "Salat ü•ó", b: "Suppe ü•£" },
                    { q: "Lieber Marmelade oder Honig?", a: "Marmelade üçì", b: "Honig üçØ" },
                    { q: "Lieber Kartoffeln oder Reis?", a: "Kartoffeln ü•î", b: "Reis üçö" },
                    { q: "Lieber s√º√ü oder herzhaft fr√ºhst√ºcken?", a: "S√º√ü ü•ûüç¨", b: "Herzhaft ü•ìüç≥" },
                    { q: "Lieber K√§seplatte oder Obstteller?", a: "K√§se üßÄüçá", b: "Obst ü•ùüçé" },
                    { q: "Lieber Apfelkuchen oder K√§sekuchen?", a: "Apfelkuchen üçéüç∞", b: "K√§sekuchen üßÄüç∞" }
                ]
            },
            "flora_fauna": {
                name: "Flora & Fauna",
                emoji: "üåø",
                questions: [
                    { q: "Lieber Hund oder Katze?", a: "Hund üêï", b: "Katze üêà" },
                    { q: "Lieber Blumen oder B√§ume?", a: "Blumen üå∏", b: "B√§ume üå≥" },
                    { q: "Lieber V√∂gel oder Fische beobachten?", a: "V√∂gel üê¶", b: "Fische üê†" },
                    { q: "Lieber Rosen oder Sonnenblumen?", a: "Rosen üåπ", b: "Sonnenblumen üåª" },
                    { q: "Lieber Haus- oder Wildtier?", a: "Haustier üêï", b: "Wildtier ü¶Å" },
                    { q: "Lieber Garten oder Wald?", a: "Garten üå≥", b: "Wald üå≤" },
                    { q: "Lieber Kraut oder Bl√ºte?", a: "Kraut üåø", b: "Bl√ºte üå∫" },
                    { q: "Lieber Tagfalter oder Nachtfalter?", a: "Tagfalter ü¶ã", b: "Nachtfalter ü¶ãüåô" },
                    { q: "Lieber Nadel- oder Laubbaum?", a: "Nadelbaum üå≤", b: "Laubbaum üçÉ" },
                    { q: "Lieber S√§ugetier oder Reptil?", a: "S√§ugetier üêæ", b: "Reptil ü¶é" },
                    { q: "Lieber Obst- oder Gem√ºsegarten?", a: "Obstgarten üçé", b: "Gem√ºsegarten ü•ï" },
                    { q: "Lieber Land- oder Wassertier?", a: "Landtier ü¶å", b: "Wassertier üêô" },
                    { q: "Lieber Kaktus oder Palme?", a: "Kaktus üåµ", b: "Palme üå¥" },
                    { q: "Lieber kleine oder gro√üe Tiere?", a: "Klein üê≠", b: "Gro√ü üêò" },
                    { q: "Lieber duftende oder bunte Blumen?", a: "Duftend üå∏", b: "Bunt üå∫" },
                    { q: "Lieber Raub- oder Beutetier?", a: "Raubtier ü¶Å", b: "Beutetier üê∞" },
                    { q: "Lieber heimische oder exotische Pflanzen?", a: "Heimisch üåæ", b: "Exotisch üå¥" },
                    { q: "Lieber Insekten oder Spinnen?", a: "Insekten ü¶ó", b: "Spinnen üï∑Ô∏è" },
                    { q: "Lieber einj√§hrige oder mehrj√§hrige Pflanzen?", a: "Einj√§hrig üå±", b: "Mehrj√§hrig üå≥" },
                    { q: "Lieber Pflanzen pflegen oder Tiere versorgen?", a: "Pflanzen üåø", b: "Tiere üêï" }
                ]
            },
            "forschung_wissenschaft": {
                name: "Forschung & Wissenschaft",
                emoji: "üî¨",
                questions: [
                    { q: "Lieber Biologie oder Physik?", a: "Biologie üß¨", b: "Physik ‚öõÔ∏è" },
                    { q: "Lieber Labor oder Feldversuch?", a: "Labor üß™", b: "Feldversuch üåç" },
                    { q: "Lieber Theorie oder Praxis?", a: "Theorie üìö", b: "Praxis üî¨" },
                    { q: "Lieber Mikroskop oder Teleskop?", a: "Mikroskop üî¨", b: "Teleskop üî≠" },
                    { q: "Lieber Chemie oder Mathematik?", a: "Chemie ‚öóÔ∏è", b: "Mathematik üìê" },
                    { q: "Lieber beobachten oder experimentieren?", a: "Beobachten üëÅÔ∏è", b: "Experimentieren ‚öóÔ∏è" },
                    { q: "Lieber Naturwissenschaft oder Geisteswissenschaft?", a: "Naturwissenschaft üî¨", b: "Geisteswissenschaft üìñ" },
                    { q: "Lieber Einzelergebnis oder Durchbruch?", a: "Einzelergebnis üìä", b: "Durchbruch üí°" },
                    { q: "Lieber quantitative oder qualitative Forschung?", a: "Quantitativ üìà", b: "Qualitativ üìù" },
                    { q: "Lieber Astronomie oder Geologie?", a: "Astronomie ü™ê", b: "Geologie üóø" },
                    { q: "Lieber Genom oder Umwelt?", a: "Genom üß¨", b: "Umwelt üåç" },
                    { q: "Lieber Hypothese oder Theorie?", a: "Hypothese üí≠", b: "Theorie üìö" },
                    { q: "Lieber klinische oder Grundlagenforschung?", a: "Klinisch üè•", b: "Grundlagen üß™" },
                    { q: "Lieber Robotik oder KI?", a: "Robotik ü§ñ", b: "KI üß†" },
                    { q: "Lieber Entdeckung oder Erfindung?", a: "Entdeckung üîç", b: "Erfindung üí°" },
                    { q: "Lieber Mikro- oder Makroskala?", a: "Mikro üî¨", b: "Makro üåå" },
                    { q: "Lieber Langzeitstudie oder Schnelltest?", a: "Langzeit üìÖ", b: "Schnelltest ‚ö°" },
                    { q: "Lieber Teamforschung oder Einzelforschung?", a: "Team üë•", b: "Einzel üßë‚Äçüî¨" },
                    { q: "Lieber Datenanalyse oder Datensammlung?", a: "Analyse üìä", b: "Sammlung üì¶" },
                    { q: "Lieber publizieren oder forschen?", a: "Publizieren üìÑ", b: "Forschen üî¨" }
                ]
            },
            "geschichte_politik": {
                name: "Geschichte & Politik",
                emoji: "üèõÔ∏è",
                questions: [
                    { q: "Lieber Antike oder Moderne?", a: "Antike üèõÔ∏è", b: "Moderne üèôÔ∏è" },
                    { q: "Lieber Monarchie oder Republik?", a: "Monarchie üëë", b: "Republik üó≥Ô∏è" },
                    { q: "Lieber lokale oder Weltgeschichte?", a: "Lokal üèòÔ∏è", b: "Welt üåç" },
                    { q: "Lieber Krieg oder Frieden?", a: "Krieg ‚öîÔ∏è", b: "Frieden üïäÔ∏è" },
                    { q: "Lieber Revolution oder Evolution?", a: "Revolution üî•", b: "Evolution üìà" },
                    { q: "Lieber Demokratie oder Diktatur?", a: "Demokratie üó≥Ô∏è", b: "Diktatur üö´" },
                    { q: "Lieber geschichtliche Dokumente oder m√ºndliche √úberlieferung?", a: "Dokumente üìú", b: "M√ºndlich üó£Ô∏è" },
                    { q: "Lieber Imperium oder Stadtstaat?", a: "Imperium üåç", b: "Stadtstaat üèõÔ∏è" },
                    { q: "Lieber Vergangenheit oder Zukunft?", a: "Vergangenheit ‚èÆÔ∏è", b: "Zukunft ‚è≠Ô∏è" },
                    { q: "Lieber Wirtschafts- oder Kulturpolitik?", a: "Wirtschaft üíº", b: "Kultur üé≠" },
                    { q: "Lieber Nationalismus oder Globalismus?", a: "Nationalismus üá©üá™", b: "Globalismus üåê" },
                    { q: "Lieber Konservativ oder Progressiv?", a: "Konservativ üìú", b: "Progressiv üöÄ" },
                    { q: "Lieber historische Pers√∂nlichkeit oder Ereignis?", a: "Pers√∂nlichkeit üë§", b: "Ereignis üìÖ" },
                    { q: "Lieber Innen- oder Au√üenpolitik?", a: "Innenpolitik üè†", b: "Au√üenpolitik üåç" },
                    { q: "Lieber Wahl oder Revolution?", a: "Wahl üó≥Ô∏è", b: "Revolution üî•" },
                    { q: "Lieber Tradition oder Innovation?", a: "Tradition üìú", b: "Innovation üí°" },
                    { q: "Lieber Friedensvertrag oder Handelsabkommen?", a: "Friedensvertrag ‚úçÔ∏è", b: "Handelsabkommen ü§ù" },
                    { q: "Lieber historischer Roman oder Dokumentation?", a: "Roman üìö", b: "Dokumentation üé•" },
                    { q: "Lieber Regierung oder Opposition?", a: "Regierung üèõÔ∏è", b: "Opposition üé§" },
                    { q: "Lieber Geschichtsbuch oder Museum?", a: "Buch üìñ", b: "Museum üèõÔ∏è" }
                ]
            },
            "glaube_religion": {
                name: "Glaube & Religion",
                emoji: "üôè",
                questions: [
                    { q: "Lieber Glaube oder Wissen?", a: "Glaube üôè", b: "Wissen üìö" },
                    { q: "Lieber Gebet oder Meditation?", a: "Gebet üôè", b: "Meditation üßò" },
                    { q: "Lieber Kirche oder Natur?", a: "Kirche ‚õ™", b: "Natur üå≥" },
                    { q: "Lieber religi√∂ser Text oder spirituelle Erfahrung?", a: "Text üìñ", b: "Erfahrung ‚ú®" },
                    { q: "Lieber Gemeinschaft oder Einzelg√§nger?", a: "Gemeinschaft üë•", b: "Einzel üôè" },
                    { q: "Lieber Ritual oder spontan?", a: "Ritual üîî", b: "Spontan üí´" },
                    { q: "Lieber Tradition oder Modernit√§t?", a: "Tradition üìú", b: "Modernit√§t üåü" },
                    { q: "Lieber Philosophie oder Theologie?", a: "Philosophie üí≠", b: "Theologie üìñ" },
                    { q: "Lieber feste √úberzeugung oder offene Fragen?", a: "√úberzeugung üí™", b: "Offen ü§î" },
                    { q: "Lieber Gott oder Universum?", a: "Gott üëº", b: "Universum üåå" },
                    { q: "Lieber Predigt oder Stille?", a: "Predigt üó£Ô∏è", b: "Stille ü§´" },
                    { q: "Lieber heiliger Ort oder √ºberall?", a: "Heiliger Ort ‚õ™", b: "√úberall üåç" },
                    { q: "Lieber Dogma oder Toleranz?", a: "Dogma üìú", b: "Toleranz ü§ù" },
                    { q: "Lieber Religion oder Spiritualit√§t?", a: "Religion ‚õ™", b: "Spiritualit√§t ‚ú®" },
                    { q: "Lieber Gemeindeleben oder Privatheit?", a: "Gemeinde üë•", b: "Privat üôè" },
                    { q: "Lieber geschriebenes Gesetz oder Gewissen?", a: "Gesetz üìú", b: "Gewissen ‚ù§Ô∏è" },
                    { q: "Lieber Priester oder Laie?", a: "Priester üë®‚Äçüíº", b: "Laie üë§" },
                    { q: "Lieber heilige Schrift oder pers√∂nliche Offenbarung?", a: "Schrift üìñ", b: "Offenbarung üí°" },
                    { q: "Lieber Festtag oder Alltag?", a: "Festtag üéâ", b: "Alltag üìÖ" },
                    { q: "Lieber Transzendenz oder Immanenz?", a: "Transzendenz üåå", b: "Immanenz üåç" }
                ]
            },
            "kunst_kultur": {
                name: "Kunst & Kultur",
                emoji: "üé®",
                questions: [
                    { q: "Lieber Malerei oder Skulptur?", a: "Malerei üñºÔ∏è", b: "Skulptur üóø" },
                    { q: "Lieber abstrakt oder figurativ?", a: "Abstrakt üé®", b: "Figurativ üë§" },
                    { q: "Lieber Museum oder Galerie?", a: "Museum üèõÔ∏è", b: "Galerie üñºÔ∏è" },
                    { q: "Lieber klassisch oder modern?", a: "Klassisch üé≠", b: "Modern üé®" },
                    { q: "Lieber Farbe oder Form?", a: "Farbe üåà", b: "Form ‚¨ú" },
                    { q: "Lieber Original oder Reproduktion?", a: "Original ‚ú®", b: "Reproduktion üìã" },
                    { q: "Lieber K√ºnstler oder Betrachter?", a: "K√ºnstler üé®", b: "Betrachter üëÅÔ∏è" },
                    { q: "Lieber √ñl- oder Aquarellmalerei?", a: "√ñl üñåÔ∏è", b: "Aquarell üíß" },
                    { q: "Lieber Renaissance oder Barock?", a: "Renaissance üé≠", b: "Barock üèõÔ∏è" },
                    { q: "Lieber Street Art oder Museumskunst?", a: "Street Art üé®", b: "Museumskunst üñºÔ∏è" },
                    { q: "Lieber Portr√§t oder Landschaft?", a: "Portr√§t üë§", b: "Landschaft üåÑ" },
                    { q: "Lieber Fotografie oder Gem√§lde?", a: "Fotografie üì∏", b: "Gem√§lde üñºÔ∏è" },
                    { q: "Lieber Installation oder Performance?", a: "Installation üé≠", b: "Performance üé™" },
                    { q: "Lieber Realismus oder Surrealismus?", a: "Realismus üëÅÔ∏è", b: "Surrealismus üåà" },
                    { q: "Lieber minimal oder opulent?", a: "Minimal ‚¨ú", b: "Opulent ‚ú®" },
                    { q: "Lieber analog oder digital?", a: "Analog üñåÔ∏è", b: "Digital üíª" },
                    { q: "Lieber Tradition oder Avantgarde?", a: "Tradition üìú", b: "Avantgarde üöÄ" },
                    { q: "Lieber Einzelwerk oder Serie?", a: "Einzelwerk üñºÔ∏è", b: "Serie üìö" },
                    { q: "Lieber Gem√§lde oder Zeichnung?", a: "Gem√§lde üé®", b: "Zeichnung ‚úèÔ∏è" },
                    { q: "Lieber K√ºnstlerkollektiv oder Einzelk√ºnstler?", a: "Kollektiv üë•", b: "Einzelk√ºnstler üé®" }
                ]
            },
            "literatur_sprache": {
                name: "Literatur & Sprache",
                emoji: "üìö",
                questions: [
                    { q: "Lieber Buch oder H√∂rbuch?", a: "Buch üìö", b: "H√∂rbuch üéß" },
                    { q: "Lieber Roman oder Gedicht?", a: "Roman üìñ", b: "Gedicht ‚úçÔ∏è" },
                    { q: "Lieber Fiktion oder Non-Fiktion?", a: "Fiktion üé≠", b: "Non-Fiktion üìä" },
                    { q: "Lieber Schreiber oder Leser?", a: "Schreiber ‚úçÔ∏è", b: "Leser üëÅÔ∏è" },
                    { q: "Lieber gedruckt oder digital?", a: "Gedruckt üìñ", b: "Digital üì±" },
                    { q: "Lieber Fantasy oder Realismus?", a: "Fantasy üêâ", b: "Realismus üëÅÔ∏è" },
                    { q: "Lieber Kurzgeschichte oder Roman?", a: "Kurzgeschichte üìù", b: "Roman üìñ" },
                    { q: "Lieber √úbersetzen oder Original?", a: "√úbersetzen üåê", b: "Original üìö" },
                    { q: "Lieber Gedicht schreiben oder lesen?", a: "Schreiben ‚úçÔ∏è", b: "Lesen üëÅÔ∏è" },
                    { q: "Lieber Drama oder Kom√∂die?", a: "Drama üé≠", b: "Kom√∂die üòÇ" },
                    { q: "Lieber Autor oder Kritiker?", a: "Autor ‚úçÔ∏è", b: "Kritiker üìù" },
                    { q: "Lieber Bibliothek oder Buchhandlung?", a: "Bibliothek üìö", b: "Buchhandlung üè™" },
                    { q: "Lieber Klassiker oder Bestseller?", a: "Klassiker üìú", b: "Bestseller üî•" },
                    { q: "Lieber Poesie oder Prosa?", a: "Poesie ‚úçÔ∏è", b: "Prosa üìñ" },
                    { q: "Lieber Muttersprache oder Fremdsprache?", a: "Muttersprache üá©üá™", b: "Fremdsprache üåç" },
                    { q: "Lieber Erz√§hler oder Zuh√∂rer?", a: "Erz√§hler üó£Ô∏è", b: "Zuh√∂rer üëÇ" },
                    { q: "Lieber Brief oder E-Mail?", a: "Brief ‚úâÔ∏è", b: "E-Mail üìß" },
                    { q: "Lieber Tagebuch oder Blog?", a: "Tagebuch üìî", b: "Blog üíª" },
                    { q: "Lieber Lyrik oder Epik?", a: "Lyrik ‚úçÔ∏è", b: "Epik üìñ" },
                    { q: "Lieber Wort oder Bild?", a: "Wort üìù", b: "Bild üñºÔ∏è" }
                ]
            },
            "medien_unterhaltung": {
                name: "Medien & Unterhaltung",
                emoji: "üì∫",
                questions: [
                    { q: "Lieber Film oder Serie?", a: "Film üé¨", b: "Serie üì∫" },
                    { q: "Lieber Netflix oder YouTube?", a: "Netflix üü•", b: "YouTube ‚ñ∂Ô∏è" },
                    { q: "Lieber Kino oder zu Hause?", a: "Kino üé¨", b: "Zuhause üì∫" },
                    { q: "Lieber Action oder Drama?", a: "Action üí•", b: "Drama üé≠" },
                    { q: "Lieber Comedy oder Thriller?", a: "Comedy üòÇ", b: "Thriller üïµÔ∏è" },
                    { q: "Lieber Live-TV oder Streaming?", a: "Live-TV üì°", b: "Streaming üì±" },
                    { q: "Lieber Dokumentation oder Spielfilm?", a: "Dokumentation üìπ", b: "Spielfilm üé¨" },
                    { q: "Lieber Originalsprache oder Synchronisation?", a: "Original üó£Ô∏è", b: "Synchronisation üé§" },
                    { q: "Lieber Kurzfilm oder Langfilm?", a: "Kurzfilm ‚è±Ô∏è", b: "Langfilm ‚è∞" },
                    { q: "Lieber Schwarz-Wei√ü oder Farbe?", a: "Schwarz-Wei√ü ‚ö´‚ö™", b: "Farbe üåà" },
                    { q: "Lieber Realit√§t oder Fiktion?", a: "Realit√§t üëÅÔ∏è", b: "Fiktion üé≠" },
                    { q: "Lieber Single-Player oder Multiplayer?", a: "Single üéÆ", b: "Multiplayer üë•" },
                    { q: "Lieber Actionspiel oder Strategiespiel?", a: "Action üí•", b: "Strategie üß†" },
                    { q: "Lieber Konsole oder PC?", a: "Konsole üéÆ", b: "PC üíª" },
                    { q: "Lieber Videospiele spielen oder Brettspiele?", a: "Video üéÆ", b: "Brett üé≤" },
                    { q: "Lieber Kabel oder Streaming?", a: "Kabel üì∫", b: "Streaming üì±" },
                    { q: "Lieber Neuerscheinung oder Klassiker?", a: "Neu üÜï", b: "Klassiker ‚≠ê" },
                    { q: "Lieber Fernseher oder Projektor?", a: "Fernseher üì∫", b: "Projektor üé¨" },
                    { q: "Lieber Reality-TV oder Scripted?", a: "Reality üì∫", b: "Scripted üìù" },
                    { q: "Lieber Binge-Watching oder w√∂chentlich?", a: "Binge üçø", b: "W√∂chentlich üìÖ" }
                ]
            },
            "musik": {
                name: "Musik",
                emoji: "üéµ",
                questions: [
                    { q: "Lieber Rock oder Pop?", a: "Rock üé∏", b: "Pop üé§" },
                    { q: "Lieber laut oder leise Musik h√∂ren?", a: "Laut üîäüé∂", b: "Leise ü§´üéß" },
                    { q: "Lieber Musik mit oder ohne Text?", a: "Mit Text üó£Ô∏èüéµ", b: "Instrumental üéºüéß" },
                    { q: "Lieber Live-Konzert oder Studioaufnahme?", a: "Live üé§", b: "Studio üéß" },
                    { q: "Lieber S√§nger oder Instrumentalist?", a: "S√§nger üé§", b: "Instrumentalist üé∏" },
                    { q: "Lieber Klassik oder Moderne?", a: "Klassik üéª", b: "Moderne üé∏" },
                    { q: "Lieber Gitarre oder Klavier?", a: "Gitarre üé∏", b: "Klavier üéπ" },
                    { q: "Lieber allein oder in der Band?", a: "Allein üé§", b: "Band üë•" },
                    { q: "Lieber Kopfh√∂rer oder Lautsprecher?", a: "Kopfh√∂rer üéß", b: "Lautsprecher üîä" },
                    { q: "Lieber Vinyl oder Digital?", a: "Vinyl üíø", b: "Digital üì±" },
                    { q: "Lieber Songwriter oder Interprete?", a: "Songwriter ‚úçÔ∏è", b: "Interprete üé§" },
                    { q: "Lieber Jazz oder Electronic?", a: "Jazz üé∑", b: "Electronic üéπ" },
                    { q: "Lieber Festival oder Intimkonzert?", a: "Festival üé™", b: "Intim üéµ" },
                    { q: "Lieber Refrain oder Bridge?", a: "Refrain üéµ", b: "Bridge üåâ" },
                    { q: "Lieber Musik machen oder h√∂ren?", a: "Machen üé∏", b: "H√∂ren üéß" },
                    { q: "Lieber Akustik oder Elektrik?", a: "Akustik üé∏", b: "Elektrik ‚ö°" },
                    { q: "Lieber Cover oder Original?", a: "Cover üéµ", b: "Original ‚ú®" },
                    { q: "Lieber Album oder Single?", a: "Album üíø", b: "Single üéµ" },
                    { q: "Lieber Rhythmus oder Melodie?", a: "Rhythmus ü•Å", b: "Melodie üéµ" },
                    { q: "Lieber Bar oder Club?", a: "Bar üç∏", b: "Club üé∂" }
                ]
            },
            "sport": {
                name: "Sport",
                emoji: "‚öΩ",
                questions: [
                    { q: "Lieber Sport im Team oder allein?", a: "Team ‚öΩ", b: "Allein üèÉ‚Äç‚ôÄÔ∏è" },
                    { q: "Lieber Sport gucken oder selber machen?", a: "Gucken üèüÔ∏èüëÄ", b: "Machen ü§∏‚Äç‚ôÇÔ∏èüí™" },
                    { q: "Lieber morgens oder abends trainieren?", a: "Morgens üåÖüèÉ", b: "Abends üåôüí™" },
                    { q: "Lieber Laufen oder Schwimmen?", a: "Laufen üèÉ", b: "Schwimmen üèä" },
                    { q: "Lieber Fu√üball oder Basketball?", a: "Fu√üball ‚öΩ", b: "Basketball üèÄ" },
                    { q: "Lieber Indoor oder Outdoor?", a: "Indoor üè†", b: "Outdoor üå≥" },
                    { q: "Lieber Ausdauer oder Kraft?", a: "Ausdauer üèÉ", b: "Kraft üí™" },
                    { q: "Lieber Wettkampf oder Training?", a: "Wettkampf üèÜ", b: "Training üí™" },
                    { q: "Lieber Mannschaft oder Einzelsport?", a: "Mannschaft üë•", b: "Einzel üèÉ" },
                    { q: "Lieber Tennis oder Badminton?", a: "Tennis üéæ", b: "Badminton üè∏" },
                    { q: "Lieber Radfahren oder Wandern?", a: "Radfahren üö≤üå≥", b: "Wandern üö∂‚Äç‚ôÄÔ∏èüèîÔ∏è" },
                    { q: "Lieber Gym oder Natur?", a: "Gym üèãÔ∏è", b: "Natur üå≤" },
                    { q: "Lieber Profi oder Amateur?", a: "Profi üèÜ", b: "Amateur üéØ" },
                    { q: "Lieber Sieg oder Spa√ü?", a: "Sieg üèÜ", b: "Spa√ü üòä" },
                    { q: "Lieber Sommer- oder Wintersport?", a: "Sommer ‚òÄÔ∏è", b: "Winter ‚ùÑÔ∏è" },
                    { q: "Lieber Kontaktsport oder Nicht-Kontakt?", a: "Kontakt ü§º", b: "Nicht-Kontakt üèÉ" },
                    { q: "Lieber Sprint oder Marathon?", a: "Sprint ‚ö°", b: "Marathon üèÉ" },
                    { q: "Lieber Ball- oder R√ºckschlagsport?", a: "Ball ‚öΩ", b: "R√ºckschlag üéæ" },
                    { q: "Lieber Sportartikel oder nat√ºrliche Bewegung?", a: "Artikel üéæ", b: "Nat√ºrlich üèÉ" },
                    { q: "Lieber Tageszeitung oder Sport-App?", a: "Zeitung üì∞", b: "App üì±" }
                ]
            },
            "technik_wirtschaft": {
                name: "Technik & Wirtschaft",
                emoji: "üíª",
                questions: [
                    { q: "Lieber Apple oder Android?", a: "Apple üçé", b: "Android ü§ñ" },
                    { q: "Lieber Smartphone oder Laptop?", a: "Smartphone üì±", b: "Laptop üíª" },
                    { q: "Lieber Bargeld oder Karte?", a: "Bargeld üíµ", b: "Karte üí≥" },
                    { q: "Lieber Auto oder Bahn?", a: "Auto üöó", b: "Bahn üöÇ" },
                    { q: "Lieber Schreibtisch oder Homeoffice?", a: "B√ºro üè¢", b: "Homeoffice üè°" },
                    { q: "Lieber WhatsApp oder Anruf?", a: "WhatsApp üí¨", b: "Anruf üìû" },
                    { q: "Lieber online shoppen oder im Laden?", a: "Online üõíüíª", b: "Im Laden üõçÔ∏èüö∂" },
                    { q: "Lieber Aktien oder Immobilien?", a: "Aktien üìà", b: "Immobilien üè†" },
                    { q: "Lieber Start-up oder Konzern?", a: "Start-up üöÄ", b: "Konzern üè¢" },
                    { q: "Lieber Innovation oder Stabilit√§t?", a: "Innovation üí°", b: "Stabilit√§t üìä" },
                    { q: "Lieber Cloud oder lokal?", a: "Cloud ‚òÅÔ∏è", b: "Lokal üíæ" },
                    { q: "Lieber Kryptow√§hrung oder Fiat?", a: "Krypto ‚Çø", b: "Fiat üíµ" },
                    { q: "Lieber Automatisierung oder Handarbeit?", a: "Automatisierung ü§ñ", b: "Handarbeit ‚úã" },
                    { q: "Lieber √ñkonomie oder √ñkologie?", a: "√ñkonomie üíº", b: "√ñkologie üåø" },
                    { q: "Lieber B2B oder B2C?", a: "B2B üíº", b: "B2C üõí" },
                    { q: "Lieber Offline oder Online?", a: "Offline üì¥", b: "Online üåê" },
                    { q: "Lieber Freelancer oder Angestellter?", a: "Freelancer üÜì", b: "Angestellter üíº" },
                    { q: "Lieber Kredit oder Sparen?", a: "Kredit üí≥", b: "Sparen üí∞" },
                    { q: "Lieber Risiko oder Sicherheit?", a: "Risiko üé≤", b: "Sicherheit üîí" },
                    { q: "Lieber einmal viel Geld oder jeden Tag ein bisschen?", a: "Einmal viel üí∞üí•", b: "Jeden Tag etwas üí∏üóìÔ∏è" }
                ]
            },
            "diverses": {
                name: "Diverses",
                emoji: "üé≤",
                questions: [
                    { q: "Lieber Sommer oder Winter?", a: "Sommer ‚òÄÔ∏è", b: "Winter ‚ùÑÔ∏è" },
                    { q: "Lieber Urlaub am Strand oder in den Bergen?", a: "Strand üèñÔ∏è", b: "Berge ‚õ∞Ô∏è" },
                    { q: "Lieber Fr√ºhaufsteher oder Langschl√§fer?", a: "Fr√ºh ‚è∞‚òÄÔ∏è", b: "Sp√§t üåôüí§" },
                    { q: "Lieber Sneaker oder Stiefel?", a: "Sneaker üëü", b: "Stiefel üë¢" },
                    { q: "Lieber Holz- oder Metallm√∂bel?", a: "Holz ü™µ", b: "Metall üî©" },
                    { q: "Lieber Jeans oder Stoffhose?", a: "Jeans üëñ", b: "Stoffhose ü©≥" },
                    { q: "Lieber drinnen oder drau√üen feiern?", a: "Drinnen üè†üéâ", b: "Drau√üen üå≥ü•≥" },
                    { q: "Lieber Socken an oder barfu√ü?", a: "Socken an üß¶", b: "Barfu√ü ü¶∂" },
                    { q: "Lieber Couch oder Sessel?", a: "Couch üõãÔ∏è", b: "Sessel ü™ë" },
                    { q: "Lieber Stadt oder Land?", a: "Stadt üèôÔ∏è", b: "Land üèûÔ∏è" },
                    { q: "Lieber Meer oder See?", a: "Meer üåä", b: "See üèûÔ∏èüíß" },
                    { q: "Lieber Fr√ºhling oder Herbst?", a: "Fr√ºhling üå∑", b: "Herbst üçÇ" },
                    { q: "Lieber aufstehen oder liegen bleiben?", a: "Aufstehen üö∂‚Äç‚ôÄÔ∏è", b: "Liegen üõå" },
                    { q: "Lieber Bleistift oder Kugelschreiber?", a: "Bleistift ‚úèÔ∏è", b: "Kugelschreiber üñäÔ∏è" },
                    { q: "Lieber Feste planen oder spontan sein?", a: "Planen üóìÔ∏è", b: "Spontan üéâ" },
                    { q: "Lieber Duschgel oder Seife?", a: "Duschgel üß¥", b: "Seife üßº" },
                    { q: "Lieber drinnen lesen oder drau√üen spazieren?", a: "Drinnen lesen üìñüè†", b: "Drau√üen spazieren üö∂‚Äç‚ôÇÔ∏èüå≤" },
                    { q: "Lieber Zelt oder Hotel?", a: "Zelt ‚õ∫", b: "Hotel üè®" },
                    { q: "Lieber Nachrichten lesen oder h√∂ren?", a: "Lesen üì∞üëÄ", b: "H√∂ren üìªüëÇ" },
                    { q: "Lieber Kerzenlicht oder helles Licht?", a: "Kerzenlicht üî•üïØÔ∏è", b: "Helles Licht üí°‚ú®" },
                    { q: "Lieber kurze oder lange Haare?", a: "Kurz üíá‚Äç‚ôÄÔ∏è‚úÇÔ∏è", b: "Lang üë±‚Äç‚ôÄÔ∏èü¶í" },
                    { q: "Lieber Ananas auf Pizza: Ja oder Nein?", a: "Ananas: Ja üççüçïüëç", b: "Ananas: Nein üççüçïüëé" },
                    { q: "Lieber Stille oder Hintergrundger√§usche beim Arbeiten?", a: "Stille ü§´üîá", b: "Hintergrund üéßüéµ" },
                    { q: "Lieber Bleistift oder Marker?", a: "Bleistift ‚úèÔ∏è", b: "Marker üñçÔ∏è" },
                    { q: "Lieber Eis im Becher oder in der Waffel?", a: "Becher üç®", b: "Waffel üç¶" },
                    { q: "Lieber am Fenster sitzen oder am Gang (Flugzeug/Bahn)?", a: "Fenster üñºÔ∏è", b: "Gang üö™" },
                    { q: "Lieber eine saubere, leere Wohnung oder eine unordentliche, gem√ºtliche?", a: "Sauber & Leer ‚ú®üì¶", b: "Unordentlich & Gem√ºtlich üõãÔ∏èüòå" },
                    { q: "Lieber Kissen weich oder hart?", a: "Weich ‚òÅÔ∏è", b: "Hart üß±" },
                    { q: "Lieber ein Leben lang nur noch Toast oder nur noch Br√∂tchen essen?", a: "Toast üçû", b: "Br√∂tchen ü•ê" },
                    { q: "Lieber in der ersten oder letzten Reihe sitzen (Kino/Theater)?", a: "Erste Reihe ü•á", b: "Letzte Reihe üîö" },
                    { q: "Lieber Marmelade oder Nutella?", a: "Marmelade üçì", b: "Nutella üç´" },
                    { q: "Lieber warm oder kalt trinken?", a: "Warm ‚ô®Ô∏è‚òï", b: "Kalt üßäü•§" },
                    { q: "Lieber Fleisch oder Fisch?", a: "Fleisch ü•©", b: "Fisch üêü" },
                    { q: "Lieber S√º√ükartoffel oder normale Kartoffel?", a: "S√º√ü üç†", b: "Normal ü•î" },
                    { q: "Lieber Hemd oder T-Shirt?", a: "Hemd üëî", b: "T-Shirt üëï" },
                    { q: "Lieber im Hotel fr√ºhst√ºcken oder im Caf√©?", a: "Hotel üè®üç≥", b: "Caf√© ‚òïü•ê" },
                    { q: "Lieber Scharf oder Mild essen?", a: "Scharf üå∂Ô∏èüî•", b: "Mild ü•õüòå" },
                    { q: "Lieber E-Book oder gedrucktes Buch?", a: "E-Book üì±üìö", b: "Gedruckt üìñüå≥" },
                    { q: "Lieber mit √∂ffentlichen Verkehrsmitteln oder mit dem Rad zur Arbeit?", a: "√ñffentlich üöåüöÜ", b: "Fahrrad üö≤" },
                    { q: "Lieber Rotwein oder Wei√üwein?", a: "Rotwein üç∑üî¥", b: "Wei√üwein ü•Ç‚ö™" },
                    { q: "Lieber in der K√ºche oder im Wohnzimmer essen?", a: "K√ºche üßë‚Äçüç≥üçΩÔ∏è", b: "Wohnzimmer üõãÔ∏èüì∫" },
                    { q: "Lieber Salzgeb√§ck oder Chips?", a: "Salzgeb√§ck ü•®", b: "Chips ü•îüí∏" },
                    { q: "Lieber schreiben oder lesen?", a: "Schreiben ‚úçÔ∏è", b: "Lesen üìñ" },
                    { q: "Lieber Krawatte oder Fliege?", a: "Krawatte üëî", b: "Fliege üéÄ" },
                    { q: "Lieber glatt oder lockig?", a: "Glatt üíá‚Äç‚ôÄÔ∏èüìè", b: "Lockig üíÜ‚Äç‚ôÄÔ∏èüåÄ" },
                    { q: "Lieber Taschenlampe oder Kerze?", a: "Taschenlampe üî¶", b: "Kerze üïØÔ∏è" },
                    { q: "Lieber nur noch Gem√ºse oder nur noch Obst essen?", a: "Gem√ºse ü•¶ü•¨", b: "Obst üçéüçä" },
                    { q: "Lieber nur noch M√ºtzen oder nur noch Schals tragen?", a: "M√ºtzen üß¢üëí", b: "Schals üß£üß£" },
                    { q: "Lieber immer p√ºnktlich oder immer gute Laune?", a: "P√ºnktlich ‚è∞‚úÖ", b: "Gute Laune üòÑü•≥" },
                    { q: "Lieber Suppe mit Einlage oder pur?", a: "Mit Einlage üçúüç≤", b: "Pur ü•£üíß" },
                    { q: "Lieber S√º√üigkeiten im K√ºhlschrank oder ungek√ºhlt?", a: "Kalt üßäüç¨", b: "Zimmerwarm üå°Ô∏èüç≠" },
                    { q: "Lieber auf dem Bauch oder auf der Seite schlafen?", a: "Bauch ‚¨áÔ∏èüõå", b: "Seite ‚Ü™Ô∏èüò¥" },
                    { q: "Lieber Jeans mit L√∂chern oder ohne?", a: "Mit L√∂chern üëñüï≥Ô∏è", b: "Ohne L√∂cher üëñ‚ú®" },
                    { q: "Lieber wei√üe oder bunte W√§sche?", a: "Wei√üe ‚ö™üß∫", b: "Bunte üåàüëï" },
                    { q: "Lieber Nudeln al dente oder weich?", a: "Al Dente üëåüçù", b: "Weich üò¥üçú" },
                    { q: "Lieber F√ºller oder Kugelschreiber?", a: "F√ºller üñãÔ∏è‚ú®", b: "Kugelschreiber üñäÔ∏èüí™" },
                    { q: "Lieber St√§dtetrip oder Wellness?", a: "St√§dtetrip üèôÔ∏è", b: "Wellness üßò‚Äç‚ôÄÔ∏è" },
                    { q: "Lieber duschen oder baden?", a: "Duschen üöø", b: "Baden üõÅ" }
                ]
            }
        };
        
        // Flache Liste aller Fragen mit Kategorie-Information
        function getAllQuestions(activeCategories = []) {
            let allQuestions = [];
            if(activeCategories.length === 0) {
                // Falls keine Kategorien aktiv sind, verwende alle
                activeCategories = Object.keys(questionCategories);
            }
            
            activeCategories.forEach(catKey => {
                if(questionCategories[catKey] && questionCategories[catKey].questions) {
                    questionCategories[catKey].questions.forEach(q => {
                        allQuestions.push({ ...q, category: catKey });
                    });
                }
            });
            return allQuestions;
        }

        function getRandomUnusedQuestion(usedQuestions = [], activeCategories = [], lastCategory = null) {
            const questions = getAllQuestions(activeCategories);
            if(questions.length === 0) {
                console.error('Keine Fragen verf√ºgbar!');
                return { question: { q: "Keine Frage verf√ºgbar", a: "A", b: "B" }, index: -1, category: null };
            }
            const available = questions.filter((q, idx) => !usedQuestions.includes(idx));
            if(available.length === 0) {
                const randomIdx = Math.floor(Math.random() * questions.length);
                const q = questions[randomIdx];
                if(!q || !q.q) {
                    console.error('Ung√ºltige Frage gefunden:', q);
                    return { question: questions[0] || { q: "Fehler", a: "A", b: "B" }, index: 0, category: null };
                }
                return { question: q, index: randomIdx, category: q.category };
            }
            
            // Wenn mehrere Kategorien aktiv sind und eine letzte Kategorie bekannt ist,
            // vermeide Fragen aus derselben Kategorie
            let filteredAvailable = available;
            if(activeCategories.length > 1 && lastCategory) {
                const fromOtherCategories = available.filter(q => q.category !== lastCategory);
                if(fromOtherCategories.length > 0) {
                    filteredAvailable = fromOtherCategories;
                }
            }
            
            const randomQ = filteredAvailable[Math.floor(Math.random() * filteredAvailable.length)];
            if(!randomQ || !randomQ.q) {
                console.error('Ung√ºltige Frage gefunden:', randomQ);
                return { question: questions[0] || { q: "Fehler", a: "A", b: "B" }, index: 0, category: null };
            }
            return { question: randomQ, index: questions.indexOf(randomQ), category: randomQ.category };
        }
        const cardInfo = {
            card_oil: { label: "üõ¢Ô∏è √ñlfass", desc: "Verdoppelt deinen n√§chsten Angriff." },
            card_mirror: { label: "ü™û Spiegel", desc: "Der n√§chste Angriff prallt zur√ºck." },
            card_ice: { label: "üßä Eisw√ºrfel", desc: "K√ºhlt dich in der n√§chsten Runde automatisch ab." }
        };

        // --- AUTO LOGIN ---
        if(myName && roomId) {
            document.getElementById('inpName').value = myName;
            if(document.getElementById('inpEmoji')) {
                document.getElementById('inpEmoji').value = myEmoji;
                // Aktualisiere Emoji-Galerie wenn vorhanden
                const gallery = document.getElementById('emojiGallery');
                if(gallery) {
                    gallery.querySelectorAll('.emoji-card').forEach((card) => {
                        const cardEmoji = card.getAttribute('data-emoji');
                        if(cardEmoji === myEmoji) {
                            card.classList.add('selected');
                        } else {
                            card.classList.remove('selected');
                        }
                    });
                }
                currentEmojiIndex = availableEmojis.indexOf(myEmoji);
                if(currentEmojiIndex === -1) currentEmojiIndex = 0;
            }
            window.selectedRoomId = roomId;
            setTimeout(() => joinGame(), 500);
        }

        // --- MENU / START CONTROLS ---
        window.toggleMenu = () => {
            document.getElementById('adminDrawer').classList.toggle('open');
            document.getElementById('menuOverlay').classList.toggle('open');
        };
        function ensureName() {
            const name = document.getElementById('inpName').value.trim();
            if(!name) {
                showToast("Bitte gib zuerst deinen Namen ein.");
                document.getElementById('inpName').focus();
                return false;
            }
            return true;
        }

        window.openHostSettings = () => {
            if(!ensureName()) return;
            const panel = document.getElementById('hostSettings');
            const join = document.getElementById('joinPanel');
            join.classList.add('hidden');
            panel.classList.toggle('hidden');
            if(!panel.classList.contains('hidden')) {
                renderCategorySelection();
            }
        };
        
        function renderCategorySelection() {
            const container = document.getElementById('categorySelection');
            if(!container) return;
            
            // Erstelle "Alle Kategorien"-Button zuerst
            const allCategoriesButton = `
                <div class="category-card" data-category="all" onclick="selectAllCategories()" style="border:2px solid #ff4500; background:linear-gradient(145deg, #3e2e2e, #2a1a1a);">
                    <div class="category-emoji">üåü</div>
                    <div class="category-name">Alle Kategorien</div>
                </div>
            `;
            
            // Erstelle Kategorie-Karten
            const categoryCards = Object.keys(questionCategories).map(catKey => {
                const cat = questionCategories[catKey];
                return `
                    <div class="category-card" data-category="${catKey}" onclick="toggleCategory('${catKey}')">
                        <div class="category-emoji">${cat.emoji}</div>
                        <div class="category-name">${cat.name}</div>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = allCategoriesButton + categoryCards;
            
            // Keine Kategorien standardm√§√üig aktiviert
        }
        
        window.toggleCategory = (catKey) => {
            const card = document.querySelector(`[data-category="${catKey}"]`);
            if(card) {
                card.classList.toggle('selected');
            }
            // Wenn eine einzelne Kategorie deaktiviert wird, deaktiviere auch "Alle Kategorien"
            const allCategoriesCard = document.querySelector(`[data-category="all"]`);
            if(allCategoriesCard && allCategoriesCard.classList.contains('selected')) {
                allCategoriesCard.classList.remove('selected');
            }
        };
        
        window.selectAllCategories = () => {
            const allCategoriesCard = document.querySelector(`[data-category="all"]`);
            const isCurrentlySelected = allCategoriesCard && allCategoriesCard.classList.contains('selected');
            
            if(isCurrentlySelected) {
                // Wenn bereits ausgew√§hlt, w√§hle alle ab
                Object.keys(questionCategories).forEach(catKey => {
                    const card = document.querySelector(`[data-category="${catKey}"]`);
                    if(card) {
                        card.classList.remove('selected');
                    }
                });
                allCategoriesCard.classList.remove('selected');
            } else {
                // W√§hle alle Kategorien aus
                Object.keys(questionCategories).forEach(catKey => {
                    const card = document.querySelector(`[data-category="${catKey}"]`);
                    if(card) {
                        card.classList.add('selected');
                    }
                });
                allCategoriesCard.classList.add('selected');
            }
        };
        
        window.toggleGameMode = (mode) => {
            document.querySelectorAll('.game-mode-card').forEach(card => {
                card.classList.remove('selected');
            });
            const card = document.querySelector(`[data-mode="${mode}"]`);
            if(card) {
                card.classList.add('selected');
            }
        };
        
        function getSelectedGameMode() {
            const selectedCard = document.querySelector('.game-mode-card.selected');
            return selectedCard ? selectedCard.getAttribute('data-mode') : 'party';
        }
        
        function getSelectedCategories() {
            const selected = [];
            const allCategoriesCard = document.querySelector(`[data-category="all"]`);
            const isAllSelected = allCategoriesCard && allCategoriesCard.classList.contains('selected');
            
            if(isAllSelected) {
                // Wenn "Alle Kategorien" ausgew√§hlt ist, gib alle Kategorien zur√ºck
                return Object.keys(questionCategories);
            } else {
                // Sonst sammle nur die einzeln ausgew√§hlten Kategorien
                document.querySelectorAll('.category-card.selected').forEach(card => {
                    const catKey = card.getAttribute('data-category');
                    if(catKey !== 'all') { // Ignoriere "Alle Kategorien"-Button
                        selected.push(catKey);
                    }
                });
                return selected;
            }
        }
        window.openJoinPanel = () => {
            if(!ensureName()) return;
            const panel = document.getElementById('joinPanel');
            const host = document.getElementById('hostSettings');
            host.classList.add('hidden');
            panel.classList.toggle('hidden');
            if(!panel.classList.contains('hidden')) {
                loadRoomList();
            }
        };
        
        // Cleanup-Funktion: L√∂sche leere R√§ume (ohne Spieler) und "tote" R√§ume
        async function cleanupEmptyRooms() {
            try {
                const roomsRef = collection(db, "lobbies");
                const q = query(roomsRef);
                const querySnapshot = await getDocs(q);
                
                const deletePromises = [];
                const now = Date.now();
                const MIN_ROOM_AGE_MS = 30000; // 30 Sekunden - sch√ºtze neu erstellte R√§ume
                
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const players = data.players || {};
                    // Filtere echte Spieler (nicht null/undefined/leere Objekte)
                    const realPlayers = Object.keys(players).filter(p => {
                        const playerData = players[p];
                        return playerData !== undefined && playerData !== null && typeof playerData === 'object' && Object.keys(playerData).length > 0;
                    });
                    
                    // Pr√ºfe ob Raum beitretbar ist (muss hostName haben und Status "lobby")
                    const hasHostName = data.hostName && typeof data.hostName === 'string' && data.hostName.trim().length > 0;
                    const isValidStatus = data.status === 'lobby';
                    
                    // Pr√ºfe ob Raum zu neu ist (gesch√ºtzt vor Cleanup)
                    let roomAge = Infinity;
                    if(data.createdAt) {
                        if(data.createdAt.toMillis) {
                            // Firestore Timestamp
                            roomAge = now - data.createdAt.toMillis();
                        } else if(typeof data.createdAt === 'number') {
                            // Unix Timestamp
                            roomAge = now - data.createdAt;
                        } else if(data.createdAt.seconds) {
                            // Firestore Timestamp (Alternative)
                            roomAge = now - (data.createdAt.seconds * 1000);
                        }
                    }
                    const isNewRoom = roomAge < MIN_ROOM_AGE_MS;
                    
                    // L√∂sche R√§ume wenn:
                    // 1. Keine echten Spieler vorhanden
                    // 2. ODER nur noch ein Spieler im Winner-Screen (Geisterlobby)
                    // 3. ODER geschlossener Status
                    // 4. ODER kein g√ºltiger Host-Name (toter Raum)
                    // 5. ODER Status nicht "lobby" (au√üer winner/voting die noch aktiv sein k√∂nnten)
                    // WICHTIG: R√§ume im "lobby"-Status mit mindestens einem Spieler (Host wartet auf Spieler) NICHT l√∂schen
                    // WICHTIG: Neu erstellte R√§ume (unter 30 Sekunden) NICHT l√∂schen
                    const isWinnerScreenWithOnePlayer = data.status === 'winner' && realPlayers.length === 1;
                    const isLobbyWithHost = data.status === 'lobby' && realPlayers.length >= 1 && hasHostName;
                    const shouldDelete = (realPlayers.length === 0 || 
                                       isWinnerScreenWithOnePlayer ||
                                       data.status === 'closed' || 
                                       !hasHostName ||
                                       (data.status && data.status !== 'lobby' && data.status !== 'game' && data.status !== 'result' && data.status !== 'winner' && data.status !== 'voting' && data.status !== 'countdown'))
                                       && !isLobbyWithHost // NICHT l√∂schen wenn Host in Lobby wartet
                                       && !isNewRoom; // NICHT l√∂schen wenn Raum zu neu ist (unter 30 Sekunden)
                    
                    if(shouldDelete) {
                        deletePromises.push(deleteDoc(doc.ref));
                        console.log('Leerer/toter Raum gel√∂scht:', doc.id, {
                            realPlayers: realPlayers.length,
                            status: data.status,
                            hasHostName,
                            roomAge: roomAge < Infinity ? `${Math.round(roomAge / 1000)}s` : 'unbekannt',
                            reason: realPlayers.length === 0 ? 'keine Spieler' : 
                                   isWinnerScreenWithOnePlayer ? 'Winner-Screen mit nur einem Spieler (Geisterlobby)' :
                                   data.status === 'closed' ? 'geschlossen' :
                                   !hasHostName ? 'kein Host-Name' : 'ung√ºltiger Status'
                        });
                    }
                });
                
                if(deletePromises.length > 0) {
                    await Promise.all(deletePromises);
                    console.log(`${deletePromises.length} leere/tote R√§ume bereinigt`);
                }
            } catch(error) {
                console.error('Fehler beim Bereinigen leerer R√§ume:', error);
            }
        }

        // Manuelle Funktion zum L√∂schen spezifischer "toter" R√§ume (Einmalige Aktion)
        window.forceDeleteDeadRooms = async () => {
            try {
                const roomsRef = collection(db, "lobbies");
                const q = query(roomsRef, where("status", "==", "lobby"));
                const querySnapshot = await getDocs(q);
                
                const deletePromises = [];
                const targetHostNames = ['Niklas', 'asdfasdf', 'fasdff']; // Die drei zu l√∂schenden R√§ume
                
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const hostName = data.hostName;
                    
                    // L√∂sche R√§ume mit diesen Host-Namen
                    if(hostName && targetHostNames.includes(hostName)) {
                        deletePromises.push(deleteDoc(doc.ref));
                        console.log('Manuell gel√∂schter toter Raum:', doc.id, 'Host:', hostName);
                    }
                });
                
                if(deletePromises.length > 0) {
                    await Promise.all(deletePromises);
                    console.log(`${deletePromises.length} tote R√§ume manuell gel√∂scht`);
                    if(typeof showToast === 'function') {
                        showToast(`${deletePromises.length} tote R√§ume gel√∂scht`);
                    }
                } else {
                    console.log('Keine toten R√§ume zum L√∂schen gefunden');
                }
            } catch(error) {
                console.error('Fehler beim manuellen L√∂schen toter R√§ume:', error);
            }
        };
        
        window.loadRoomList = async () => {
            try {
                // Automatische Bereinigung deaktiviert
                
                const roomsRef = collection(db, "lobbies");
                const q = query(roomsRef, where("status", "==", "lobby"));
                const querySnapshot = await getDocs(q);
                
                const rooms = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const players = data.players || {};
                    // Filtere echte Spieler (nicht null/undefined/leere Objekte)
                    const realPlayers = Object.keys(players).filter(p => {
                        const playerData = players[p];
                        return playerData !== undefined && playerData !== null && typeof playerData === 'object' && Object.keys(playerData).length > 0;
                    });
                    
                    // Zeige nur R√§ume mit echten Spielern und g√ºltigem Host-Namen
                    const hasHostName = data.hostName && typeof data.hostName === 'string' && data.hostName.trim().length > 0;
                    if(hasHostName && realPlayers.length > 0) {
                        rooms.push({
                            id: doc.id,
                            hostName: data.hostName,
                            playerCount: realPlayers.length,
                            password: data.password || "",
                            hasPassword: !!(data.password && data.password.trim().length > 0)
                        });
                    }
                });
                
                const roomListEl = document.getElementById('roomList');
                const inpCodeEl = document.getElementById('inpCode');
                const inpPasswordEl = document.getElementById('inpPassword');
                
                if(rooms.length === 0) {
                    roomListEl.style.display = 'none';
                    inpCodeEl.style.display = 'none';
                    inpPasswordEl.style.display = 'none';
                    showToast("Keine offenen R√§ume gefunden. Erstelle einen neuen Raum!");
                } else {
                    roomListEl.style.display = 'block';
                    inpCodeEl.style.display = 'none';
                    inpPasswordEl.style.display = 'none';
                    roomListEl.innerHTML = rooms.map(room => {
                        // XSS-Schutz: Escape hostName und roomId
                        const safeHostName = escapeHtml(room.hostName);
                        const safeRoomId = escapeHtml(room.id);
                        return `
                        <div class="card" style="padding:15px; margin-bottom:10px; cursor:pointer; background:linear-gradient(145deg, #1e1e1e, #252525);" onclick="selectRoom('${safeRoomId}', ${room.hasPassword ? 'true' : 'false'})">
                            <div style="font-weight:bold; font-size:1.1rem; color:#ff8c00;">
                                ${room.hasPassword ? 'üîí ' : ''}Raum von ${safeHostName}
                            </div>
                            <div style="font-size:0.85rem; color:#aaa; margin-top:5px;">üë• ${room.playerCount} Spieler</div>
                        </div>
                    `;
                    }).join('');
                }
            } catch(error) {
                console.error('Fehler beim Laden der R√§ume:', error);
                showToast("Fehler beim Laden der R√§ume");
            }
        };
        
        window.selectRoom = (selectedRoomId, hasPassword) => {
            // Speichere den ausgew√§hlten Raum-Code
            window.selectedRoomId = selectedRoomId;
            
            // Verstecke Code-Eingabefeld (nicht mehr ben√∂tigt)
            document.getElementById('inpCode').style.display = 'none';
            
            // Zeige nur Passwort-Feld wenn n√∂tig
            if(hasPassword) {
                document.getElementById('inpPassword').style.display = 'block';
                document.getElementById('inpPassword').placeholder = 'Passwort erforderlich';
                document.getElementById('inpPassword').value = '';
                document.getElementById('inpPassword').focus();
            } else {
                document.getElementById('inpPassword').style.display = 'none';
                document.getElementById('inpPassword').value = '';
                // Wenn kein Passwort, direkt beitreten
                joinGame();
            }
            // Verstecke Raumliste
            document.getElementById('roomList').style.display = 'none';
        };
        window.toggleLobbyReady = async () => {
            if(!roomId) return;
            const current = !!(globalData?.lobbyReady?.[myName]);
            await updateDoc(doc(db, "lobbies", roomId), {
                [`lobbyReady.${myName}`]: !current
            });
        };

        // --- CREATE GAME ---
        window.createGame = async () => {
            const nameInput = document.getElementById('inpName').value.trim();
            const emojiInput = document.getElementById('inpEmoji').value || 'üòä';
            const gender = "divers"; // Deaktiviert, aber behalten
            const gameMode = getSelectedGameMode();
            const selectedCategories = getSelectedCategories();
            const roomPasswordInput = document.getElementById('inpRoomPassword').value.trim();
            
            // Input-Validierung und Sanitierung (Sicherheitsfix)
            const name = sanitizeInput(nameInput, 'name');
            const emoji = sanitizeInput(emojiInput, 'emoji') || 'üòä';
            const roomPassword = sanitizeInput(roomPasswordInput, 'password');
            
            if(!name) {
                showToast("Bitte gib einen g√ºltigen Namen ein!");
                return;
            }
            
            if(selectedCategories.length === 0) {
                showToast("Bitte w√§hle mindestens eine Kategorie aus!");
                return;
            }
            
            // Konfiguration basierend auf Spielmodus
            let dmg, speed, startTemp, maxTemp;
            if(gameMode === 'strategisch') {
                dmg = 10;
                speed = 1.0;
                startTemp = 0;
                maxTemp = 120;
            } else { // party
                dmg = 20; // Schaden f√ºr Angriff
                speed = 1.5;
                startTemp = 0;
                maxTemp = 100;
            }
            
            const code = Math.random().toString(36).substring(2,6).toUpperCase();
            myName = name;
            myEmoji = emoji;
            myGender = gender;
            roomId = code;
            sessionStorage.setItem("hk_name", name);
            sessionStorage.setItem("hk_emoji", emoji);
            sessionStorage.setItem("hk_gender", gender);
            sessionStorage.setItem("hk_room", code);
            
            // Erste Frage aus aktiven Kategorien
            const firstQuestion = getAllQuestions(selectedCategories)[0] || { q: "Willkommen zu Hitzkopf!", a: "A", b: "B" };
            const firstCategory = firstQuestion.category || null;

            await setDoc(doc(db, "lobbies", code), {
                host: name,
                hostName: name, // F√ºr Raumliste
                status: "lobby",
                createdAt: serverTimestamp(), // Zeitstempel f√ºr Cleanup-Schutz
                players: { [name]: { temp: startTemp, inventory: [], gender: gender, emoji: emoji, consecutiveWrongAnswers: 0 } },
                config: { dmg: dmg, speed: speed, startTemp: startTemp, maxTemp: maxTemp, gameMode: gameMode, categories: selectedCategories },
                votes: {},
                ready: [],
                log: [],
                hotseat: "",
                currentQ: firstQuestion,
                roundId: 0,
                lobbyReady: {},
                countdownEnds: null,
                usedQuestions: [],
                eliminatedShown: [],
                rematchVotes: {},
                winner: null,
                password: roomPassword || "", // Leer = √∂ffentlich
                lastQuestionCategory: firstCategory,
                pendingAttacks: {}, // Sammelt Angriffe: { targetName: [{ attacker, dmg, hasOil }] }
                attackDecisions: {}, // Trackt welche Spieler ihre Angriffsentscheidung getroffen haben
                popupConfirmed: {} // Trackt welche Spieler ihre Attack-Feedback-Popups best√§tigt haben
            });
            
            connectToLobby();
        };

        // --- JOIN GAME ---
        window.joinGame = async () => {
            const nameInput = document.getElementById('inpName').value.trim();
            const emojiInput = document.getElementById('inpEmoji').value || 'üòä';
            const gender = "divers"; // Deaktiviert, aber behalten
            
            // Input-Validierung und Sanitierung (Sicherheitsfix)
            const name = sanitizeInput(nameInput, 'name');
            const emoji = sanitizeInput(emojiInput, 'emoji') || 'üòä';
            
            // Verwende ausgew√§hlten Raum-Code oder versuche aus Input-Feld (Fallback)
            const codeInput = window.selectedRoomId || document.getElementById('inpCode').value.trim().toUpperCase();
            const passwordInput = document.getElementById('inpPassword').value.trim();
            
            // Validiere Raum-Code (sollte nur alphanumerisch sein, max 6 Zeichen)
            const code = codeInput.replace(/[^A-Z0-9]/g, '').substring(0, 6);
            const password = sanitizeInput(passwordInput, 'password');
            
            if(!name) {
                showToast("Bitte gib deinen Namen ein!");
                return;
            }
            
            if(!code || code.length < 4) {
                showToast("Bitte gib einen g√ºltigen Raum-Code ein!");
                return;
            }
            
            if(!code) {
                showToast("Bitte w√§hle einen Raum aus der Liste aus!");
                return;
            }
            
            // Passwortpr√ºfung
            const ref = doc(db, "lobbies", code);
            const snap = await getDoc(ref);
            if(!snap.exists()) {
                showToast("Lobby nicht gefunden! Bitte w√§hle einen anderen Raum.");
                return;
            }
            
            const roomData = snap.data();
            const roomPassword = roomData.password || "";
            
            // Wenn Raum ein Passwort hat, muss es √ºbereinstimmen
            if(roomPassword && roomPassword.trim().length > 0) {
                if(!password || password !== roomPassword) {
                    showToast("Falsches Passwort! Bitte versuche es erneut.");
                    return;
                }
            }
            
            myName = name;
            myEmoji = emoji;
            myGender = gender;
            roomId = code;
            sessionStorage.setItem("hk_name", name);
            sessionStorage.setItem("hk_emoji", emoji);
            sessionStorage.setItem("hk_gender", gender);
            sessionStorage.setItem("hk_room", code);

            // data wird bereits oben geladen (siehe Passwortpr√ºfung)
            const data = snap.data();
            const startTemp = data.config?.startTemp || 0;
            if(!data.players[name]) {
                await updateDoc(ref, { [`players.${name}`]: { temp: startTemp, inventory: [], gender: gender, emoji: emoji, consecutiveWrongAnswers: 0 } });
            } else {
                // Emoji und Geschlecht aktualisieren falls bereits vorhanden
                await updateDoc(ref, { 
                    [`players.${name}.gender`]: gender,
                    [`players.${name}.emoji`]: emoji
                });
            }
            connectToLobby();
        };

        // --- CONNECT TO LOBBY ---
        function connectToLobby() {
            onSnapshot(doc(db, "lobbies", roomId), (snap) => {
                if(!snap.exists()) { 
                    sessionStorage.clear(); 
                    location.reload(); 
                    return; 
                }
                const data = snap.data();
                
                // WICHTIG: Pr√ºfe ob sich ready ge√§ndert hat (f√ºr renderResult-Update)
                const readyChanged = globalData && JSON.stringify(globalData.ready || []) !== JSON.stringify(data.ready || []);
                
                // WICHTIG: Pr√ºfe ob im Winner-Screen nur noch ein Spieler √ºbrig ist - entferne diesen automatisch
                if(data.status === 'winner') {
                    const players = data.players || {};
                    const remainingPlayers = Object.keys(players).filter(p => {
                        const playerData = players[p];
                        return playerData !== undefined && playerData !== null && typeof playerData === 'object' && Object.keys(playerData).length > 0;
                    });
                    
                    // Wenn nur noch ein Spieler √ºbrig ist (und dieser nicht ich bin), entferne diesen automatisch
                    if(remainingPlayers.length === 1 && remainingPlayers[0] !== myName && isHost) {
                        const lastPlayer = remainingPlayers[0];
                        console.log('Winner-Screen: Nur noch ein Spieler √ºbrig (nicht ich), entferne diesen automatisch:', lastPlayer);
                        const ref = doc(db, "lobbies", roomId);
                        updateDoc(ref, {
                            [`players.${lastPlayer}`]: deleteField()
                        }).then(() => {
                            // Pr√ºfe ob Raum jetzt leer ist
                            getDoc(ref).then(snap => {
                                if(snap.exists()) {
                                    const data = snap.data();
                                    const players = data.players || {};
                                    const realPlayers = Object.keys(players).filter(p => {
                                        const playerData = players[p];
                                        return playerData !== undefined && playerData !== null && typeof playerData === 'object' && Object.keys(playerData).length > 0;
                                    });
                                    if(realPlayers.length === 0) {
                                        deleteDoc(ref);
                                        console.log('Leerer Raum gel√∂scht (Winner-Screen, letzter Spieler entfernt):', roomId);
                                    }
                                }
                            }).catch(err => {
                                console.error('Fehler beim Pr√ºfen des leeren Raums:', err);
                            });
                        }).catch(err => {
                            console.error('Fehler beim Entfernen des letzten Spielers:', err);
                        });
                    }
                }
                
                globalData = data;

                // Pr√ºfe ob Angriffe ausgef√ºhrt wurden und zeige beim Angegriffenen
                const meState = data.players?.[myName];
                if(meState) {
                    // Debug: Logge ready-Status wenn sich √§ndert
                    if(data.ready !== undefined) {
                        const currentReady = Array.isArray(data.ready) ? data.ready : [];
                        if(currentReady.length > 0 || (globalData && globalData.ready && globalData.ready.length !== currentReady.length)) {
                            console.log('onSnapshot: ready-Liste aktualisiert:', currentReady, 'L√§nge:', currentReady.length);
                        }
                    }
                    
                    // Pr√ºfe ob Angriffe ausgef√ºhrt wurden (durch executePendingAttacks)
                    // Zeige Popup f√ºr ALLE Spieler (auch die nicht angegriffenen)
                    // Warte bis attackResults vollst√§ndig sind (roundRecapShown = true)
                    const recapShown = data.roundRecapShown || false;
                    
                    // WICHTIG: Popup-Logik nur im result-Status ausf√ºhren, nicht wenn sich nur ready √§ndert
                    // UND nur wenn sich attackResults ge√§ndert haben (nicht wenn nur ready ge√§ndert wurde)
                    if(data.status === 'result' && data.attackResults && data.attackResults[myName] !== undefined && recapShown && !readyChanged) {
                        const result = data.attackResults[myName];
                        // Erstelle einen eindeutigen Schl√ºssel f√ºr dieses Ergebnis
                        const resultKey = `${result.totalDmg}-${JSON.stringify(result.attackDetails || [])}-${recapShown}`;
                        
                        // Zeige Popup nur einmal pro eindeutigem Ergebnis und nur wenn Modal nicht bereits offen ist
                        const modal = document.getElementById('attackModal');
                        const isModalOpen = modal && modal.style.display === 'flex';
                        
                        // WICHTIG: Verhindere erneutes Ausl√∂sen des Popups wenn nur ready-Status √§ndert
                        // Pr√ºfe ob attackResults unver√§ndert sind (nur ready ge√§ndert)
                        // UND pr√ºfe ob das Modal bereits einmal angezeigt wurde
                        if(resultKey === lastAttackResultKey) {
                            // Key ist gleich = attackResults haben sich nicht ge√§ndert, nur ready wurde ge√§ndert
                            // √úberspringe erneutes Ausl√∂sen des Popups
                            console.log('Popup-Logik: √úberspringe erneutes Ausl√∂sen - resultKey unver√§ndert:', resultKey);
                            return;
                        }
                        
                        // Zus√§tzliche Pr√ºfung: Wenn das Modal bereits einmal angezeigt wurde, nicht erneut anzeigen
                        if(isModalOpen) {
                            console.log('Popup-Logik: Modal bereits offen, √ºberspringe erneutes Ausl√∂sen');
                            return;
                        }
                        
                        // Pr√ºfe ob bereits ein Popup-Trigger f√ºr diesen Key in Gang ist
                        if(resultKey !== lastAttackResultKey && !isModalOpen) {
                            // Setze lastAttackResultKey SOFORT um mehrfache Ausl√∂sung zu verhindern
                            lastAttackResultKey = resultKey;
                            
                            console.log('Attack-Feedback f√ºr', myName, ':', result);
                            console.log('Attack-Feedback Debug:', {
                                totalDmg: result.totalDmg,
                                attackers: result.attackers,
                                attackDetails: result.attackDetails,
                                attackersLength: result.attackers?.length || 0,
                                attackDetailsLength: result.attackDetails?.length || 0,
                                resultKey,
                                lastAttackResultKey: lastAttackResultKey
                            });
                            
                            // Pr√ºfe sofort nochmal ob Modal bereits ge√∂ffnet ist (doppelter Check)
                            const modalDoubleCheck = document.getElementById('attackModal');
                            const isModalOpenDoubleCheck = modalDoubleCheck && modalDoubleCheck.style.display === 'flex';
                            
                            if(!isModalOpenDoubleCheck && !isOpeningAttackModal) {
                                // √ñffne Modal direkt ohne setTimeout
                                triggerAttackFeedback(result);
                            } else {
                                console.log('Popup-Logik: Modal bereits ge√∂ffnet oder wird ge√∂ffnet, √ºberspringe triggerAttackFeedback');
                                // Setze lastAttackResultKey zur√ºck wenn Modal bereits offen ist, damit es sp√§ter erneut versucht werden kann
                                if(isModalOpenDoubleCheck) {
                                    lastAttackResultKey = null;
                                }
                            }
                            
                            // Entferne nach Anzeige (mit l√§ngerer Verz√∂gerung damit alle sehen k√∂nnen - 8 Sekunden)
                            setTimeout(() => {
                                if(isHost) {
                                    const newResults = { ...(data.attackResults || {}) };
                                    delete newResults[myName];
                                    updateDoc(doc(db, "lobbies", roomId), { attackResults: newResults }).catch(console.error);
                                }
                            }, 8000);
                        }
                    } else if(!data.attackResults || data.attackResults[myName] === undefined) {
                        // Wenn attackResults entfernt wurde, zur√ºcksetzen
                        if(lastAttackResultKey !== null) {
                            lastAttackResultKey = null;
                        }
                    }
                    lastMyTemp = meState.temp;
                } else {
                    lastMyTemp = null;
                }

                // Pr√ºfe ob Raum leer ist und l√∂sche automatisch
                const players = data.players || {};
                const playerCount = Object.keys(players).filter(p => players[p] !== undefined && players[p] !== null).length;
                
                if(playerCount === 0 && isHost) {
                    // Raum ist leer, l√∂sche automatisch
                    const ref = doc(db, "lobbies", roomId);
                    deleteDoc(ref).catch(console.error);
                    console.log('Leerer Raum automatisch gel√∂scht:', roomId);
                    sessionStorage.clear();
                    setTimeout(() => location.reload(), 500);
                    return;
                }
                
                if(data.status === 'closed') {
                    if(!lobbyClosedHandled) {
                        lobbyClosedHandled = true;
                        showToast("üõë Host hat die Lobby beendet.");
                    }
                    sessionStorage.clear();
                    setTimeout(() => location.reload(), 200);
                    return;
                }
                
                isHost = (data.host === myName);
                if(isHost) {
                    document.getElementById('hostControls').style.display = 'block';
                    document.getElementById('btnHostStart').style.display = 'block';
                    document.getElementById('lblWait').style.display = 'none';
                }

                // RENDER
                renderThermos(data.players, 'gridGame');
                renderThermos(data.players, 'gridResult');
                renderLog(data.log);

                // DEATH CHECK - Spieler mit 100¬∞ fliegen raus, k√∂nnen aber zuschauen
                const maxTemp = data.config?.maxTemp || 100;
                const activePlayers = Object.keys(data.players).filter(p => data.players[p].temp < maxTemp);
                const eliminatedPlayers = Object.keys(data.players).filter(p => data.players[p].temp >= maxTemp);
                
                // Eliminierte Spieler permanent als "Ready" markieren, damit sie nicht blockieren
                if(eliminatedPlayers.length > 0 && isHost) {
                    const currentReady = data.ready || [];
                    const updatedReady = [...currentReady];
                    let needsUpdate = false;
                    
                    eliminatedPlayers.forEach(eliminated => {
                        if(!updatedReady.includes(eliminated)) {
                            updatedReady.push(eliminated);
                            needsUpdate = true;
                        }
                        
                        const eliminatedShown = data.eliminatedShown || [];
                        if(!eliminatedShown.includes(eliminated)) {
                            // Markiere als gezeigt
                            updateDoc(doc(db, "lobbies", roomId), {
                                eliminatedShown: arrayUnion(eliminated)
                            }).catch(console.error);
                        }
                    });
                    
                    // Aktualisiere ready-Liste mit eliminierten Spielern
                    if(needsUpdate) {
                        updateDoc(doc(db, "lobbies", roomId), {
                            ready: updatedReady
                        }).catch(console.error);
                    }
                }
                
                // Zeige Animation f√ºr alle (auch wenn nicht Host)
                eliminatedPlayers.forEach(eliminated => {
                    const eliminatedShown = data.eliminatedShown || [];
                    if(eliminatedShown.includes(eliminated)) {
                        // Nur einmal zeigen
                        return;
                    }
                    // Zeige Animation f√ºr rausgeflogenen Spieler
                    showEliminationAnimation(eliminated, data.players[eliminated].temp);
                });

                // WICHTIG: Pr√ºfe ob nur noch ein Spieler √ºbrig ist (Gewinner) - ABER NUR NACHDEM ALLE POPUPS ANGEZEIGT WURDEN
                // 1. Alle Attack-Feedback-Popups m√ºssen angezeigt worden sein (roundRecapShown = true)
                // 2. Alle Elimination-Animationen m√ºssen angezeigt worden sein (alle eliminierten Spieler in eliminatedShown)
                // 3. Erst dann zum Winner-Screen wechseln
                // WICHTIG: Nur pr√ºfen wenn eliminiert wurde (eliminatedPlayers.length > 0) ODER wenn bereits roundRecapShown = true
                if((data.status === 'game' || data.status === 'result') && activePlayers.length === 1 && data.status !== 'winner' && data.status !== 'voting') {
                    const recapShown = data.roundRecapShown || false;
                    const eliminatedShown = data.eliminatedShown || [];
                    
                    // Wenn keine Elimination stattgefunden hat, direkt zum Winner-Screen (z.B. wenn alle au√üer einem aufgegeben haben)
                    // Wenn Elimination stattgefunden hat, warte bis alle Popups angezeigt wurden
                    if(eliminatedPlayers.length === 0) {
                        // Keine Elimination, direkt zum Winner-Screen
                        const winner = activePlayers[0];
                        if(isHost) {
                            console.log('onSnapshot: Keine Elimination, wechsle direkt zum Winner-Screen. Gewinner:', winner);
                            updateDoc(doc(db, "lobbies", roomId), {
                                status: 'winner',
                                winner: winner
                            }).catch(console.error);
                        }
                    } else {
                        // Es gab Eliminationen - warte bis alle Popups angezeigt wurden UND alle Spieler sie best√§tigt haben
                        const allEliminatedShown = eliminatedPlayers.every(e => eliminatedShown.includes(e));
                        const popupConfirmed = data.popupConfirmed || {};
                        const allPlayers = Object.keys(data.players || {});
                        // Pr√ºfe ob ALLE Spieler ihre Popups best√§tigt haben
                        const allPopupConfirmed = allPlayers.every(p => popupConfirmed[p] === true);
                        
                        // Pr√ºfe ob alle Popups angezeigt wurden UND alle Spieler sie best√§tigt haben
                        if(recapShown && allEliminatedShown && allPopupConfirmed && isHost) {
                            const winner = activePlayers[0];
                            console.log('onSnapshot: Alle Popups angezeigt und best√§tigt, wechsle zum Winner-Screen. Gewinner:', winner);
                            updateDoc(doc(db, "lobbies", roomId), {
                                status: 'winner',
                                winner: winner
                            }).catch(console.error);
                        } else {
                            // Debug: Warum wird nicht gewechselt?
                            console.log('onSnapshot: Winner-Screen-Check - noch nicht alle Popups best√§tigt', {
                                recapShown,
                                allEliminatedShown,
                                allPopupConfirmed,
                                popupConfirmed,
                                allPlayers,
                                eliminatedPlayers: eliminatedPlayers.length,
                                eliminatedShown: eliminatedShown.length,
                                eliminatedPlayersList: eliminatedPlayers,
                                eliminatedShownList: eliminatedShown,
                                isHost
                            });
                        }
                    }
                } else if((data.status === 'game' || data.status === 'result') && activePlayers.length === 0 && data.status !== 'voting') {
                    // Fallback: Wenn alle raus sind, gewinnt der mit niedrigster Temperatur
                    // ABER NUR NACHDEM ALLE POPUPS ANGEZEIGT WURDEN
                    const recapShown = data.roundRecapShown || false;
                    const eliminatedShown = data.eliminatedShown || [];
                    const allEliminatedShown = eliminatedPlayers.length > 0 ? eliminatedPlayers.every(e => eliminatedShown.includes(e)) : true;
                    
                    if(recapShown && allEliminatedShown && isHost) {
                        let minTemp = 999;
                        let winner = null;
                        Object.keys(data.players).forEach(p => {
                            if(data.players[p].temp < minTemp) {
                                minTemp = data.players[p].temp;
                                winner = p;
                            }
                        });
                        if(winner) {
                            console.log('onSnapshot: Alle Popups angezeigt, wechsle zum Winner-Screen. Gewinner (Fallback):', winner);
                            updateDoc(doc(db, "lobbies", roomId), {
                                status: 'winner',
                                winner: winner
                            }).catch(console.error);
                        }
                    }
                }

                // Pr√ºfe ob Spieler rausgeflogen ist (f√ºr Spectator-Mode)
                // WICHTIG: Spectator-Mode nur im result-Status anzeigen, NICHT im winner-Status
                // Im Winner-Screen m√ºssen alle Spieler (auch eliminierten) die Voting-Buttons sehen k√∂nnen
                if(eliminatedPlayers.includes(myName) && data.status !== 'winner' && data.status !== 'voting') {
                    showSpectatorMode();
                } else {
                    hideSpectatorMode();
                }

                // ROUTER
                const shareBtn = document.getElementById('btnShare');
                const readyBtn = document.getElementById('btnLobbyReady');
                const readyStatus = document.getElementById('lobbyReadyStatus');
                const readyList = document.getElementById('lobbyReadyList');
                const hostStartBtn = document.getElementById('btnHostStart');
                if(data.status === 'lobby') {
                    showScreen('screen-lobby');
                    const players = Object.keys(data.players);
                    // XSS-Schutz: Escape alle Spielernamen und Emojis
                    document.getElementById('lobbyList').innerHTML = players.map(p => {
                        const safeName = escapeHtml(p);
                        const isHost = p === data.host;
                        return `<div>${safeName}${isHost ? ' üëë' : ''}</div>`;
                    }).join('');
                    const readyObj = data.lobbyReady || {};
                    if(readyList) {
                        readyList.innerHTML = players.map(p => {
                            const ready = readyObj[p];
                            const icon = ready ? '‚úÖ' : '‚è≥';
                            const playerData = data.players[p];
                            const playerEmoji = playerData?.emoji || 'üòä';
                            const safeName = escapeHtml(p);
                            const safeEmoji = escapeHtml(playerEmoji);
                            return `<div>${icon} ${safeEmoji} ${safeName}</div>`;
                        }).join('');
                    }
                    const readyCount = players.filter(p => readyObj[p]).length;
                    if(readyStatus) readyStatus.innerText = `Bereit: ${readyCount}/${players.length}`;
                    if(readyBtn) {
                        readyBtn.style.display = 'block';
                        readyBtn.innerText = readyObj[myName] ? "‚ùå Nicht bereit" : "‚úÖ Bereit";
                        readyBtn.classList.toggle('btn-primary', !readyObj[myName]);
                        readyBtn.classList.toggle('btn-secondary', !!readyObj[myName]);
                    }
                    if(hostStartBtn) {
                        hostStartBtn.style.display = isHost ? 'block' : 'none';
                        hostStartBtn.disabled = !(isHost && readyCount === players.length && players.length >= 2);
                    }
                    lastTemps = {};
                    if(shareBtn) shareBtn.style.display = 'block';
                }
                else if(data.status === 'countdown') {
                    showScreen('screen-lobby');
                    if(readyBtn) readyBtn.style.display = 'none';
                    if(readyStatus) readyStatus.innerText = "";
                    if(readyList) readyList.innerHTML = "";
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) {
                        hostStartBtn.disabled = true;
                        hostStartBtn.style.display = 'none';
                    }
                }
                else if(data.status === 'game') {
                    // Sicherstellen, dass currentQ gesetzt ist und korrekt formatiert
                    let currentQ = data.currentQ;
                    if(currentQ && typeof currentQ === 'object') {
                        // Pr√ºfe ob es ein Firebase Timestamp oder Map ist
                        if(currentQ.toDate || currentQ.toMillis) currentQ = null;
                    }
                    if(!currentQ || typeof currentQ.q !== 'string' || !currentQ.q) {
                        if(isHost) {
                            const usedQuestions = data.usedQuestions || [];
                            const activeCategories = data.config?.categories || Object.keys(questionCategories);
                            const lastCategory = data.lastQuestionCategory || null;
                            const { question: q, category: qCategory } = getRandomUnusedQuestion(usedQuestions, activeCategories, lastCategory);
                            updateDoc(doc(db, "lobbies", roomId), { currentQ: q, lastQuestionCategory: qCategory }).catch(console.error);
                            data.currentQ = q;
                        } else {
                            // Fallback f√ºr Nicht-Hosts
                            const activeCategories = data.config?.categories || Object.keys(questionCategories);
                            const allQuestions = getAllQuestions(activeCategories);
                            data.currentQ = allQuestions[0] || { q: "Lade Frage...", a: "A", b: "B" };
                        }
                    } else {
                        data.currentQ = currentQ; // Verwende das bereinigte currentQ
                    }
                    if(readyBtn) readyBtn.style.display = 'none';
                    if(readyStatus) readyStatus.innerText = "";
                    if(readyList) readyList.innerHTML = "";
                    showScreen('screen-game');
                    renderGame(data);
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) hostStartBtn.style.display = 'none';
                    // Host Auto-Advance
                    if(isHost && Object.keys(data.votes).length >= Object.keys(data.players).length) {
                        setTimeout(() => {
                            updateDoc(doc(db, "lobbies", roomId), { status: 'result' });
                        }, 500);
                    }
                }
                else if(data.status === 'result') {
                    // Sicherstellen, dass currentQ gesetzt ist und korrekt formatiert
                    let currentQ = data.currentQ;
                    if(currentQ && typeof currentQ === 'object') {
                        // Pr√ºfe ob es ein Firebase Timestamp oder Map ist
                        if(currentQ.toDate || currentQ.toMillis) currentQ = null;
                    }
                    if(!currentQ || typeof currentQ.q !== 'string' || !currentQ.q) {
                        if(isHost) {
                            const usedQuestions = data.usedQuestions || [];
                            const activeCategories = data.config?.categories || Object.keys(questionCategories);
                            const lastCategory = data.lastQuestionCategory || null;
                            const { question: q, category: qCategory } = getRandomUnusedQuestion(usedQuestions, activeCategories, lastCategory);
                            updateDoc(doc(db, "lobbies", roomId), { currentQ: q, lastQuestionCategory: qCategory }).catch(console.error);
                            data.currentQ = q;
                        } else {
                            // Fallback f√ºr Nicht-Hosts
                            const activeCategories = data.config?.categories || Object.keys(questionCategories);
                            const allQuestions = getAllQuestions(activeCategories);
                            data.currentQ = allQuestions[0] || { q: "Lade Frage...", a: "A", b: "B" };
                        }
                    } else {
                        data.currentQ = currentQ; // Verwende das bereinigte currentQ
                    }
                    if(readyBtn) readyBtn.style.display = 'none';
                    if(readyStatus) readyStatus.innerText = "";
                    if(readyList) readyList.innerHTML = "";
                    showScreen('screen-result');
                    // WICHTIG: renderResult immer aufrufen, auch wenn sich nur ready √§ndert
                    // Dies stellt sicher, dass der Ready-Button und die Liste aktualisiert werden
                    renderResult(data);
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) hostStartBtn.style.display = 'none';
                    
                    // Pr√ºfe ob alle Spieler ihre Angriffsentscheidung getroffen haben (nicht erst wenn alle bereit sind)
                    const attackDecisions = data.attackDecisions || {};
                    const playerCount = Object.keys(data.players || {}).length;
                    const playersWithDecision = Object.keys(attackDecisions).filter(p => attackDecisions[p] === true);
                    const allDecided = playersWithDecision.length >= playerCount;
                    const recapNotShown = !data.roundRecapShown;
                    
                    console.log('onSnapshot (result): Pr√ºfe Bedingung f√ºr executePendingAttacks', {
                        playersWithDecision: playersWithDecision.length,
                        playerCount,
                        allDecided,
                        recapNotShown,
                        attackDecisions,
                        roundRecapShown: data.roundRecapShown,
                        isHost
                    });
                    
                    if(allDecided && recapNotShown && isHost) {
                        console.log('onSnapshot (result): Alle Spieler haben ihre Entscheidung getroffen, rufe executePendingAttacks auf');
                        // executePendingAttacks setzt jetzt roundRecapShown selbst, kein separates Update n√∂tig
                        executePendingAttacks(data).catch(err => {
                            console.error('Fehler bei executePendingAttacks:', err);
                        });
                    }
                    
                    // Host Auto-Next (alte Logik - kann entfernt werden wenn executePendingAttacks funktioniert)
                    // if(isHost && data.ready.length >= Object.keys(data.players).length) {
                    //     setTimeout(() => nextRound(), 1000);
                    // }
                }
                else if(data.status === 'winner') {
                    showScreen('screen-winner');
                    renderWinner(data.winner, data.players, data);
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) hostStartBtn.style.display = 'none';
                    // Winner-Screen bleibt bestehen, bis man die Lobby verl√§sst oder eine neue Runde startet
                    // Voting-Funktionalit√§t ist direkt auf dem Winner-Screen
                }
                else if(data.status === 'voting') {
                    // Voting wird jetzt auf dem Winner-Screen angezeigt
                    showScreen('screen-winner');
                    renderWinner(data.winner || Object.keys(data.players)[0], data.players, data);
                    if(shareBtn) shareBtn.style.display = 'none';
                    if(hostStartBtn) hostStartBtn.style.display = 'none';
                }
                handleCountdownOverlay(data);
            });
        }
        // --- RENDER GAME ---
        function renderGame(data) {
            const roundId = data.roundId ?? 0;
            const btnLock = document.getElementById('btnLock');
            const btnA = document.getElementById('btnA');
            const btnB = document.getElementById('btnB');
            const lblHotseat = document.getElementById('lblHotseat');
            const lblHotseatSub = document.getElementById('lblHotseatSub');

            if(lastRoundId !== roundId) {
                lastRoundId = roundId;
                localActionDone = false;
                mySelection = null;
                btnA.classList.remove('selected');
                btnB.classList.remove('selected');
                btnLock.disabled = true;
                // A/B Buttons werden sp√§ter aktiviert, wenn hotseat gesetzt ist
                
                // Hotseat-Popup beim Start jeder Runde anzeigen
                if(data.hotseat) {
                    triggerHotseatAlert(data.hotseat, data.players);
                }
            }

            if(data.votes[myName]) {
                btnLock.classList.add('hidden');
                // Wenn bereits abgestimmt, A/B Buttons deaktivieren
                const optionRow = document.getElementById('optionRow');
                if(optionRow) {
                    optionRow.style.opacity = '0.5';
                    optionRow.style.pointerEvents = 'none';
                }
            } else {
                btnLock.classList.remove('hidden');
                // Strategie ist nur eine Vorauswahl, nicht mehr zwingend
                btnLock.disabled = !mySelection;
            }

            // Robustere Behandlung von currentQ (Firebase kann Objekte anders serialisieren)
            let currentQ = data.currentQ;
            if(currentQ && typeof currentQ === 'object') {
                // Pr√ºfe ob es ein Firebase Timestamp oder Map ist
                if(currentQ.toDate) currentQ = null; // Timestamp, ignorieren
                if(currentQ.toMillis) currentQ = null; // Timestamp, ignorieren
            }
            
            if(currentQ && currentQ.q && typeof currentQ.q === 'string') {
                document.getElementById('lblQuestion').innerText = currentQ.q;
                btnA.innerText = currentQ.a || 'A';
                btnB.innerText = currentQ.b || 'B';
                
                // Kategorie anzeigen
                const categoryLabel = document.getElementById('lblQuestionCategory');
                if(categoryLabel && currentQ.category) {
                    const cat = questionCategories[currentQ.category];
                    if(cat) {
                        categoryLabel.innerText = `${cat.emoji} ${cat.name}`;
                        categoryLabel.style.display = 'block';
                    } else {
                        categoryLabel.style.display = 'none';
                    }
                } else if(categoryLabel) {
                    categoryLabel.style.display = 'none';
                }
            } else {
                // Fallback falls currentQ fehlt oder falsch formatiert
                console.warn('currentQ fehlt oder ist falsch formatiert:', currentQ);
                const activeCategories = globalData?.config?.categories || Object.keys(questionCategories);
                const allQuestions = getAllQuestions(activeCategories);
                const fallbackQ = allQuestions[0] || { q: "Lade Frage...", a: "A", b: "B" };
                document.getElementById('lblQuestion').innerText = fallbackQ.q;
                btnA.innerText = fallbackQ.a;
                btnB.innerText = fallbackQ.b;
                
                // Versuche currentQ zu reparieren (nur als Host)
                if(isHost && globalData) {
                    const usedQuestions = globalData.usedQuestions || [];
                    const activeCategories = globalData.config?.categories || Object.keys(questionCategories);
                    const lastCategory = globalData.lastQuestionCategory || null;
                    const { question: q, category: qCategory } = getRandomUnusedQuestion(usedQuestions, activeCategories, lastCategory);
                    updateDoc(doc(db, "lobbies", roomId), { currentQ: q, lastQuestionCategory: qCategory }).catch(console.error);
                }
            }
            
            if(!data.hotseat) {
                lblHotseat.innerText = "Runde wird vorbereitet...";
                lblHotseatSub.innerText = "Bitte kurz warten.";
                // A/B Buttons aktivieren
                const optionRow = document.getElementById('optionRow');
                if(optionRow) {
                    optionRow.style.opacity = '1';
                    optionRow.style.pointerEvents = 'auto';
                }
            } else if(myName === data.hotseat) {
                lblHotseat.innerText = "Du beantwortest die Frage!";
                lblHotseatSub.innerText = "Antworte ehrlich ‚Äì die anderen versuchen deine Wahl zu erraten.";
                // Hotseat kann direkt A/B w√§hlen
                const optionRow = document.getElementById('optionRow');
                if(optionRow) {
                    optionRow.style.opacity = '1';
                    optionRow.style.pointerEvents = 'auto';
                }
            } else {
                lblHotseat.innerText = `${data.hotseat} beantwortet die Frage!`;
                const gameMode = data.config?.gameMode || 'party';
                const isPartyMode = gameMode === 'party';
                if(isPartyMode) {
                    lblHotseatSub.innerText = "Errate die Wahl, um einen Spieler aufzuheizen!";
                } else {
                    lblHotseatSub.innerText = "Errate die Wahl, um anzugreifen oder Joker zu ziehen.";
                }
                // A/B Buttons aktivieren
                const optionRow = document.getElementById('optionRow');
                if(optionRow) {
                    optionRow.style.opacity = '1';
                    optionRow.style.pointerEvents = 'auto';
                }
            }
            
            const players = Object.keys(data.players);
            const voted = players.filter(p => data.votes[p]);
            const pending = players.filter(p => !data.votes[p]);
            const voteStatusEl = document.getElementById('lblVoteStatus');
            const voteText = voted.length ? voted.join(', ') : 'Niemand';
            const pendingText = pending.length ? pending.join(', ') : 'Niemand';
            voteStatusEl.innerHTML = `‚úÖ Abgegeben: ${voteText}<br>ü§î √úberlegen: ${pendingText}`;
            // Joker nur im Strategiemodus anzeigen
            const gameMode = data.config?.gameMode || 'party';
            const isPartyMode = gameMode === 'party';
            const jokerPanelGame = document.getElementById('jokerPanelGame');
            if(jokerPanelGame) {
                jokerPanelGame.style.display = isPartyMode ? 'none' : 'block';
            }
            
            if(data.players[myName] && !isPartyMode) {
                renderMyJokers('myJokerListGame', data.players[myName]);
            }
        }

        // --- RENDER RESULT ---
        function renderResult(data) {
            const truth = data.votes[data.hotseat]?.choice;
            let truthText = '?';
            
            // Robustere Behandlung von currentQ (Firebase kann Objekte anders serialisieren)
            let currentQ = data.currentQ;
            if(currentQ && typeof currentQ === 'object') {
                // Pr√ºfe ob es ein Firebase Timestamp oder Map ist
                if(currentQ.toDate) currentQ = null; // Timestamp, ignorieren
                if(currentQ.toMillis) currentQ = null; // Timestamp, ignorieren
            }
            
            if(truth && currentQ && typeof currentQ.a === 'string' && typeof currentQ.b === 'string') {
                truthText = truth === 'A' ? currentQ.a : currentQ.b;
            } else if(truth) {
                // Fallback falls currentQ fehlt
                console.warn('currentQ fehlt in renderResult:', currentQ);
                truthText = truth === 'A' ? 'A' : 'B';
            }
            // lblTruth wird nicht mehr angezeigt (nur noch "RICHTIG GERATEN!" etc.)
            // document.getElementById('lblTruth').innerText = truthText;
            
            // Kategorie anzeigen
            const categoryLabel = document.getElementById('lblResultCategory');
            if(categoryLabel && currentQ && currentQ.category) {
                const cat = questionCategories[currentQ.category];
                if(cat) {
                    categoryLabel.innerText = `${cat.emoji} ${cat.name}`;
                    categoryLabel.style.display = 'block';
                } else {
                    categoryLabel.style.display = 'none';
                }
            } else if(categoryLabel) {
                categoryLabel.style.display = 'none';
            }

            const myVote = data.votes[myName];
            const statusEl = document.getElementById('lblResultStatus');
            const boxAttack = document.getElementById('boxAttack');
            const boxShop = document.getElementById('boxShop');
            const btnReady = document.getElementById('btnReady');

            // Reset Boxes
            boxAttack.style.display = 'none';
            boxShop.style.display = 'none';
            
            // Ready Status mit Namen
            const players = Object.keys(data.players);
            const readyPlayers = data.ready || [];
            const notReadyPlayers = players.filter(p => !readyPlayers.includes(p));
            
            let readyText = `‚úÖ Bereit (${readyPlayers.length}/${players.length}): `;
            if(readyPlayers.length > 0) {
                readyText += readyPlayers.map(p => {
                    const playerData = data.players[p];
                    const playerEmoji = playerData?.emoji || 'üòä';
                    return `${playerEmoji} ${p}`;
                }).join(', ');
            } else {
                readyText += "Niemand";
            }
            
            if(notReadyPlayers.length > 0) {
                readyText += `<br>‚è≥ Noch nicht bereit: `;
                readyText += notReadyPlayers.map(p => {
                    const playerData = data.players[p];
                    const playerEmoji = playerData?.emoji || 'üòä';
                    return `${playerEmoji} ${p}`;
                }).join(', ');
            }
            
            document.getElementById('lblReady').innerHTML = readyText;
            
            // Pr√ºfe ob Spieler eliminiert ist (100¬∞ erreicht)
            const maxTemp = data.config?.maxTemp || 100;
            const isEliminated = (data.players[myName]?.temp || 0) >= maxTemp;
            
            // Eliminierte Spieler sind automatisch bereit und sehen nur den Wartescreen
            if(isEliminated) {
                btnReady.disabled = true;
                btnReady.innerText = "üî• Hitzkopf - Ausgeschieden";
                btnReady.onclick = null;
                return;
            }
            
            // Pr√ºfe ob Angriffszusammenfassung noch angezeigt wird (attackResults vorhanden)
            const hasAttackResults = data.attackResults && Object.keys(data.attackResults).length > 0;
            
            // Nach dem Popup: Immer "Bereit" Button zeigen, nicht "N√§chste Runde"
            // WICHTIG: Verwende globalData f√ºr aktuelle ready-Liste
            const currentReadyForButton = globalData?.ready || data.ready || [];
            if(currentReadyForButton.includes(myName)) {
                btnReady.disabled = true;
                btnReady.innerText = "‚è≥ Warte auf andere...";
                btnReady.onclick = setReady;
            } else {
                btnReady.disabled = false;
                btnReady.innerText = "üëç Bereit";
                btnReady.onclick = setReady;
            }

            if(isHost) {
                maybeLogRoundSummary(data, truthText, truth);
            }

            // Automatisch zur n√§chsten Runde wenn alle bereit sind (inkl. eliminierten Spielern)
            // WICHTIG: Verwende globalData statt data, da globalData immer aktuell ist
            const currentReady = globalData?.ready || [];
            const readyCount = Array.isArray(currentReady) ? currentReady.length : 0;
            const allPlayers = Object.keys(globalData?.players || data.players || {});
            const playerCount = allPlayers.length;
            const allReady = readyCount >= playerCount;
            
            // Pr√ºfe ob Angriffe bereits ausgef√ºhrt wurden (roundRecapShown = true)
            const recapShown = globalData?.roundRecapShown || data.roundRecapShown;
            
            console.log('renderResult: Pr√ºfe Bedingung f√ºr automatische Weiterleitung', {
                readyCount,
                playerCount,
                allReady,
                recapShown,
                readyArray: currentReady,
                isHost
            });
            
            // Wenn alle bereit sind UND Angriffe bereits ausgef√ºhrt wurden, starte automatisch n√§chste Runde
            if(allReady && recapShown && isHost) {
                console.log('renderResult: Alle bereit und Angriffe ausgef√ºhrt, starte automatisch n√§chste Runde');
                setTimeout(() => {
                    nextRound();
                }, 1000);
            }

            const gameMode = data.config?.gameMode || 'party';
            const isPartyMode = gameMode === 'party';
            
            // Joker-Panel nur im Strategiemodus anzeigen
            const jokerPanel = document.querySelector('.joker-panel');
            if(jokerPanel) {
                jokerPanel.style.display = isPartyMode ? 'none' : 'block';
            }
            
            if(myName === data.hotseat) {
                statusEl.innerText = "Du hast die Frage beantwortet.";
                statusEl.style.color = "#aaa";
                
                // Hotseat kann nicht angreifen, markiere automatisch als "entschieden"
                // WICHTIG: Immer markieren (Party und Strategic Mode), damit executePendingAttacks aufgerufen wird
                (async () => {
                    const ref = doc(db, "lobbies", roomId);
                    const currentData = await getDoc(ref);
                    const currentAttackDecisions = currentData.data()?.attackDecisions || {};
                    if(!currentAttackDecisions[myName]) {
                        const updatedAttackDecisions = {
                            ...currentAttackDecisions,
                            [myName]: true // Hotseat hat keine Angriffsentscheidung zu treffen
                        };
                        await updateDoc(ref, {
                            attackDecisions: updatedAttackDecisions
                        });
                        console.log('Hotseat automatisch als entschieden markiert');
                        localActionDone = true;
                    }
                })().catch(err => {
                    console.error('Fehler beim Markieren des Hotseats als entschieden:', err);
                });
            } else {
                if(myVote && myVote.choice === truth) {
                    // Bei richtiger Antwort: consecutiveWrongAnswers zur√ºcksetzen
                    (async () => {
                        const ref = doc(db, "lobbies", roomId);
                        const currentData = await getDoc(ref);
                        const playerData = currentData.data()?.players?.[myName] || {};
                        if(playerData.consecutiveWrongAnswers && playerData.consecutiveWrongAnswers > 0) {
                            await updateDoc(ref, {
                                [`players.${myName}.consecutiveWrongAnswers`]: 0
                            });
                            console.log('consecutiveWrongAnswers zur√ºckgesetzt f√ºr', myName);
                        }
                    })().catch(err => {
                        console.error('Fehler beim Zur√ºcksetzen von consecutiveWrongAnswers:', err);
                    });
                    
                    if(isPartyMode) {
                        // Partymodus: Direkt Angriff-Auswahl
                        statusEl.innerHTML = "‚úÖ <strong>RICHTIG GERATEN!</strong><br><span style='font-size:0.9rem; font-weight:normal;'>W√§hle einen Spieler zum Aufheizen!</span>";
                        statusEl.style.color = "#0f0";
                        
                        if(!localActionDone) {
                            btnReady.disabled = true;
                            btnReady.innerText = "‚ö° W√§hle einen Spieler!";
                            
                            const boxAttackEl = document.getElementById('boxAttack');
                            if(boxAttackEl) {
                                boxAttackEl.style.display = 'block';
                                renderTargets(data.players);
                            }
                        }
                    } else {
                        // Strategiemodus: Belohnungsauswahl
                        statusEl.innerHTML = "‚úÖ <strong>RICHTIG GERATEN!</strong><br><span style='font-size:0.9rem; font-weight:normal;'>Hier ist deine Belohnung, wie m√∂chtest du vorgehen?</span>";
                        statusEl.style.color = "#0f0";

                        if(!localActionDone) {
                            btnReady.disabled = true;
                            btnReady.innerText = "‚ö° W√§hle deine Belohnung!";
                            
                            const rewardBoxEl = document.getElementById('boxReward');
                            if(rewardBoxEl) {
                                rewardBoxEl.style.display = 'block';
                            }
                        }
                    }
                } else {
                    if(!myVote) {
                        statusEl.innerText = "‚åõ Keine Antwort abgegeben.";
                        statusEl.style.color = "#ccc";
                    } else {
                        statusEl.innerText = "‚ùå FALSCH";
                        statusEl.style.color = "#f00";
                        
                        // Partymodus: Bei falscher Antwort automatisch 10¬∞ selbst bekommen
                        if(isPartyMode && !localActionDone) {
                            localActionDone = true;
                            handlePartyModeWrongAnswer();
                        }
                    }
                    if(!isPartyMode || (isPartyMode && !myVote)) {
                        localActionDone = true;
                    }
                }
            }
            // Joker nur im Strategiemodus anzeigen
            const resultGameMode = data.config?.gameMode || 'party';
            const resultIsPartyMode = resultGameMode === 'party';
            const jokerPanelResult = document.querySelector('#screen-result .joker-panel');
            if(jokerPanelResult) {
                jokerPanelResult.style.display = resultIsPartyMode ? 'none' : 'block';
            }
            
            if(data.players[myName] && !resultIsPartyMode) {
                renderMyJokers('myJokerListResult', data.players[myName]);
            }
            
            // WICHTIG: Stelle sicher, dass ALLE Spieler ihre attackDecisions setzen, auch wenn keine Angriffe vorhanden sind
            // Dies ist notwendig, damit executePendingAttacks aufgerufen wird (f√ºr Strafhitze) und roundRecapShown gesetzt wird
            const attackDecisions = data.attackDecisions || {};
            if(!attackDecisions[myName]) {
                // Spieler hat noch keine Angriffsentscheidung getroffen
                // Pr√ºfe ob er eine treffen muss (nicht Hotseat, hat falsch geraten oder richtig ohne Angriff)
                const isHotseat = myName === data.hotseat;
                const myVoteData = data.votes?.[myName];
                const truth = data.votes?.[data.hotseat]?.choice;
                const guessedCorrectly = myVoteData && myVoteData.choice === truth;
                
                // Im Strategic Mode: Wenn richtig geraten, muss Spieler Belohnung w√§hlen (das setzt attackDecisions √ºber doAttack/skipAttack)
                // Im Party Mode: Wenn richtig geraten, muss Spieler Angriff w√§hlen (das setzt attackDecisions √ºber doAttack)
                // Wenn falsch geraten im Party Mode: wird bereits in handlePartyModeWrongAnswer gesetzt
                // Wenn falsch geraten im Strategic Mode oder Hotseat: automatisch setzen
                if(isHotseat) {
                    // Hotseat sollte bereits oben gesetzt sein, aber sicherheitshalber nochmal pr√ºfen
                    (async () => {
                        const ref = doc(db, "lobbies", roomId);
                        const currentData = await getDoc(ref);
                        const currentAttackDecisions = currentData.data()?.attackDecisions || {};
                        if(!currentAttackDecisions[myName]) {
                            await updateDoc(ref, {
                                [`attackDecisions.${myName}`]: true
                            });
                            console.log('Hotseat (Fallback) automatisch als entschieden markiert');
                        }
                    })().catch(err => {
                        console.error('Fehler beim Markieren des Hotseats als entschieden:', err);
                    });
                } else if(!guessedCorrectly) {
                    // Falsch geraten (Party oder Strategic Mode): automatisch als entschieden markieren
                    // Im Party Mode wird es bereits in handlePartyModeWrongAnswer gesetzt, aber sicherheitshalber nochmal
                    (async () => {
                        const ref = doc(db, "lobbies", roomId);
                        const currentData = await getDoc(ref);
                        const currentAttackDecisions = currentData.data()?.attackDecisions || {};
                        if(!currentAttackDecisions[myName]) {
                            await updateDoc(ref, {
                                [`attackDecisions.${myName}`]: true
                            });
                            console.log('Spieler (falsch geraten) automatisch als entschieden markiert:', myName);
                        }
                    })().catch(err => {
                        console.error('Fehler beim Markieren des Spielers als entschieden:', err);
                    });
                }
            }
        }

        // --- RENDER TARGETS ---
        window.renderTargets = (players) => {
            const div = document.getElementById('divTargets');
            const attackTitle = document.getElementById('attackTitle');
            const btnBack = document.getElementById('btnBackFromAttack');
            const btnSkip = document.getElementById('btnSkipAttack');
            div.innerHTML = "";
            const gameMode = globalData?.config?.gameMode || 'party';
            const isPartyMode = gameMode === 'party';
            const baseDmg = isPartyMode ? 20 : (globalData?.config?.dmg || 10);
            
            // Pr√ºfe ob Spieler √ñlfass hat (verdoppelt Schaden)
            const attackerState = globalData?.players?.[myName] || {};
            const hasOil = attackerState.inventory?.includes('card_oil');
            const dmg = baseDmg * (hasOil ? 2 : 1);
            
            // Anpassen f√ºr Partymodus
            if(isPartyMode) {
                if(attackTitle) attackTitle.innerText = "üî• Wen aufheizen?";
                if(btnBack) btnBack.style.display = 'none';
                if(btnSkip) btnSkip.style.display = 'none';
            } else {
                if(attackTitle) attackTitle.innerText = "üî• Wen angreifen?";
                if(btnBack) btnBack.style.display = 'block';
                if(btnSkip) btnSkip.style.display = 'block';
            }
            
            Object.keys(players).forEach(p => {
                if(p !== myName) {
                    const playerData = players[p];
                    const playerEmoji = playerData?.emoji || 'üòä';
                    
                    // Erstelle Karte √§hnlich wie Kategorien-Karten
                    const card = document.createElement('div');
                    card.className = 'target-card';
                    card.setAttribute('data-target', p);
                    card.onclick = () => doAttack(p);
                    
                    // Emoji oben
                    const emojiDiv = document.createElement('div');
                    emojiDiv.className = 'target-emoji';
                    emojiDiv.innerText = playerEmoji;
                    
                    // Name mittig
                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'target-name';
                    nameDiv.innerText = p;
                    
                    // Schaden unten (klein)
                    const dmgDiv = document.createElement('div');
                    dmgDiv.className = 'target-dmg';
                    dmgDiv.innerText = `+${dmg}¬∞`;
                    
                    card.appendChild(emojiDiv);
                    card.appendChild(nameDiv);
                    card.appendChild(dmgDiv);
                    
                    div.appendChild(card);
                }
            });
        };

        // --- SELECT STRATEGY ---
        window.selectStrategy = (strat) => {
            myStrategy = strat;
            const btnAttack = document.getElementById('btnStratAttack');
            const btnInvest = document.getElementById('btnStratInvest');
            const lockBtn = document.getElementById('btnLock');
            
            // Buttons markieren (nur visuelle Vorauswahl)
            if(btnAttack) {
                btnAttack.classList.toggle('selected', strat === 'attack');
            }
            if(btnInvest) {
                btnInvest.classList.toggle('selected', strat === 'invest');
            }
            
            // Lock-Button aktivieren, wenn bereits A/B gew√§hlt wurde
            if(lockBtn && mySelection) {
                lockBtn.disabled = false;
            }
        };

        // --- VOTE ---
        window.vote = (opt) => {
            // Strategie ist nur eine Vorauswahl, nicht mehr zwingend erforderlich
            mySelection = opt;
            document.getElementById('btnA').classList.toggle('selected', opt === 'A');
            document.getElementById('btnB').classList.toggle('selected', opt === 'B');
            const lockBtn = document.getElementById('btnLock');
            lockBtn.disabled = false;
        };

        // --- SUBMIT VOTE ---
        window.submitVote = async () => {
            // Pr√ºfe ob Hotseat (dann keine Strategie n√∂tig)
            const stratSection = document.getElementById('stratSection');
            const isHotseat = stratSection && stratSection.classList.contains('hidden');
            
            if(!mySelection) {
                showToast("Bitte w√§hle zuerst eine Antwort (A oder B)!");
                return;
            }
            
            // Strategie ist nur eine Vorauswahl, wird nicht mehr bindend gespeichert
            // Die finale Entscheidung wird im Result-Screen getroffen
            let strat = myStrategy || 'none'; // Vorauswahl oder 'none' als Fallback
            
            // Hotseat braucht keine Strategie (wird ignoriert)
            if(isHotseat) {
                strat = 'none'; // Placeholder f√ºr Hotseat
            }
            
            document.getElementById('btnLock').classList.add('hidden');
            
            await updateDoc(doc(db, "lobbies", roomId), {
                [`votes.${myName}`]: { choice: mySelection, strategy: strat }
            });
        };

        // --- CHOOSE REWARD ---
        window.chooseReward = (rewardType) => {
            const rewardBox = document.getElementById('boxReward');
            if(rewardBox) rewardBox.style.display = 'none';
            
            const boxAttack = document.getElementById('boxAttack');
            const boxShop = document.getElementById('boxShop');
            
            if(rewardType === 'attack') {
                boxAttack.style.display = 'block';
                renderTargets(globalData.players);
            } else if(rewardType === 'invest') {
                boxShop.style.display = 'block';
            }
        };

        // --- GO BACK TO REWARD ---
        window.goBackToReward = () => {
            const rewardBox = document.getElementById('boxReward');
            const boxAttack = document.getElementById('boxAttack');
            const boxShop = document.getElementById('boxShop');
            
            if(rewardBox) rewardBox.style.display = 'block';
            if(boxAttack) boxAttack.style.display = 'none';
            if(boxShop) boxShop.style.display = 'none';
        };

        // --- ATTACK ---
        window.doAttack = async (target) => {
            localActionDone = true;
            const rewardBox = document.getElementById('boxReward');
            if(rewardBox) rewardBox.style.display = 'none';
            document.getElementById('boxAttack').style.display = 'none';
            
            const gameMode = globalData?.config?.gameMode || 'party';
            const isPartyMode = gameMode === 'party';
            const baseDmg = isPartyMode ? 20 : (globalData?.config?.dmg || 10); // Partymodus: 20¬∞
            const attackerState = globalData?.players?.[myName] || {};
            const hasOil = attackerState.inventory?.includes('card_oil');
            const dmg = baseDmg * (hasOil ? 2 : 1);
            
            // Angriff sammeln statt sofort ausf√ºhren
            const ref = doc(db, "lobbies", roomId);
            const attackEntry = {
                attacker: myName,
                dmg: dmg,
                hasOil: hasOil
            };
            
            // Lese aktuelle pendingAttacks aus Firebase
            const currentData = await getDoc(ref);
            const currentPendingAttacks = currentData.data()?.pendingAttacks || {};
            const targetAttacks = currentPendingAttacks[target] || [];
            targetAttacks.push(attackEntry);
            
            const updatedPendingAttacks = {
                ...currentPendingAttacks,
                [target]: targetAttacks
            };
            
            // Markiere dass dieser Spieler seine Angriffsentscheidung getroffen hat
            const currentAttackDecisions = currentData.data()?.attackDecisions || {};
            const updatedAttackDecisions = {
                ...currentAttackDecisions,
                [myName]: true
            };
            
            console.log('doAttack: Angriff hinzugef√ºgt:', { target, attacker: myName, dmg, updatedPendingAttacks });
            
            // √ñlfass entfernen wenn verwendet
            if(hasOil) {
                await updateDoc(ref, { 
                    [`players.${myName}.inventory`]: arrayRemove('card_oil'),
                    pendingAttacks: updatedPendingAttacks,
                    attackDecisions: updatedAttackDecisions
                });
            } else {
                await updateDoc(ref, { 
                    pendingAttacks: updatedPendingAttacks,
                    attackDecisions: updatedAttackDecisions
                });
            }
            
            console.log('doAttack: pendingAttacks und attackDecisions aktualisiert');
        };

        // --- TAKE CARD ---
        window.takeCard = async (card) => {
            localActionDone = true;
            const rewardBox = document.getElementById('boxReward');
            if(rewardBox) rewardBox.style.display = 'none';
            document.getElementById('boxShop').style.display = 'none';
            document.getElementById('btnReady').disabled = false;

            const inventory = globalData?.players?.[myName]?.inventory || [];
            if(inventory.includes(card)) {
                showToast("Du besitzt diesen Joker bereits! Du kannst jeden Joker nur einmal haben.");
                return;
            }

            await updateDoc(doc(db, "lobbies", roomId), {
                [`players.${myName}.inventory`]: arrayUnion(card),
                log: arrayUnion(`üÉè ${myName} zieht eine geheime Karte.`)
            });
            
            // Zeige Animation
            await showJokerAnimation(myName, card);
            
            showToast(`${cardInfo[card].label} erhalten! ${cardInfo[card].desc}`);
        };

        // --- SKIP ATTACK ---
        window.skipAttack = async () => {
            localActionDone = true;
            const rewardBox = document.getElementById('boxReward');
            if(rewardBox) rewardBox.style.display = 'none';
            document.getElementById('boxAttack').style.display = 'none';
            
            const ref = doc(db, "lobbies", roomId);
            const currentData = await getDoc(ref);
            const currentAttackDecisions = currentData.data()?.attackDecisions || {};
            const updatedAttackDecisions = {
                ...currentAttackDecisions,
                [myName]: true
            };
            
            await updateDoc(ref, {
                log: arrayUnion(`üïäÔ∏è ${myName} verzichtet auf einen Angriff.`),
                attackDecisions: updatedAttackDecisions
            });
            
            console.log('skipAttack: attackDecisions aktualisiert');
        };

        // --- SET READY ---
        window.setReady = async () => {
            console.log('setReady: Markiere Spieler als bereit:', myName);
            const ref = doc(db, "lobbies", roomId);
            
            // Lese aktuelle ready-Liste aus Firebase
            const currentData = await getDoc(ref);
            const currentReady = currentData.data()?.ready || [];
            console.log('setReady: Aktuelle ready-Liste:', currentReady);
            
            // Pr√ºfe ob bereits in der Liste
            if(currentReady.includes(myName)) {
                console.log('setReady: Spieler bereits in ready-Liste');
                return;
            }
            
            // F√ºge Spieler hinzu
            const updatedReady = [...currentReady, myName];
            console.log('setReady: Neue ready-Liste:', updatedReady);
            
            await updateDoc(ref, { 
                ready: updatedReady
            });
            console.log('setReady: Bereitschaft gesetzt');
        };
        
        // --- PARTY MODE WRONG ANSWER ---
        async function handlePartyModeWrongAnswer() {
            const dmg = 10; // 10¬∞ selbst bekommen bei falscher Antwort
            const ref = doc(db, "lobbies", roomId);
            const currentData = await getDoc(ref);
            const currentAttackDecisions = currentData.data()?.attackDecisions || {};
            const updatedAttackDecisions = {
                ...currentAttackDecisions,
                [myName]: true // Markiere dass Entscheidung getroffen wurde (Selbstschaden)
            };
            
            await updateDoc(ref, {
                [`players.${myName}.temp`]: increment(dmg),
                log: arrayUnion(`‚ùå ${myName} hat falsch geraten und sich selbst aufgeheizt (+${dmg}¬∞C)`),
                attackDecisions: updatedAttackDecisions
            });
            showToast(`Du hast falsch geraten! +${dmg}¬∞C f√ºr dich.`);
            console.log('handlePartyModeWrongAnswer: attackDecisions aktualisiert');
        }
        // --- START GAME (COUNTDOWN) ---
        window.startCountdown = async () => {
            if(!isHost || !globalData) return;
            const players = Object.keys(globalData.players);
            if(players.length < 2) {
                showToast("Mindestens 2 Spieler ben√∂tigt!");
                return;
            }
            const readyObj = globalData.lobbyReady || {};
            const unready = players.filter(p => !readyObj[p]);
                if(unready.length) {
                showToast(`Noch nicht alle bereit: ${unready.join(', ')}`);
                return;
            }
            
            await applyIceCooling(globalData.players);
            const usedQuestions = globalData.usedQuestions || [];
            const activeCategories = globalData.config?.categories || Object.keys(questionCategories);
            const lastCategory = globalData.lastQuestionCategory || null;
            const { question: q, index: qIdx, category: qCategory } = getRandomUnusedQuestion(usedQuestions, activeCategories, lastCategory);
            const nextRoundId = (globalData?.roundId ?? 0) + 1;
            const countdownEnds = Date.now() + 3000;
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'countdown',
                hotseat: players[0],
                currentQ: q,
                votes: {},
                ready: [],
                roundId: nextRoundId,
                countdownEnds,
                lobbyReady: {},
                usedQuestions: [...usedQuestions, qIdx],
                lastQuestionCategory: qCategory,
                pendingAttacks: {} // Zur√ºcksetzen f√ºr neue Runde
            });
            setTimeout(() => {
                updateDoc(doc(db, "lobbies", roomId), { status: 'game', countdownEnds: null });
            }, 3300);
        };
        
        // Starte Spiel nach Schlie√üen der Regeln
        // --- OPEN RULES OVERLAY ---
        window.openRulesOverlay = () => {
            const overlay = document.getElementById('rulesOverlay');
            if(overlay) {
                overlay.style.display = 'flex';
            }
        };

        // --- CLOSE RULES OVERLAY ---
        window.closeRulesOverlay = () => {
            const overlay = document.getElementById('rulesOverlay');
            if(overlay) {
                overlay.style.display = 'none';
            }
        };
        
        // --- SHOW ROUND RECAP ---
        function showRoundRecap(data) {
            const overlay = document.getElementById('roundRecapOverlay');
            const content = document.getElementById('recapContent');
            if(!overlay || !content) return;
            
            const players = Object.keys(data.players || {});
            const readyPlayers = data.ready || [];
            const notReadyPlayers = players.filter(p => !readyPlayers.includes(p));
            
            let html = `<div style="text-align:left; margin-bottom:20px;">`;
            html += `<h3 style="color:#ff4500; margin-bottom:15px;">Bereitschaftsstatus:</h3>`;
            
            if(readyPlayers.length > 0) {
                html += `<div style="margin-bottom:15px;"><strong style="color:#4CAF50;">‚úÖ Bereit (${readyPlayers.length}):</strong><br>`;
                html += readyPlayers.map(p => {
                    const playerData = data.players[p];
                    const playerEmoji = playerData?.emoji || 'üòä';
                    return `  ${playerEmoji} ${p}`;
                }).join('<br>');
                html += `</div>`;
            }
            
            if(notReadyPlayers.length > 0) {
                html += `<div><strong style="color:#ff9800;">‚è≥ Noch nicht bereit (${notReadyPlayers.length}):</strong><br>`;
                html += notReadyPlayers.map(p => {
                    const playerData = data.players[p];
                    const playerEmoji = playerData?.emoji || 'üòä';
                    return `  ${playerEmoji} ${p}`;
                }).join('<br>');
                html += `</div>`;
            }
            
            html += `</div>`;
            content.innerHTML = html;
            overlay.style.display = 'flex';
        }
        
        // --- CLOSE ROUND RECAP ---
        window.closeRoundRecap = () => {
            const overlay = document.getElementById('roundRecapOverlay');
            if(overlay) {
                overlay.style.display = 'none';
            }
        };

        // --- NEXT ROUND ---
        window.nextRound = async () => {
            const maxTemp = globalData?.config?.maxTemp || 100;
            const activePlayers = Object.keys(globalData.players).filter(p => 
                (globalData.players[p].temp || 0) < maxTemp
            );
            
            if(activePlayers.length === 0) {
                // Fallback: Alle sind raus, nimm alle Spieler
                activePlayers.push(...Object.keys(globalData.players));
            }
            
            // Pr√ºfe nur w√§hrend des Spiels, nicht in der Lobby
            if(globalData?.status === 'game' || globalData?.status === 'result') {
                if(activePlayers.length === 1) {
                    // Nur noch ein Spieler √ºbrig - Gewinner!
                    if(isHost) {
                        await updateDoc(doc(db, "lobbies", roomId), {
                            status: 'winner',
                            winner: activePlayers[0]
                        });
                    }
                    return;
                }
            }
            
            const curr = globalData.hotseat;
            let nextIdx = activePlayers.indexOf(curr);
            if(nextIdx === -1) nextIdx = 0;
            nextIdx = (nextIdx + 1) % activePlayers.length;
            
            const usedQuestions = globalData.usedQuestions || [];
            const activeCategories = globalData.config?.categories || Object.keys(questionCategories);
            const lastCategory = globalData.lastQuestionCategory || null;
            const { question: q, index: qIdx, category: qCategory } = getRandomUnusedQuestion(usedQuestions, activeCategories, lastCategory);
            const nextRoundId = (globalData?.roundId ?? 0) + 1;
            await applyIceCooling(globalData.players);
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'game',
                hotseat: activePlayers[nextIdx],
                currentQ: q,
                votes: {},
                ready: [],
                roundId: nextRoundId,
                usedQuestions: [...usedQuestions, qIdx],
                roundRecapShown: false,
                lastQuestionCategory: qCategory,
                pendingAttacks: {}, // Zur√ºcksetzen f√ºr neue Runde
                attackResults: {}, // Zur√ºcksetzen f√ºr neue Runde
                attackDecisions: {} // Zur√ºcksetzen f√ºr neue Runde
            });
        };

        // --- FORCE NEXT ROUND ---
        window.forceNextRound = async () => {
            if(!isHost) return;
            if(!confirm("M√∂chtest du wirklich zur n√§chsten Runde springen?")) return;
            await nextRound();
            toggleMenu();
        };

        // --- RESET GAME ---
        window.resetGame = async () => {
            if(!isHost) return;
            if(!confirm("M√∂chtest du das Spiel wirklich neustarten? Alle Temperaturen werden zur√ºckgesetzt.")) return;
            
            const pClean = {};
            Object.keys(globalData.players).forEach(p => {
                pClean[p] = {temp: 0, inventory: []};
            });
            
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'lobby', 
                players: pClean, 
                votes: {}, 
                ready: [], 
                log: [],
                hotseat: "",
                roundId: 0,
                lobbyReady: {},
                countdownEnds: null,
                usedQuestions: [],
                pendingAttacks: {},
                attackResults: {},
                popupConfirmed: {}
            });
            toggleMenu();
            document.body.classList.remove('final-mode');
        };

        // --- KILL LOBBY ---
        window.killLobby = async () => {
            if(!isHost) return;
            if(!confirm("Lobby wirklich l√∂schen? Alle Spieler werden ausgeworfen und die Lobby ist danach nicht mehr verf√ºgbar!")) return;
            const ref = doc(db, "lobbies", roomId);
            // L√∂sche sofort - kein Status-Update n√∂tig
            await deleteDoc(ref);
            console.log('Lobby gel√∂scht:', roomId);
        };

        // --- LEAVE LOBBY ---
        window.leaveLobby = async () => {
            // Memory Leak Fix: Cleanup des onSnapshot Listeners beim Verlassen
            if(unsubscribeListener) {
                unsubscribeListener();
                unsubscribeListener = null;
                console.log('onSnapshot Listener aufger√§umt');
            }
            if(!confirm("Lobby wirklich verlassen?")) return;
            
            if(roomId && myName) {
                const ref = doc(db, "lobbies", roomId);
                try {
                    // Entferne Spieler aus dem Raum
                    await updateDoc(ref, {
                        [`players.${myName}`]: deleteField()
                    });
                    
                    // Pr√ºfe ob Raum jetzt leer ist oder nur noch ein Spieler √ºbrig ist (im Winner-Screen)
                    const snap = await getDoc(ref);
                    if(snap.exists()) {
                        const data = snap.data();
                        const players = data.players || {};
                        const remainingPlayers = Object.keys(players).filter(p => {
                            const playerData = players[p];
                            return playerData !== undefined && playerData !== null && typeof playerData === 'object' && Object.keys(playerData).length > 0;
                        });
                        
                        // WICHTIG: Wenn im Winner-Screen und nur noch ein Spieler √ºbrig ist, entferne diesen auch automatisch
                        // Dies verhindert "Geisterlobbies" mit nur einem Spieler
                        if(data.status === 'winner' && remainingPlayers.length === 1) {
                            const lastPlayer = remainingPlayers[0];
                            console.log('Winner-Screen: Nur noch ein Spieler √ºbrig, entferne diesen automatisch:', lastPlayer);
                            await updateDoc(ref, {
                                [`players.${lastPlayer}`]: deleteField()
                            });
                            // Raum ist jetzt leer, l√∂sche ihn
                            await deleteDoc(ref);
                            console.log('Leerer Raum gel√∂scht nach Verlassen (Winner-Screen, letzter Spieler):', roomId);
                        }
                        // Wenn keine Spieler mehr vorhanden, l√∂sche den Raum
                        else if(remainingPlayers.length === 0) {
                            await deleteDoc(ref);
                            console.log('Leerer Raum gel√∂scht nach Verlassen:', roomId);
                        } else {
                            // Entferne aus ready-Liste und anderen Arrays
                            const currentReady = data.ready || [];
                            const updatedReady = currentReady.filter(p => p !== myName);
                            
                            const currentAttackDecisions = data.attackDecisions || {};
                            const updatedAttackDecisions = { ...currentAttackDecisions };
                            delete updatedAttackDecisions[myName];
                            
                            await updateDoc(ref, {
                                ready: updatedReady,
                                attackDecisions: updatedAttackDecisions
                            });
                        }
                    }
                } catch(error) {
                    console.error('Fehler beim Verlassen der Lobby:', error);
                }
            }
            
            document.body.classList.remove('final-mode');
            sessionStorage.clear();
            location.reload();
        };
        
        window.shareLobby = async () => {
            if(!roomId || !globalData) {
                showToast("Kein aktiver Raum zum Teilen verf√ºgbar.");
                return;
            }
            const roomPassword = globalData.password || "";
            const hasPassword = roomPassword && roomPassword.trim().length > 0;
            let text = `üî• Hitzkopf-Code: ${roomId}`;
            if(hasPassword) {
                text += ` | Passwort: ${roomPassword}`;
            }
            text += " ‚Äì komm in meine Lobby!";
            try {
                if(navigator.share) {
                    await navigator.share({ title: "Hitzkopf Lobby", text, url: location.href });
                    showToast("Link erfolgreich geteilt!");
                } else if(navigator.clipboard) {
                    await navigator.clipboard.writeText(text);
                    showToast("Link kopiert! Teile ihn mit deinen Freunden.");
                } else {
                    prompt("Code kopieren:", text);
                }
            } catch (err) {
                console.warn(err);
                showToast("Teilen wurde abgebrochen.");
            }
        };

        window.rematchGame = async () => {
            if(!globalData) return;
            if(globalData.host !== myName) {
                showToast("Nur der Host kann eine Revanche starten.");
                return;
            }
            if(!confirm("M√∂chtest du eine Revanche starten? Alle Temperaturen werden zur√ºckgesetzt.")) return;
            const pClean = {};
            Object.keys(globalData.players).forEach(p => {
                pClean[p] = { temp: 0, inventory: [] };
            });
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'lobby',
                players: pClean,
                votes: {},
                ready: [],
                log: arrayUnion("‚ôªÔ∏è Revanche gestartet! Alle Temperaturen wurden zur√ºckgesetzt."),
                hotseat: "",
                roundId: (globalData.roundId ?? 0) + 1,
                lobbyReady: {},
                countdownEnds: null,
                usedQuestions: [],
                pendingAttacks: {},
                attackResults: {},
                popupConfirmed: {}
            });
            document.body.classList.remove('final-mode');
            showToast("Revanche gestartet! Alle zur√ºck in die Lobby.");
        };

        // --- RENDER HELPERS ---
        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            
            // Anleitung-Button nur auf Start-Screen anzeigen
            const anleitungBtn = document.getElementById('anleitungButton');
            if(anleitungBtn) {
                anleitungBtn.style.display = (id === 'screen-start') ? 'block' : 'none';
            }
            
            // Host-Einstellungen und Join-Panel zur√ºcksetzen wenn nicht auf Start-Screen
            if(id !== 'screen-start') {
                const hostSettings = document.getElementById('hostSettings');
                const joinPanel = document.getElementById('joinPanel');
                if(hostSettings) hostSettings.classList.add('hidden');
                if(joinPanel) joinPanel.classList.add('hidden');
            }
        }

        function renderGameOver(loser, players) {
            showScreen('screen-gameover');
            document.body.classList.add('final-mode');
            const nameEl = document.getElementById('lblLoser');
            const captionEl = document.getElementById('lblFinalText');
            const fillEl = document.getElementById('finalThermoFill');
            const emojiEl = document.getElementById('finalEmoji');
            const btnRematch = document.getElementById('btnRematch');
            nameEl.innerText = loser;
            captionEl.innerText = `${loser} hat 100¬∞C erreicht ‚Äì ein echter Hitzkopf! üî•`;
            if(emojiEl) emojiEl.innerText = 'ü•µ';
            if(fillEl) {
                fillEl.style.width = '0%';
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        const temp = Math.min(players[loser]?.temp ?? 120, 120);
                        fillEl.style.width = `${Math.min(temp, 120)}%`;
                    });
                });
            }
            const rankingEl = document.getElementById('finalRanking');
            if(rankingEl) {
                const survivors = Object.keys(players).filter(p => p !== loser)
                    .sort((a,b) => players[a].temp - players[b].temp);
                if(!survivors.length) {
                    rankingEl.innerHTML = `<div class="final-rank-item">Keine weiteren Spieler.</div>`;
                } else {
                    const coolest = survivors[0];
                    rankingEl.innerHTML = survivors.map((p, idx) => `
                        <div class="final-rank-item ${p === coolest ? 'coolest' : ''}">
                            <span>${idx + 1}. ${p}</span>
                            <span>${players[p].temp}¬∞C ${p === coolest ? 'üßä' : ''}</span>
                        </div>
                    `).join('');
                }
            if(btnRematch) {
                if(isHost) {
                    btnRematch.disabled = false;
                    btnRematch.innerText = "‚ôªÔ∏è Revanche starten";
                } else {
                    btnRematch.disabled = true;
                    btnRematch.innerText = "‚è≥ Host entscheidet...";
                }
            }
            }
        }

        function renderThermos(players, targetId) {
            const div = document.getElementById(targetId);
            if(!div) return;
            
            const order = Object.keys(players).sort((a,b) => players[b].temp - players[a].temp);
            let html = "";
            const newTemps = {};
            order.forEach((p, idx) => {
                const d = players[p];
                const percent = Math.min(d.temp, 100);
                let color = '#0f0';
                if(d.temp >= 80) color = '#ff4500';
                else if(d.temp >= 50) color = '#ff8c00';
                else if(d.temp >= 30) color = '#ffa500';
                
                const inventory = d.inventory?.length > 0 ? 
                    ` <span style="font-size:0.7rem;">üé¥${d.inventory.length}</span>` : '';
                const classes = ['thermo-item'];
                const isHotseat = globalData?.hotseat === p;
                if(idx === 0) classes.push('top-hot');
                if(isHotseat) classes.push('is-hotseat');
                if(targetId === 'gridGame' && lastTemps[p] != null && d.temp > lastTemps[p]) {
                    classes.push('shake');
                }
                const playerEmoji = d.emoji || 'üòä';
                // Hitzkopf nur bei hei√üester Person (letzter Platz, k√∂nnen mehrere sein)
                // ü•µ Emoji nur noch f√ºr Hitzk√∂pfe, nicht mehr f√ºr Hotseat
                const maxTemp = Math.max(...Object.values(players).map(p => p.temp || 0));
                const isHottest = d.temp === maxTemp && d.temp > 0;
                const prefix = isHottest ? 'üî• ' : '';
                const nameLabel = `${prefix}${playerEmoji} ${p}${inventory}`;
                
                html += `
                    <div class="${classes.join(' ')}">
                        <div class="thermo-top">
                            <span>${nameLabel}</span>
                            <span>${d.temp}¬∞C</span>
                        </div>
                        <div class="thermo-bar">
                            <div class="thermo-fill" style="width:${percent}%; background:${color}"></div>
                        </div>
                    </div>
                `;
                newTemps[p] = d.temp;
            });
            div.innerHTML = html;
            if(targetId === 'gridGame') {
                lastTemps = newTemps;
            }
        }

        function renderLog(log) {
            // Rendere in beiden Stellen: Men√º (divLogMenu) und Result-Screen (divLog, falls vorhanden)
            const elMenu = document.getElementById('divLogMenu');
            const elResult = document.getElementById('divLog');
            if(!elMenu && !elResult || !log) return;
            
            const html = log.slice(-15).reverse().map(l => {
                let className = 'log-entry';
                if(l.includes('üî•')) className += ' attack';
                return `<div class="${className}">${l}</div>`;
            }).join('');
            
            if(elMenu) {
                elMenu.innerHTML = html;
                elMenu.scrollTop = 0; // Auto-scroll to top (newest)
            }
            if(elResult) {
                elResult.innerHTML = html;
                elResult.scrollTop = 0; // Auto-scroll to top (newest)
            }
        }

        async function maybeLogRoundSummary(data, truthText, truthKey) {
            if(!isHost) return;
            if(data.roundId == null) return;
            if(loggedRoundResult === data.roundId) return;
            if(!truthKey) return;

            loggedRoundResult = data.roundId;
            const players = Object.keys(data.players).filter(p => p !== data.hotseat);
            const correct = players.filter(p => data.votes[p]?.choice === truthKey);
            const wrong = players.filter(p => !correct.includes(p));
            const entries = [
                `üß† Wahrheit (${data.hotseat}): ${truthText}`
            ];

            if(correct.length) {
                entries.push(`‚úÖ Richtige Spieler: ${correct.join(', ')}`);
                if(wrong.length) entries.push(`‚ùå Daneben: ${wrong.join(', ')}`);
            } else {
                entries.push('‚ö™ Niemand lag richtig ‚Äì keine Aktionen in dieser Runde.');
            }

            await updateDoc(doc(db, "lobbies", roomId), {
                log: arrayUnion(...entries)
            });
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            if(!toast) return;
            toast.innerText = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2500);
        }

        function renderMyJokers(targetId, playerData) {
            const container = document.getElementById(targetId);
            if(!container) return;
            const inventory = playerData?.inventory || [];
            const cards = Object.keys(cardInfo);
            container.innerHTML = cards.map(key => {
                const info = cardInfo[key];
                const has = inventory.includes(key);
                return `
                    <div class="joker-chip ${has ? 'has' : ''}">
                        <strong>${info.label}</strong>
                        <span>${info.desc}</span>
                    </div>
                `;
            }).join('');
        }

        async function applyIceCooling(players) {
            if(!players) return;
            const ref = doc(db, "lobbies", roomId);
            const coolValue = globalData?.config?.dmg || 10;
            for(const name of Object.keys(players)) {
                if(players[name].inventory?.includes('card_ice')) {
                    const reduction = Math.min(coolValue, players[name].temp);
                    await updateDoc(ref, {
                        [`players.${name}.temp`]: increment(-reduction),
                        [`players.${name}.inventory`]: arrayRemove('card_ice'),
                        log: arrayUnion(`üßä ${name} k√ºhlt sich ab (-${reduction}¬∞C)`)
                    });
                }
            }
        }

        function findLatestAttackOnMe(log = []) {
            if(!log || !Array.isArray(log)) return null;
            for(let i = log.length - 1; i >= 0; i--) {
                const entry = log[i];
                const match = entry?.match(/üî•\s(.+?)\s+greift\s+(.+?)\san\s\(\+(\d+)¬∞C\)/);
                if(match && match[2] === myName) {
                    return { attacker: match[1], dmg: parseInt(match[3], 10) || null };
                }
            }
            return null;
        }

        function triggerAttackFeedback(attackResult) {
            // PERFORMANCE-OPTIMIERUNG: Gecachte DOM-Elemente verwenden
            const modal = domCache.get('attackModal');
            const containerEl = domCache.get('attackModalContainer');
            if(!modal) return;
            
            // Pr√ºfe ob Modal bereits offen ist - verhindere mehrfache Anzeige
            if(modal.style.display === 'flex') {
                console.log('Modal bereits offen, √ºberspringe triggerAttackFeedback');
                return;
            }
            
            // Pr√ºfe ob bereits ein Modal-√ñffnungsprozess l√§uft
            if(isOpeningAttackModal) {
                console.log('Modal wird bereits ge√∂ffnet, √ºberspringe triggerAttackFeedback');
                return;
            }
            
            // Markiere dass Modal ge√∂ffnet wird
            isOpeningAttackModal = true;
            
            // attackResult kann sein: { attackers: [], totalDmg: 0, attackDetails: [{ attacker, dmg, isPenalty }] }
            // oder null/undefined wenn nicht angegriffen
            // Pr√ºfe ob Spieler angegriffen wurde:
            // 1. totalDmg > 0 = definitiv angegriffen
            // 2. attackers Array nicht leer = wurde angegriffen (auch wenn gespiegelt)
            // 3. attackDetails enth√§lt normale Angriffe (nicht nur Strafhitze)
            const hasAttackers = attackResult && attackResult.attackers && attackResult.attackers.length > 0;
            const hasAttackDetails = attackResult && attackResult.attackDetails && attackResult.attackDetails.length > 0;
            const hasRegularAttacks = hasAttackDetails && attackResult.attackDetails.some(d => !d.isPenalty && !d.mirrored);
            
            // WICHTIG: Pr√ºfe zuerst ob es Angreifer gibt (attackers Array) - das ist das zuverl√§ssigste Signal
            const wasAttacked = attackResult && (
                attackResult.totalDmg > 0 || 
                hasAttackers ||
                hasRegularAttacks
            );
            
            console.log('triggerAttackFeedback: wasAttacked Pr√ºfung', {
                totalDmg: attackResult?.totalDmg,
                hasAttackers,
                hasRegularAttacks,
                attackers: attackResult?.attackers,
                attackDetails: attackResult?.attackDetails,
                wasAttacked
            });
            
            // Screen Shake nur einmal pro Angriff (verhindere mehrfache Trigger)
            if(wasAttacked && !document.body.classList.contains('viewport-shake')) {
                document.body.classList.add('viewport-shake');
                setTimeout(() => {
                    document.body.classList.remove('viewport-shake');
                }, 600);
            }
            
            // Aktuelle Temperatur des Spielers - lese aus globalData (wird durch onSnapshot aktualisiert)
            // WICHTIG: globalData enth√§lt die Temperatur VOR dem Angriff (wird nach executePendingAttacks aktualisiert)
            // Wenn das Popup angezeigt wird, wurde executePendingAttacks bereits ausgef√ºhrt
            // also ist globalData bereits auf die neue Temperatur aktualisiert
            // Berechne daher die alte Temperatur durch Subtraktion des Schadens
            const newTempFromDB = globalData?.players?.[myName]?.temp || 0;
            const damage = attackResult?.totalDmg || 0;
            
            // Berechne die Temperatur VOR dem Angriff (falls globalData bereits aktualisiert wurde)
            // Wenn wasAttacked = true, dann wurde der Schaden bereits angewendet, also subtrahiere den Schaden
            const currentTemp = wasAttacked ? Math.max(0, newTempFromDB - damage) : newTempFromDB;
            // newTemp ist die Temperatur NACH dem Angriff (currentTemp + damage)
            const newTemp = wasAttacked ? (currentTemp + damage) : currentTemp;
            const maxTemp = globalData?.config?.maxTemp || 100;
            // Zeige im Thermometer die neue Temperatur (nach dem Angriff)
            const tempPercent = Math.min((newTemp / maxTemp) * 100, 100);
            
            console.log('triggerAttackFeedback:', { myName, currentTemp, totalDmg: attackResult.totalDmg, newTemp, wasAttacked });
            
            // Setze Modal-Inhalte
            const emojiEl = document.getElementById('attackModalEmoji');
            const nameEl = document.getElementById('attackModalName');
            const textEl = document.getElementById('attackModalText');
            const detailsEl = document.getElementById('attackModalDetails');
            const thermoEl = document.getElementById('attackModalThermoFill');
            const tempEl = document.getElementById('attackModalTemp');
            
            if(wasAttacked) {
                // Angegriffen - Roter Rahmen
                if(containerEl) {
                    containerEl.style.border = '2px solid #ff4500';
                    containerEl.style.boxShadow = '0 8px 32px rgba(255,69,0,0.8)';
                }
                
                const attackers = attackResult.attackers || [];
                const attackDetails = attackResult.attackDetails || [];
                
                if(emojiEl) emojiEl.innerText = 'üî•';
                if(nameEl) {
                    nameEl.innerText = myName;
                    nameEl.style.color = '#ff4500';
                }
                
                // Pr√ºfe ob gespiegelt wurde
                const wasMirrored = attackDetails.some(d => d.mirrored) && attackResult.totalDmg === 0;
                
                // Pr√ºfe ob nur Strafhitze vorhanden ist (keine normalen Angriffe)
                const regularAttacks = attackDetails.filter(d => !d.isPenalty && !d.mirrored);
                const penaltyAttacks = attackDetails.filter(d => d.isPenalty);
                const onlyPenalty = regularAttacks.length === 0 && penaltyAttacks.length > 0;
                
                if(wasMirrored) {
                    // Angriffe wurden gespiegelt
                    if(textEl) textEl.innerText = `Angriffe gespiegelt - kein Schaden erhalten`;
                } else if(onlyPenalty) {
                    // Nur Strafhitze - spezieller Text
                    const totalPenalty = penaltyAttacks.reduce((sum, p) => sum + p.dmg, 0);
                    if(textEl) textEl.innerText = `Falsch geraten! Das gibt eine Strafhitze von ${totalPenalty}¬∞C`;
                } else {
                    // Gesamtschaden (normale Angriffe oder gemischt)
                    if(textEl) textEl.innerText = `Du wurdest aufgeheizt! Insgesamt ${attackResult.totalDmg}¬∞C`;
                }
                
                // Details: Wer hat wie viel Schaden verursacht (inkl. Strafhitze)
                if(detailsEl && attackDetails.length > 0) {
                    let detailsHTML = '<div style="margin-top:10px; padding-top:10px; border-top:1px solid #333;"><strong>Angriffe:</strong><br>';
                    
                    // Normale Angriffe
                    regularAttacks.forEach(detail => {
                        if(detail.mirrored) {
                            detailsHTML += `‚Ä¢ ${detail.attacker}: gespiegelt (${detail.dmg}¬∞C zur√ºck)<br>`;
                        } else {
                            detailsHTML += `‚Ä¢ ${detail.attacker}: +${detail.dmg}¬∞C<br>`;
                        }
                    });
                    
                    // Strafhitze
                    if(penaltyAttacks.length > 0) {
                        const totalPenalty = penaltyAttacks.reduce((sum, p) => sum + p.dmg, 0);
                        detailsHTML += `‚Ä¢ Strafhitze: +${totalPenalty}¬∞C<br>`;
                    }
                    
                    detailsHTML += '</div>';
                    detailsEl.innerHTML = detailsHTML;
                } else if(detailsEl) {
                    // Fallback wenn keine Details vorhanden
                    if(attackers.length > 1) {
                        detailsEl.innerHTML = `<div style="margin-top:10px; padding-top:10px; border-top:1px solid #333;">Gemeinsamer Angriff von: ${attackers.join(', ')}</div>`;
                    } else if(attackers.length === 1) {
                        detailsEl.innerHTML = `<div style="margin-top:10px; padding-top:10px; border-top:1px solid #333;">Angriff von: ${attackers[0]}</div>`;
                    } else {
                        detailsEl.innerHTML = '';
                    }
                }
                
                // Thermometer mit √Ñnderung
                // Zeige die neue Temperatur (alt + Schaden)
                if(thermoEl) {
                    thermoEl.style.background = 'linear-gradient(90deg, #ffae00, #ff0000)';
                }
                if(tempEl) {
                    // Zeige die neue Temperatur nach dem Angriff
                    tempEl.innerText = `${newTemp}¬∞C`;
                    tempEl.style.color = '#ff4500';
                }
            } else {
                // Nicht angegriffen - Blauer Rahmen
                if(containerEl) {
                    containerEl.style.border = '2px solid #4a9eff';
                    containerEl.style.boxShadow = '0 8px 32px rgba(74,158,255,0.8)';
                }
                
                if(emojiEl) emojiEl.innerText = 'üßä';
                if(nameEl) {
                    nameEl.innerText = myName;
                    nameEl.style.color = '#4a9eff';
                }
                if(textEl) textEl.innerText = 'Cool geblieben - Keiner hat dich aufgeheizt';
                if(detailsEl) detailsEl.innerHTML = '<div style="margin-top:10px; padding-top:10px; border-top:1px solid #333;">Du hast diese Runde keine Hitze erhalten</div>';
                
                // Thermometer ohne √Ñnderung (bleibt bei currentTemp)
                if(thermoEl) {
                    thermoEl.style.background = 'linear-gradient(90deg, #4a9eff, #0066cc)';
                }
                if(tempEl) {
                    tempEl.innerText = `${currentTemp}¬∞C`;
                    tempEl.style.color = '#4a9eff';
                }
            }
            
            // Animiere Thermometer
            if(thermoEl) {
                thermoEl.style.width = '0%';
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        thermoEl.style.width = `${tempPercent}%`;
                    });
                });
            }
            
            // Zeige Modal
            modal.style.display = 'flex';
            
            // Modal ist jetzt offen - setze Flag zur√ºck
            isOpeningAttackModal = false;
        }
        
        window.closeAttackModal = async () => {
            const modal = document.getElementById('attackModal');
            if(modal) {
                modal.style.display = 'none';
            }
            
            // WICHTIG: Markiere Spieler als "Popups best√§tigt"
            if(roomId && myName) {
                try {
                    const ref = doc(db, "lobbies", roomId);
                    const currentData = await getDoc(ref);
                    const currentPopupConfirmed = currentData.data()?.popupConfirmed || {};
                    
                    // Pr√ºfe ob bereits best√§tigt
                    if(!currentPopupConfirmed[myName]) {
                        await updateDoc(ref, {
                            [`popupConfirmed.${myName}`]: true
                        });
                        console.log('Popup best√§tigt von:', myName);
                    }
                } catch(error) {
                    console.error('Fehler beim Markieren des Popups als best√§tigt:', error);
                }
            }
        };
        
        function triggerHotseatAlert(hotseatName, players) {
            const modal = document.getElementById('hotseatModal');
            if(!modal) return;
            
            const playerData = players[hotseatName];
            const playerEmoji = playerData?.emoji || 'üòä';
            
            const emojiEl = document.getElementById('hotseatModalEmoji');
            const nameEl = document.getElementById('hotseatModalName');
            const textEl = document.getElementById('hotseatModalText');
            
            if(hotseatName === myName) {
                if(emojiEl) emojiEl.innerText = 'üéØ';
                if(nameEl) nameEl.innerText = 'Du bist gefragt!';
                if(textEl) textEl.innerText = 'Alle anderen m√ºssen deine Antwort erraten.';
            } else {
                if(emojiEl) emojiEl.innerText = 'üéØ';
                if(nameEl) nameEl.innerText = `${playerEmoji} ${hotseatName}`;
                if(textEl) textEl.innerText = `ist gefragt. Versuche ${hotseatName}'s Antwort zu erraten.`;
            }
            
            // Zeige Modal
            modal.style.display = 'flex';
        }
        
        window.closeHotseatModal = () => {
            const modal = document.getElementById('hotseatModal');
            if(modal) {
                modal.style.display = 'none';
            }
        };
        
        // Alte Funktionen f√ºr R√ºckw√§rtskompatibilit√§t
        window.closeHotseatAlert = () => {
            closeHotseatModal();
        };
        
        // --- EXECUTE PENDING ATTACKS ---
        async function executePendingAttacks(data) {
            if(!isHost) {
                console.log('executePendingAttacks: Nicht der Host, √ºberspringe');
                return;
            }
            
            console.log('executePendingAttacks: Starte Ausf√ºhrung');
            const pendingAttacks = data.pendingAttacks || {};
            const players = data.players || {};
            
            console.log('executePendingAttacks: pendingAttacks =', pendingAttacks);
            console.log('executePendingAttacks: players =', Object.keys(players));
            
            // WICHTIG: Initialisiere tempUpdates und attackResults VOR der Pr√ºfung auf leere Angriffe
            // damit Strafhitze auch ohne normale Angriffe angewendet werden kann
            const ref = doc(db, "lobbies", roomId);
            const tempUpdates = {};
            const attackResults = {}; // F√ºr Anzeige bei betroffenen Spielern: { target: { attackers: [], totalDmg: 0 } }
            const logEntries = [];
            
            // Verarbeite alle Angriffe
            for(const [target, attacks] of Object.entries(pendingAttacks)) {
                if(!players[target] || attacks.length === 0) continue;
                
                const targetState = players[target];
                const targetHasMirror = targetState.inventory?.includes('card_mirror');
                let totalDmg = 0;
                const attackerNames = [];
                
                // Summiere Schaden und sammle Angreifer
                attacks.forEach(attack => {
                    totalDmg += attack.dmg;
                    attackerNames.push(attack.attacker);
                    
                    // Log-Eintrag f√ºr einzelnen Angriff
                    if(attack.hasOil) {
                        logEntries.push(`üî• ${attack.attacker} greift ${target} mit dem √ñlfass an (+${attack.dmg}¬∞C)`);
                    } else {
                        logEntries.push(`üî• ${attack.attacker} greift ${target} an (+${attack.dmg}¬∞C)`);
                    }
                });
                
                // Spiegele Angriffe zur√ºck wenn Spiegel vorhanden
                if(targetHasMirror) {
                    await updateDoc(ref, {
                        [`players.${target}.inventory`]: arrayRemove('card_mirror')
                    });
                    
                    // Spiegle an jeden Angreifer zur√ºck
                    attacks.forEach(attack => {
                        if(!tempUpdates[`players.${attack.attacker}.temp`]) {
                            tempUpdates[`players.${attack.attacker}.temp`] = 0;
                        }
                        tempUpdates[`players.${attack.attacker}.temp`] += attack.dmg;
                        
                        // F√ºr Anzeige bei gespiegelten Angreifern
                        if(!attackResults[attack.attacker]) {
                            attackResults[attack.attacker] = {
                                attackers: [target],
                                totalDmg: attack.dmg,
                                attackDetails: [{ attacker: target, dmg: attack.dmg, mirrored: true }]
                            };
                        } else {
                            attackResults[attack.attacker].totalDmg += attack.dmg;
                            attackResults[attack.attacker].attackDetails.push({ attacker: target, dmg: attack.dmg, mirrored: true });
                            if(!attackResults[attack.attacker].attackers.includes(target)) {
                                attackResults[attack.attacker].attackers.push(target);
                            }
                        }
                    });
                    
                    // F√ºr Angegriffenen: Zeige dass Angriffe gespiegelt wurden
                    attackResults[target] = {
                        attackers: attackerNames,
                        totalDmg: 0, // Kein Schaden durch Spiegel
                        attackDetails: attacks.map(a => ({ attacker: a.attacker, dmg: a.dmg, mirrored: true }))
                    };
                    
                    // Sammle alle Angreifer f√ºr Log
                    const attackerList = attackerNames.join(' und ');
                    logEntries.push(`ü™û ${target} spiegelt die Angriffe von ${attackerList} zur√ºck! (+${totalDmg}¬∞C)`);
                } else {
                    // Normaler Angriff
                    if(!tempUpdates[`players.${target}.temp`]) {
                        tempUpdates[`players.${target}.temp`] = 0;
                    }
                    tempUpdates[`players.${target}.temp`] += totalDmg;
                    
                    // F√ºr Anzeige beim Angegriffenen - mit Details
                    // WICHTIG: Erstelle neues Objekt, nicht √ºberschreibe
                    attackResults[target] = {
                        attackers: [...attackerNames], // Kopie des Arrays
                        totalDmg: totalDmg,
                        attackDetails: attacks.map(a => ({ attacker: a.attacker, dmg: a.dmg }))
                    };
                    
                    console.log('executePendingAttacks: Angriff auf', target, 'gespeichert:', {
                        attackers: attackerNames,
                        totalDmg,
                        attackDetails: attackResults[target].attackDetails
                    });
                }
            }
            
            // Erstelle Attack-Ergebnisse f√ºr ALLE Spieler (auch die nicht angegriffenen)
            const allPlayers = Object.keys(players);
            
            // F√ºge Strafhitze f√ºr alle Spieler hinzu, die falsch geraten haben
            const votes = data.votes || {};
            const truth = data.votes?.[data.hotseat]?.choice;
            const playersUpdate = {}; // F√ºr consecutiveWrongAnswers Updates
            const gameMode = data.config?.gameMode || 'party';
            const isPartyMode = gameMode === 'party';
            
            allPlayers.forEach(playerName => {
                if(playerName === data.hotseat) return; // Hotseat bekommt keine Strafhitze
                
                const playerVote = votes[playerName];
                const playerData = players[playerName] || {};
                let consecutiveWrong = playerData.consecutiveWrongAnswers || 0;
                
                // Pr√ºfe ob Spieler falsch geraten hat
                if(playerVote && playerVote.choice !== truth) {
                    // Erh√∂he consecutiveWrongAnswers (auch wenn noch 0)
                    consecutiveWrong += 1;
                    if(!playersUpdate[playerName]) {
                        playersUpdate[playerName] = {};
                    }
                    playersUpdate[playerName].consecutiveWrongAnswers = consecutiveWrong;
                    
                    // Berechne Strafhitze: 1x = 10¬∞, 3x = 20¬∞, 5x = 30¬∞
                    let penaltyDmg = 10;
                    if(consecutiveWrong >= 5) {
                        penaltyDmg = 30;
                    } else if(consecutiveWrong >= 3) {
                        penaltyDmg = 20;
                    } else {
                        penaltyDmg = 10;
                    }
                    
                    // WICHTIG: Im Party Mode wurde bereits 10¬∞ in handlePartyModeWrongAnswer angewendet
                    // Subtrahiere diese 10¬∞ von der Strafhitze, damit die korrekte Gesamtsumme erreicht wird
                    // Im Strategic Mode wird die volle Strafhitze angewendet
                    const actualPenaltyDmg = isPartyMode ? Math.max(0, penaltyDmg - 10) : penaltyDmg;
                    
                    // F√ºge Strafhitze zu Temperatur-Update hinzu (nur wenn > 0)
                    if(actualPenaltyDmg > 0) {
                        if(!tempUpdates[`players.${playerName}.temp`]) {
                            tempUpdates[`players.${playerName}.temp`] = 0;
                        }
                        tempUpdates[`players.${playerName}.temp`] += actualPenaltyDmg;
                    }
                    
                    // F√ºge Strafhitze zu attackResults hinzu (zeige immer die volle Strafhitze, auch wenn im Party Mode bereits 10¬∞ angewendet wurden)
                    if(!attackResults[playerName]) {
                        attackResults[playerName] = {
                            attackers: [],
                            totalDmg: 0,
                            attackDetails: []
                        };
                    }
                    // Im Party Mode: Zeige die bereits angewendeten 10¬∞ + zus√§tzliche Strafhitze (wenn vorhanden)
                    // Im Strategic Mode: Zeige die volle Strafhitze
                    const displayedPenaltyDmg = isPartyMode ? 10 + actualPenaltyDmg : penaltyDmg;
                    attackResults[playerName].totalDmg += displayedPenaltyDmg;
                    attackResults[playerName].attackDetails.push({
                        attacker: 'Strafhitze',
                        dmg: displayedPenaltyDmg,
                        isPenalty: true
                    });
                    
                    if(actualPenaltyDmg > 0) {
                        logEntries.push(`‚ùÑÔ∏è ${playerName} erh√§lt zus√§tzliche Strafhitze f√ºr falsche Antwort (+${actualPenaltyDmg}¬∞C)`);
                    } else {
                        logEntries.push(`‚ùÑÔ∏è ${playerName} erh√§lt Strafhitze f√ºr falsche Antwort (+${displayedPenaltyDmg}¬∞C)`);
                    }
                } else if(playerVote && playerVote.choice === truth) {
                    // Bei richtiger Antwort: consecutiveWrongAnswers zur√ºcksetzen
                    if(consecutiveWrong > 0) {
                        if(!playersUpdate[playerName]) {
                            playersUpdate[playerName] = {};
                        }
                        playersUpdate[playerName].consecutiveWrongAnswers = 0;
                    }
                }
            });
            
            allPlayers.forEach(playerName => {
                if(!attackResults[playerName]) {
                    // Spieler wurde nicht angegriffen und hat keine Strafhitze
                    attackResults[playerName] = {
                        attackers: [],
                        totalDmg: 0,
                        attackDetails: []
                    };
                } else {
                    // Debug: Logge f√ºr jeden Spieler mit attackResults
                    console.log('executePendingAttacks: Finale attackResults f√ºr', playerName, ':', {
                        attackers: attackResults[playerName].attackers,
                        totalDmg: attackResults[playerName].totalDmg,
                        attackDetails: attackResults[playerName].attackDetails
                    });
                }
            });
            
            // F√ºhre alle Temperatur-Updates aus
            const updateData = { pendingAttacks: {} };
            
            // Log-Eintr√§ge hinzuf√ºgen wenn vorhanden
            if(logEntries.length > 0) {
                updateData.log = arrayUnion(...logEntries);
            }
            
            // Aktualisiere consecutiveWrongAnswers f√ºr alle betroffenen Spieler
            if(Object.keys(playersUpdate).length > 0) {
                for(const [playerName, updates] of Object.entries(playersUpdate)) {
                    Object.keys(updates).forEach(key => {
                        updateData[`players.${playerName}.${key}`] = updates[key];
                    });
                }
            }
            
            // Konvertiere verschachtelte Pfade zu Firebase-Update-Format
            const playersTempUpdate = {};
            for(const [path, dmg] of Object.entries(tempUpdates)) {
                // Pfad ist z.B. "players.${target}.temp"
                const parts = path.split('.');
                if(parts.length === 3 && parts[0] === 'players' && parts[2] === 'temp') {
                    const playerName = parts[1];
                    if(!playersTempUpdate[playerName]) {
                        playersTempUpdate[playerName] = {};
                    }
                    playersTempUpdate[playerName].temp = increment(dmg);
                    console.log(`executePendingAttacks: Temperatur-Update f√ºr ${playerName}: +${dmg}¬∞C`);
                }
            }
            
            // F√ºge Spieler-Temperatur-Updates hinzu
            if(Object.keys(playersTempUpdate).length > 0) {
                for(const [playerName, updates] of Object.entries(playersTempUpdate)) {
                    Object.keys(updates).forEach(key => {
                        updateData[`players.${playerName}.${key}`] = updates[key];
                    });
                }
                console.log('executePendingAttacks: Temperatur-Updates vorbereitet:', Object.keys(playersTempUpdate));
            } else {
                console.log('executePendingAttacks: Keine Temperatur-Updates');
            }
            
            // Speichere Angriffsergebnisse f√ºr Anzeige bei ALLEN Spielern (auch die nicht angegriffenen)
            // attackResults enth√§lt bereits alle Spieler (siehe oben)
            updateData.attackResults = attackResults;
            // WICHTIG: Setze roundRecapShown zusammen mit attackResults, damit sie atomar gespeichert werden
            updateData.roundRecapShown = true;
            
            // Debug: Logge alle attackResults f√ºr jeden Spieler
            console.log('executePendingAttacks: attackResults vorbereitet:');
            Object.keys(attackResults).forEach(playerName => {
                const result = attackResults[playerName];
                console.log(`  ${playerName}:`, {
                    attackers: result.attackers,
                    totalDmg: result.totalDmg,
                    attackDetailsCount: result.attackDetails?.length || 0,
                    fullResult: result
                });
            });
            
            try {
                await updateDoc(ref, updateData);
                console.log('executePendingAttacks: Update erfolgreich gespeichert (inkl. attackResults und roundRecapShown)');
            } catch(error) {
                console.error('executePendingAttacks: Fehler beim Speichern:', error);
                throw error;
            }
        }

        function handleCountdownOverlay(data) {
            const overlay = document.getElementById('countdownOverlay');
            if(!overlay) return;
            if(data.status === 'countdown' && data.countdownEnds) {
                countdownTarget = data.countdownEnds;
                overlay.classList.add('show');
                startCountdownTicker();
            } else {
                overlay.classList.remove('show');
                stopCountdownTicker();
            }
        }

        function startCountdownTicker() {
            updateCountdownText();
            if(countdownInterval) clearInterval(countdownInterval);
            countdownInterval = setInterval(updateCountdownText, 250);
        }

        function stopCountdownTicker() {
            if(countdownInterval) clearInterval(countdownInterval);
            countdownInterval = null;
            countdownTarget = null;
        }

        function updateCountdownText() {
            if(!countdownTarget) return;
            const textEl = document.getElementById('countdownText');
            if(!textEl) return;
            const remainingMs = countdownTarget - Date.now();
            const seconds = Math.max(0, Math.ceil(remainingMs / 1000));
            if(seconds > 0) {
                textEl.innerHTML = seconds.toString();
            } else {
                textEl.innerHTML = "Hitz<br>kopf";
            }
        }

        // --- SPECTATOR MODE ---
        function showSpectatorMode() {
            const banner = document.getElementById('spectatorBanner');
            if(!banner) {
                const newBanner = document.createElement('div');
                newBanner.id = 'spectatorBanner';
                newBanner.className = 'spectator-banner';
                newBanner.innerText = 'üî• Du bist ein Hitzkopf! Bis zur n√§chsten Runde bist du leider raus. Zeit abzuk√ºhlen.';
                document.body.appendChild(newBanner);
            }
            document.body.classList.add('spectator-mode');
        }

        function hideSpectatorMode() {
            const banner = document.getElementById('spectatorBanner');
            if(banner) banner.remove();
            document.body.classList.remove('spectator-mode');
        }

        // --- ELIMINATION ANIMATION ---
        function showEliminationAnimation(playerName, temp) {
            const overlay = document.getElementById('fullscreenAnimation');
            if(!overlay) return;
            
            const emojiEl = document.getElementById('animEmoji');
            const nameEl = document.getElementById('animName');
            const textEl = document.getElementById('animText');
            const thermoEl = document.getElementById('animThermoFill');
            const tempEl = document.getElementById('animTemp');
            
            if(emojiEl) emojiEl.innerText = 'ü•µ';
            if(nameEl) nameEl.innerText = playerName;
            if(textEl) textEl.innerText = 'ist ein Hitzkopf und fliegt raus! üî•';
            if(tempEl) tempEl.innerText = `${temp}¬∞C`;
            
            overlay.style.display = 'flex';
            
            // Thermometer animieren
            if(thermoEl) {
                thermoEl.style.width = '0%';
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        thermoEl.style.width = `${Math.min(temp, 120)}%`;
                    });
                });
            }
            
            // Nach 3 Sekunden ausblenden
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 3000);
        }

        // --- RENDER WINNER ---
        function renderWinner(winnerName, players, data) {
            const nameEl = document.getElementById('winnerName');
            const emojiEl = document.getElementById('winnerEmoji');
            const tempEl = document.getElementById('winnerTemp');
            const thermoEl = document.getElementById('winnerThermoFill');
            const rankingEl = document.getElementById('rankingList');
            
            const winnerData = players[winnerName];
            const winnerEmoji = winnerData?.emoji || 'üòé';
            
            if(nameEl) nameEl.innerText = winnerName;
            if(emojiEl) emojiEl.innerText = winnerEmoji;
            const temp = winnerData?.temp || 0;
            if(tempEl) tempEl.innerText = `${temp}¬∞C`;
            
            // Thermometer animieren
            if(thermoEl) {
                thermoEl.style.width = '0%';
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        thermoEl.style.width = `${Math.min((temp / 100) * 100, 100)}%`;
                    });
                });
            }
            
            // Ranking: Rausgeflogene Hitzk√∂pfe mit üî• Emoji
            const maxTemp = globalData?.config?.maxTemp || 100;
            const eliminated = Object.keys(players)
                .filter(p => p !== winnerName && (players[p].temp || 0) >= maxTemp)
                .sort((a, b) => (players[b].temp || 0) - (players[a].temp || 0)); // H√∂chste zuerst (zuletzt rausgeflogen)
            
            if(rankingEl && eliminated.length > 0) {
                rankingEl.innerHTML = `
                    <h3 style="color:#ff8c00; margin-bottom:15px; font-size:1.2rem; text-align:center;">üî• Hitzk√∂pfe</h3>
                    ${eliminated.map((p, idx) => {
                    const playerData = players[p];
                    const playerEmoji = playerData?.emoji || 'ü•µ';
                    const playerTemp = playerData?.temp || 0;
                    return `
                        <div style="padding:12px; margin-bottom:8px; background:rgba(255,69,0,0.1); border:1px solid rgba(255,69,0,0.3); border-radius:10px; display:flex; justify-content:space-between; align-items:center;">
                            <div>
                                <span style="font-size:1.5rem; margin-right:8px;">üî• ${playerEmoji}</span>
                                <span style="font-size:1.1rem; font-weight:bold; color:#ff8c00;">${p}</span>
                            </div>
                            <div style="font-size:1rem; color:#ff4500; font-weight:bold;">${playerTemp}¬∞C</div>
                        </div>
                    `;
                }).join('')}
                `;
            } else if(rankingEl) {
                rankingEl.innerHTML = '<div style="text-align:center; color:#888; padding:20px;">Keine weiteren Spieler</div>';
            }
            
            // Voting-Funktionalit√§t rendern
            if(data) {
                renderWinnerVoting(data);
            }
            
            // Konfetti starten
            startConfetti();
        }
        
        // --- RENDER WINNER VOTING ---
        function renderWinnerVoting(data) {
            const votingStatus = document.getElementById('votingStatus');
            const votingResults = document.getElementById('votingResults');
            const btnRematch = document.getElementById('btnVoteRematch');
            const btnLeave = document.getElementById('btnVoteLeave');
            
            const votes = data.rematchVotes || {};
            const players = Object.keys(data.players);
            const maxTemp = data.config?.maxTemp || 100;
            const activePlayers = players.filter(p => (data.players[p].temp || 0) < maxTemp);
            
            const rematchCount = activePlayers.filter(p => votes[p] === true).length;
            const leaveCount = activePlayers.filter(p => votes[p] === false).length;
            const totalVotes = rematchCount + leaveCount;
            
            if(votingStatus) {
                votingStatus.innerText = `Abgestimmt: ${totalVotes}/${activePlayers.length}`;
            }
            
            if(votingResults) {
                const rematchList = activePlayers.filter(p => votes[p] === true).map(p => {
                    const playerData = data.players[p];
                    const playerEmoji = playerData?.emoji || 'üòä';
                    return `${playerEmoji} ${p}`;
                }).join(', ') || 'Niemand';
                
                const leaveList = activePlayers.filter(p => votes[p] === false).map(p => {
                    const playerData = data.players[p];
                    const playerEmoji = playerData?.emoji || 'üòä';
                    return `${playerEmoji} ${p}`;
                }).join(', ') || 'Niemand';
                
                votingResults.innerHTML = `
                    <div style="margin-bottom:10px;">‚úÖ Nochmal spielen (${rematchCount}): ${rematchList}</div>
                    <div>üö™ Verlassen (${leaveCount}): ${leaveList}</div>
                `;
            }
            
            // Buttons deaktivieren wenn bereits abgestimmt
            if(votes[myName] !== undefined) {
                if(btnRematch) btnRematch.disabled = true;
                if(btnLeave) btnLeave.disabled = true;
                if(votes[myName]) {
                    if(btnRematch) btnRematch.innerText = '‚úÖ Gew√§hlt';
                    if(btnLeave) btnLeave.innerText = 'üö™ Verlassen';
                } else {
                    if(btnRematch) btnRematch.innerText = '‚úÖ Nochmal spielen';
                    if(btnLeave) btnLeave.innerText = 'üö™ Gew√§hlt';
                }
            } else {
                if(btnRematch) btnRematch.disabled = false;
                if(btnLeave) btnLeave.disabled = false;
                if(btnRematch) btnRematch.innerText = '‚úÖ Nochmal spielen';
                if(btnLeave) btnLeave.innerText = 'üö™ Verlassen';
            }
            
            // Host kann Spiel starten wenn alle f√ºr Rematch gestimmt haben
            const hostSettingsDiv = document.getElementById('hostRematchSettings');
            if(isHost && totalVotes === activePlayers.length && rematchCount === activePlayers.length) {
                // Host-Einstellungen f√ºr neue Runde anzeigen
                if(!hostSettingsDiv) {
                    const settingsDiv = document.createElement('div');
                    settingsDiv.id = 'hostRematchSettings';
                    settingsDiv.style.cssText = 'margin-top:20px; padding:15px; background:rgba(255,69,0,0.1); border:2px solid #ff4500; border-radius:10px;';
                    settingsDiv.innerHTML = `
                        <h3 style="color:#ff8c00; margin-bottom:15px; font-size:1.1rem;">‚öôÔ∏è Einstellungen f√ºr neue Runde</h3>
                        <label style="display:block; font-size:0.85rem; color:#aaa; margin-top:10px; margin-bottom:5px; font-weight:500;">Spielmodus:</label>
                        <div id="rematchGameModeSelection" style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:15px;"></div>
                        <label style="display:block; font-size:0.85rem; color:#aaa; margin-top:10px; margin-bottom:5px; font-weight:500;">Kategorien w√§hlen:</label>
                        <div id="rematchCategorySelection" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(120px, 1fr)); gap:8px; margin-bottom:15px; max-height:200px; overflow-y:auto;"></div>
                        <button id="btnStartRematch" class="btn-primary" style="width:100%; margin-top:15px; padding:15px; font-size:1.2rem;">üéÆ Neue Runde starten</button>
                    `;
                    const winnerScreen = document.getElementById('screen-winner');
                    if(winnerScreen) {
                        const zIndexDiv = winnerScreen.querySelector('[style*="z-index:1"]');
                        if(zIndexDiv) {
                            zIndexDiv.appendChild(settingsDiv);
                        } else {
                            winnerScreen.appendChild(settingsDiv);
                        }
                    }
                    
                    // Spielmodus-Auswahl rendern
                    const gameModeDiv = document.getElementById('rematchGameModeSelection');
                    if(gameModeDiv) {
                        const currentMode = data.config?.gameMode || 'party';
                        gameModeDiv.innerHTML = `
                            <button class="game-mode-card ${currentMode === 'party' ? 'selected' : ''}" data-mode="party" onclick="selectRematchGameMode('party')" style="padding:12px; border-radius:8px; border:2px solid ${currentMode === 'party' ? '#ff4500' : '#333'}; background:${currentMode === 'party' ? 'rgba(255,69,0,0.2)' : 'rgba(255,255,255,0.05)'}; color:#fff; cursor:pointer; transition:all 0.3s;">
                                <div style="font-size:1.5rem; margin-bottom:5px;">üéâ</div>
                                <div class="mode-name" style="font-size:0.9rem; font-weight:bold;">Party-Modus</div>
                                <div style="font-size:0.7rem; color:#888; margin-top:3px;">Schnell & einfach</div>
                            </button>
                            <button class="game-mode-card ${currentMode === 'strategic' ? 'selected' : ''}" data-mode="strategic" onclick="selectRematchGameMode('strategic')" style="padding:12px; border-radius:8px; border:2px solid ${currentMode === 'strategic' ? '#ff4500' : '#333'}; background:${currentMode === 'strategic' ? 'rgba(255,69,0,0.2)' : 'rgba(255,255,255,0.05)'}; color:#fff; cursor:pointer; transition:all 0.3s;">
                                <div style="font-size:1.5rem; margin-bottom:5px;">üß†</div>
                                <div class="mode-name" style="font-size:0.9rem; font-weight:bold;">Strategie-Modus</div>
                                <div style="font-size:0.7rem; color:#888; margin-top:3px;">Mit Jokern</div>
                            </button>
                        `;
                    }
                    
                    // Kategorie-Auswahl rendern
                    const categoryDiv = document.getElementById('rematchCategorySelection');
                    if(categoryDiv) {
                        const currentCategories = data.config?.categories || [];
                        let html = '';
                        Object.keys(questionCategories).forEach(key => {
                            const cat = questionCategories[key];
                            const isSelected = currentCategories.includes(key);
                            html += `
                                <button class="category-card ${isSelected ? 'selected' : ''}" 
                                    data-category="${key}" 
                                    onclick="toggleRematchCategory('${key}')"
                                    style="padding:10px; border-radius:8px; border:2px solid ${isSelected ? '#ff4500' : '#333'}; background:${isSelected ? 'rgba(255,69,0,0.2)' : 'rgba(255,255,255,0.05)'}; color:#fff; cursor:pointer; transition:all 0.3s; text-align:center;">
                                    <div style="font-size:1.8rem; margin-bottom:5px;">${cat.emoji}</div>
                                    <div style="font-size:0.75rem; font-weight:bold;">${cat.name}</div>
                                </button>
                            `;
                        });
                        categoryDiv.innerHTML = html;
                    }
                    
                    // Start-Button Event
                    const startBtn = document.getElementById('btnStartRematch');
                    if(startBtn) {
                        startBtn.onclick = startRematchGame;
                    }
                }
            } else {
                // Entferne Host-Einstellungen wenn nicht mehr ben√∂tigt
                if(hostSettingsDiv) hostSettingsDiv.remove();
            }
        }

        // --- CONFETTI ---
        function startConfetti() {
            const container = document.getElementById('confetti-container');
            if(!container) return;
            
            const colors = ['#ffd700', '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7'];
            
            for(let i = 0; i < 100; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
                    confetti.style.animationDelay = Math.random() * 0.5 + 's';
                    container.appendChild(confetti);
                    
                    setTimeout(() => confetti.remove(), 5000);
                }, i * 20);
            }
        }

        // --- RENDER VOTING ---
        function renderVoting(data) {
            const votingStatus = document.getElementById('votingStatus');
            const votingResults = document.getElementById('votingResults');
            const btnRematch = document.getElementById('btnVoteRematch');
            const btnLeave = document.getElementById('btnVoteLeave');
            
            const votes = data.rematchVotes || {};
            const players = Object.keys(data.players);
            const activePlayers = players.filter(p => (data.players[p].temp || 0) < (data.config?.maxTemp || 100));
            
            const rematchCount = activePlayers.filter(p => votes[p] === true).length;
            const leaveCount = activePlayers.filter(p => votes[p] === false).length;
            const totalVotes = rematchCount + leaveCount;
            
            if(votingStatus) {
                votingStatus.innerText = `Abgestimmt: ${totalVotes}/${activePlayers.length}`;
            }
            
            if(votingResults) {
                votingResults.innerHTML = `
                    <div style="margin-bottom:10px;">‚úÖ Nochmal spielen: ${rematchCount}</div>
                    <div>üö™ Verlassen: ${leaveCount}</div>
                `;
            }
            
            // Buttons deaktivieren wenn bereits abgestimmt
            if(votes[myName] !== undefined) {
                if(btnRematch) btnRematch.disabled = true;
                if(btnLeave) btnLeave.disabled = true;
                if(votes[myName]) {
                    if(btnRematch) btnRematch.innerText = '‚úÖ Gew√§hlt';
                    if(btnLeave) btnLeave.innerText = 'üö™ Verlassen';
                } else {
                    if(btnRematch) btnRematch.innerText = '‚úÖ Nochmal spielen';
                    if(btnLeave) btnLeave.innerText = 'üö™ Gew√§hlt';
                }
            } else {
                if(btnRematch) btnRematch.disabled = false;
                if(btnLeave) btnLeave.disabled = false;
            }
            
            // Host kann Spiel starten wenn alle f√ºr Rematch gestimmt haben
            if(isHost && totalVotes === activePlayers.length && rematchCount === activePlayers.length) {
                // Host-Einstellungen f√ºr neue Runde anzeigen
                const hostSettingsDiv = document.getElementById('hostRematchSettings');
                if(!hostSettingsDiv) {
                    const settingsDiv = document.createElement('div');
                    settingsDiv.id = 'hostRematchSettings';
                    settingsDiv.style.cssText = 'margin-top:20px; padding:15px; background:rgba(255,69,0,0.1); border:2px solid #ff4500; border-radius:10px;';
                    settingsDiv.innerHTML = `
                        <h3 style="color:#ff8c00; margin-bottom:15px; font-size:1.1rem;">‚öôÔ∏è Einstellungen f√ºr neue Runde</h3>
                        <label style="display:block; font-size:0.85rem; color:#aaa; margin-top:10px; margin-bottom:5px; font-weight:500;">Spielmodus:</label>
                        <div id="rematchGameModeSelection" style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:15px;"></div>
                        <label style="display:block; font-size:0.85rem; color:#aaa; margin-top:10px; margin-bottom:5px; font-weight:500;">Kategorien w√§hlen:</label>
                        <div id="rematchCategorySelection" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(120px, 1fr)); gap:8px; margin-bottom:15px; max-height:200px; overflow-y:auto;"></div>
                        <button id="btnStartRematch" class="btn-primary" style="width:100%; margin-top:15px; padding:15px; font-size:1.2rem;">üéÆ Neue Runde starten</button>
                    `;
                    const votingCard = document.getElementById('screen-voting');
                    if(votingCard) votingCard.appendChild(settingsDiv);
                    
                    // Spielmodus-Auswahl rendern
                    const gameModeDiv = document.getElementById('rematchGameModeSelection');
                    if(gameModeDiv) {
                        const currentMode = data.config?.gameMode || 'party';
                        gameModeDiv.innerHTML = `
                            <button class="game-mode-card ${currentMode === 'party' ? 'selected' : ''}" onclick="selectRematchGameMode('party')" style="padding:12px; border-radius:8px; border:2px solid #333; background:rgba(255,255,255,0.05); color:#fff; cursor:pointer; transition:all 0.3s;">
                                <div style="font-size:1.5rem; margin-bottom:5px;">üéâ</div>
                                <div class="mode-name" style="font-size:0.9rem; font-weight:bold;">Party-Modus</div>
                                <div style="font-size:0.7rem; color:#888; margin-top:3px;">Schnell & einfach</div>
                            </button>
                            <button class="game-mode-card ${currentMode === 'strategic' ? 'selected' : ''}" onclick="selectRematchGameMode('strategic')" style="padding:12px; border-radius:8px; border:2px solid #333; background:rgba(255,255,255,0.05); color:#fff; cursor:pointer; transition:all 0.3s;">
                                <div style="font-size:1.5rem; margin-bottom:5px;">üß†</div>
                                <div class="mode-name" style="font-size:0.9rem; font-weight:bold;">Strategie-Modus</div>
                                <div style="font-size:0.7rem; color:#888; margin-top:3px;">Mit Jokern</div>
                            </button>
                        `;
                    }
                    
                    // Kategorie-Auswahl rendern
                    const categoryDiv = document.getElementById('rematchCategorySelection');
                    if(categoryDiv) {
                        const currentCategories = data.config?.categories || [];
                        let html = '';
                        Object.keys(questionCategories).forEach(key => {
                            const cat = questionCategories[key];
                            const isSelected = currentCategories.includes(key);
                            html += `
                                <button class="category-card ${isSelected ? 'selected' : ''}" 
                                    data-category="${key}" 
                                    onclick="toggleRematchCategory('${key}')"
                                    style="padding:10px; border-radius:8px; border:2px solid ${isSelected ? '#ff4500' : '#333'}; background:${isSelected ? 'rgba(255,69,0,0.2)' : 'rgba(255,255,255,0.05)'}; color:#fff; cursor:pointer; transition:all 0.3s; text-align:center;">
                                    <div style="font-size:1.8rem; margin-bottom:5px;">${cat.emoji}</div>
                                    <div style="font-size:0.75rem; font-weight:bold;">${cat.name}</div>
                                </button>
                            `;
                        });
                        categoryDiv.innerHTML = html;
                    }
                    
                    // Start-Button Event
                    const startBtn = document.getElementById('btnStartRematch');
                    if(startBtn) {
                        startBtn.onclick = startRematchGame;
                    }
                }
            } else {
                // Entferne Host-Einstellungen wenn nicht mehr ben√∂tigt
                const hostSettingsDiv = document.getElementById('hostRematchSettings');
                if(hostSettingsDiv) hostSettingsDiv.remove();
            }
        }

        // --- VOTE REMATCH ---
        window.voteRematch = async (wantRematch) => {
            await updateDoc(doc(db, "lobbies", roomId), {
                [`rematchVotes.${myName}`]: wantRematch
            });
        };
        
        // Rematch-Einstellungen
        let rematchGameMode = null;
        let rematchCategories = null;
        
        window.selectRematchGameMode = (mode) => {
            rematchGameMode = mode;
            const gameModeDiv = document.getElementById('rematchGameModeSelection');
            if(gameModeDiv) {
                gameModeDiv.querySelectorAll('button').forEach(btn => {
                    btn.classList.remove('selected');
                    btn.style.borderColor = '#333';
                    btn.style.background = 'rgba(255,255,255,0.05)';
                });
                const selectedBtn = gameModeDiv.querySelector(`button[data-mode="${mode}"]`);
                if(selectedBtn) {
                    selectedBtn.classList.add('selected');
                    selectedBtn.style.borderColor = '#ff4500';
                    selectedBtn.style.background = 'rgba(255,69,0,0.2)';
                }
            }
        };
        
        window.toggleRematchCategory = (category) => {
            if(!rematchCategories) {
                rematchCategories = [...(globalData?.config?.categories || Object.keys(questionCategories))];
            }
            const index = rematchCategories.indexOf(category);
            if(index > -1) {
                rematchCategories.splice(index, 1);
            } else {
                rematchCategories.push(category);
            }
            
            // Update UI
            const categoryBtn = document.querySelector(`#rematchCategorySelection button[data-category="${category}"]`);
            if(categoryBtn) {
                const isSelected = rematchCategories.includes(category);
                categoryBtn.classList.toggle('selected', isSelected);
                categoryBtn.style.borderColor = isSelected ? '#ff4500' : '#333';
                categoryBtn.style.background = isSelected ? 'rgba(255,69,0,0.2)' : 'rgba(255,255,255,0.05)';
            }
        };

        // --- START REMATCH ---
        window.startRematchGame = async () => {
            if(!isHost) return;
            
            // Verwende neue Einstellungen falls gesetzt, sonst behalte alte
            const newGameMode = rematchGameMode || globalData.config?.gameMode || 'party';
            const newCategories = rematchCategories || globalData.config?.categories || Object.keys(questionCategories);
            
            // Validierung: Mindestens eine Kategorie muss ausgew√§hlt sein
            if(newCategories.length === 0) {
                showToast("Bitte w√§hle mindestens eine Kategorie!");
                return;
            }
            
            // Berechne Config basierend auf Modus
            let dmg, speed, startTemp, maxTemp;
            if(newGameMode === 'party') {
                dmg = 20;
                speed = 10;
                startTemp = 0;
                maxTemp = 100;
            } else {
                dmg = 10;
                speed = 10;
                startTemp = 0;
                maxTemp = 100;
            }
            
            const pClean = {};
            Object.keys(globalData.players).forEach(p => {
                pClean[p] = { temp: startTemp, inventory: [], emoji: globalData.players[p].emoji || 'üòä', gender: globalData.players[p].gender || 'divers' };
            });
            
            // Erste Frage aus neuen Kategorien
            const firstQuestion = getAllQuestions(newCategories)[0] || { q: "Willkommen zu Hitzkopf!", a: "A", b: "B" };
            const firstCategory = firstQuestion.category || null;
            
            await updateDoc(doc(db, "lobbies", roomId), {
                status: 'lobby',
                players: pClean,
                votes: {},
                ready: [],
                log: arrayUnion("‚ôªÔ∏è Neue Runde gestartet! Alle Temperaturen wurden zur√ºckgesetzt."),
                hotseat: "",
                roundId: 0,
                lobbyReady: {},
                countdownEnds: null,
                usedQuestions: [],
                rematchVotes: {},
                eliminatedShown: [],
                winner: null,
                config: { dmg, speed, startTemp, maxTemp, gameMode: newGameMode, categories: newCategories },
                currentQ: firstQuestion,
                lastQuestionCategory: firstCategory,
                pendingAttacks: {},
                attackResults: {},
                popupConfirmed: {}
            });
            
            // Reset Rematch-Einstellungen
            rematchGameMode = null;
            rematchCategories = null;
            
            document.body.classList.remove('final-mode');
            showToast("Neue Runde gestartet!");
        };

        // --- SHOW ATTACK ANIMATION ---
        async function showAttackAnimation(targetName, attackerName, dmg, newTemp) {
            const overlay = document.getElementById('fullscreenAnimation');
            if(!overlay) return;
            
            const emojiEl = document.getElementById('animEmoji');
            const nameEl = document.getElementById('animName');
            const textEl = document.getElementById('animText');
            const thermoEl = document.getElementById('animThermoFill');
            const tempEl = document.getElementById('animTemp');
            
            if(emojiEl) emojiEl.innerText = 'üî•';
            if(nameEl) nameEl.innerText = targetName;
            if(textEl) textEl.innerText = `${attackerName} hat ${targetName} aufgeheizt (+${dmg}¬∞C)`;
            if(tempEl) tempEl.innerText = `${newTemp}¬∞C`;
            
            overlay.style.display = 'flex';
            
            // Thermometer animieren
            if(thermoEl) {
                thermoEl.style.width = '0%';
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        thermoEl.style.width = `${Math.min((newTemp / 100) * 100, 100)}%`;
                    });
                });
            }
            
            // Nach 3 Sekunden ausblenden
            await sleep(3000);
            overlay.style.display = 'none';
        }

        // --- SHOW JOKER ANIMATION ---
        async function showJokerAnimation(playerName, cardName) {
            const overlay = document.getElementById('fullscreenAnimation');
            if(!overlay) return;
            
            const emojiEl = document.getElementById('animEmoji');
            const nameEl = document.getElementById('animName');
            const textEl = document.getElementById('animText');
            const thermoEl = document.getElementById('animThermoFill');
            const tempEl = document.getElementById('animTemp');
            
            const cardInfo = {
                card_oil: { emoji: 'üõ¢Ô∏è', name: '√ñlfass' },
                card_mirror: { emoji: 'ü™û', name: 'Spiegel' },
                card_ice: { emoji: 'üßä', name: 'Eisw√ºrfel' }
            };
            
            const info = cardInfo[cardName] || { emoji: 'üÉè', name: 'Joker' };
            
            if(emojiEl) emojiEl.innerText = info.emoji;
            if(nameEl) nameEl.innerText = playerName;
            if(textEl) textEl.innerText = `hat einen Joker gezogen: ${info.name} - Aufgepasst! üÉè`;
            if(tempEl) tempEl.innerText = '';
            
            overlay.style.display = 'flex';
            
            // Thermometer ausblenden
            if(thermoEl) thermoEl.style.width = '0%';
            
            // Nach 3 Sekunden ausblenden
            await sleep(3000);
            overlay.style.display = 'none';
        }

    </script>
</body>
</html>
